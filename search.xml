<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件安装参考网站</title>
      <link href="/2019/02/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/"/>
      <url>/2019/02/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文包含一些软件的优秀安装指南，都是亲测可用的。以备以后重新安装系统快速使用，本文会热更新。</p><p>每段的格式为：</p><ul><li><p>[已有教程网址]</p></li><li><p>[排除教程中的坑]</p></li><li><p>[对教程中的简要概括(防止教程404)]</p></li></ul><hr><h2 id="蓝灯lantern"><a href="#蓝灯lantern" class="headerlink" title="蓝灯lantern"></a>蓝灯lantern</h2><ul><li><p>教程：<a href="http://www.pianshen.com/article/5553973/" target="_blank" rel="noopener">lantern傻瓜式安装教程</a></p></li><li><p>排坑：进入 <a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">https://github.com/getlantern/lantern</a> 最下面。如果左击 <strong>ubuntu 14.04 64 bit</strong> 后没有直接下载：右击 <strong>ubuntu 14.04 64 bit</strong> 用迅雷下载链接。</p></li></ul><hr><h2 id="sublime-text-3"><a href="#sublime-text-3" class="headerlink" title="sublime text 3"></a>sublime text 3</h2><ul><li><p>教程：<a href="https://jingyan.baidu.com/article/64d05a023cd849de55f73be4.html" target="_blank" rel="noopener">命令行安装sublime text 3</a></p></li><li><p>概括：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三条命令即可</span><br><span class="line">sudo add-apt-repository ppa:webupd8team/sublime-text-3</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sublime-text-installer</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust环境安装/Ubuntu 16.04</title>
      <link href="/2019/02/03/Rust%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2019/02/03/Rust%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>vct说Rust环境配置很复杂，小李哥不信邪地来打算试一试。本篇为踩坑之路。</p><p>操作系统：Ubuntu 16.04</p><hr><h2 id="1-安装curl"><a href="#1-安装curl" class="headerlink" title="1-安装curl"></a>1-安装curl</h2><blockquote><p>$ apt install curl</p></blockquote><hr><h2 id="2-安装rustup"><a href="#2-安装rustup" class="headerlink" title="2-安装rustup"></a>2-安装rustup</h2><blockquote><p>$ curl <a href="https://sh.rustup.rs" target="_blank" rel="noopener">https://sh.rustup.rs</a> -sSf | sh</p></blockquote><p>这个命令会帮你装好rustc, cargo等一系列后面要用到的东西，可以说是一键安装了。</p><p>中途会遇到这个3个选项，需要选一个，手动输入1，回车。</p><p><img src="http://pm3e2l94n.bkt.clouddn.com/blog/20190203/9RxHSEakBk0l.png?imageslim" alt="rustup安装选项"></p><p>安装成功后提示</p><p><img src="http://pm3e2l94n.bkt.clouddn.com/blog/20190203/ndYNwqsuQTug.png?imageslim" alt="rustup安装成功"></p><p>然后<strong>重启系统</strong>，重启会使得<strong>rust被添加到PATH中</strong>。这一步很重要。</p><p>重启后，查看是否成功。</p><blockquote><p>$ rustc –version</p></blockquote><p><img src="http://pm3e2l94n.bkt.clouddn.com/blog/20190203/O5BaPiTGa1Od.png?imageslim" alt="rustc版本"></p><hr><h2 id="3-Hello-world"><a href="#3-Hello-world" class="headerlink" title="3-Hello, world!"></a>3-Hello, world!</h2><p>Rust源文件以.rs结尾，文件中的单词以下划线分割，编写hello_world.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译+运行</p><blockquote><p>$ rustc hello_world.rs -o hello_world</p></blockquote><blockquote><p>$ ./hello_world</p></blockquote><p>如果显示如下，那便成功了。</p><p><img src="http://pm3e2l94n.bkt.clouddn.com/blog/20190203/GORFIM2pAXJI.png?imageslim" alt="Hello_world"></p><hr><h2 id="4-换中科大的源"><a href="#4-换中科大的源" class="headerlink" title="4-换中科大的源"></a>4-换中科大的源</h2><p>按照上面完成后，rustc和cargo都应该自动装好了。但问题在于，速度不够快。使用cargo管理项目的时候，会涉及更新问题，但rust是被墙挡在外面的，更新速度慢是小事，可是卡的根本更新不了，就是大事了。</p><p>所以我们需要，换 <strong>中科大的源</strong> 。</p><p>操作如下：</p><ul><li>在完成上面的步骤的基础上</li><li><p>进入<strong>root</strong>目录，如果有 <strong>.cargo</strong> 目录就进入(应该是一个隐藏目录， <figure class="highlight ls"><figcaption><span>-a``` 查看)，没有就新建一个 **.cargo** 目录，然后进入</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 进入 **.cargo** 目录后，如果有 **config** 文件就打开，没有就新建 **config** 文件</span><br><span class="line">* 在 **config** 文件中写入如下内容，保存退出</span><br></pre></td></tr></table></figure></p><p>  [source.crates-io]<br>  registry = “<a href="https://github.com/rust-lang/crates.io-index&quot;" target="_blank" rel="noopener">https://github.com/rust-lang/crates.io-index&quot;</a><br>  replace-with = ‘ustc’<br>  [source.ustc]<br>  registry = “git://mirrors.ustc.edu.cn/crate.io-index”<br>  <code>`</code></p></li><li>然后重启一下系统就行了，以后更新就不用翻墙啦。</li></ul><hr><h2 id="5-疑难杂症"><a href="#5-疑难杂症" class="headerlink" title="5-疑难杂症"></a>5-疑难杂症</h2><p>小李哥遇到一个奇怪的问题，就是2-安装rustup完成后，重启，查看version后发现是ok的。结果装了个vim，敲完hello_world.rs，编译的时候它提示：找不到rustc！我再查看version的时候发现我的rustc没了？！</p><p>很玄学……我重启了一下系统就好了，原因未知。</p><p>emmm……查看cargo的version时再次遇到找不到cargo！rustc也找不到了！和上次的共同之处在于：我试图关闭终端的时候提示还有进程在运行，然后我直接关掉终端，再次打开终端，cargo和rustc再次出现！</p><p>真奇怪啊……</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 环境安装 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS2019_winter</title>
      <link href="/2019/01/31/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/31/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习笔记2019winter"><a href="#操作系统学习笔记2019winter" class="headerlink" title="操作系统学习笔记2019winter"></a>操作系统学习笔记2019winter</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经一年半的学习，发现计科本科生课程中与计算机原理相关的课程多是隔靴搔痒，用到时再查书/百度也不迟，故接下来的课程中将关注点放在各章的开头1~2节，若有兴趣再继续深入。</p><p>参考书目：《操作系统教程（第5版）》费翔林</p><hr><h2 id="第一章-操作系统概论"><a href="#第一章-操作系统概论" class="headerlink" title="第一章 操作系统概论"></a>第一章 操作系统概论</h2><h3 id="PPT内容主要讲述以下问题："><a href="#PPT内容主要讲述以下问题：" class="headerlink" title="PPT内容主要讲述以下问题："></a>PPT内容主要讲述以下问题：</h3><p><strong>1. 单道/多道程序的CPU效率问题。</strong></p><p><strong>2. 对于一个操作系统来说，它要有哪些功能？</strong></p><p><strong>3. 从发明至今，有哪些操作系统，特点是什么？</strong></p><hr><h2 id="第三章-同步、通信与死锁"><a href="#第三章-同步、通信与死锁" class="headerlink" title="第三章 同步、通信与死锁"></a>第三章 同步、通信与死锁</h2><h3 id="PPT内容主要讲述以下问题：-1"><a href="#PPT内容主要讲述以下问题：-1" class="headerlink" title="PPT内容主要讲述以下问题："></a>PPT内容主要讲述以下问题：</h3><p><strong>什么是并发进程？</strong></p><hr><p><strong>并发进程与时间无关的充分条件Bernstein条件</strong></p><blockquote><p><strong>Bernstein条件</strong>：</p><p>设进程<strong>A</strong>引用变量集合为<strong>R1</strong>，改变变量集合为<strong>W1</strong>，进程<strong>B</strong>引用变量集合为<strong>R2</strong>，改变变量集合为<strong>W2</strong>。那么只要满足：</p><p>(R1 ∩ W2) ∪ (R2 ∩ W1) ∪ (W1 ∩ W2) = ∅</p><p>那么进程<strong>A</strong>和进程<strong>B</strong>与时间无关。</p></blockquote><blockquote><p>简而言之就是A和B的读写不冲突，也不会往同一个变量里写。</p></blockquote><hr><p><strong>并发进程间的交互：</strong></p><ul><li>竞争关系/间接制约关系：对于同一资源区，进程互斥访问，一个进程在用资源区的时候，其他进程只能等着</li><li>协作关系/直接制约关系：进程间互发信号控制对方是沉睡还是唤醒</li></ul><hr><p><strong>并发进程引起的时间问题：</strong></p><ul><li>结果不唯一，比如订票，抢红包</li><li>永远等待</li></ul><hr><p><strong>临界区(critial section)是什么？</strong></p><blockquote><p>定义：共享资源所在程序段</p><p>调度原则：</p><ul><li>一次只能进一个</li><li>里面的，不能一直呆在里面</li><li>外面的，不能一直等在外面</li><li>有空让进，无空等待，择一而入，算法可行</li></ul></blockquote><hr><p><strong>临界区管理方法：</strong></p><ul><li><p>先检测，后置位。弊端是检测完后可能有其他进程也进入临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inside1, inside2: Boolean</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br><span class="line">inside2 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>先置位，后检测。弊端是置位后可能inside2又被置1，可能永远等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>临界区管理软件方法：</strong></p><ol><li><p>Dekker算法</p><blockquote><p>基本思想：</p><ol><li>进程P1进入临界区时，将inside1置为true。</li><li>若P2在临界区，则P1等待。若P2不在临界区但也想进入，询问turn变量，由turn指示谁进入。若P2不在临界区且不想进入临界区，那么P1进入临界区。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Peterson算法</p><blockquote><p>基本思想：</p><ol><li>进程P1进入临界区时，将inside1置为true，指示器turn置为2。</li><li>若P2在临界区内且turn为2，则P1等待。否则P1进入临界区，然后inside1置为false。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol><hr><p><strong>临界区管理硬件方法：</strong></p><ol><li><p>关中断</p><p> 进入临界区前关中断，进入临界区，出临界区后开中断</p></li><li><p>用TS指令(test and set)</p><p> 反复TS代表临界区的lock变量，即“上锁”，如果该临界区空闲，会返回true，否则返回false。如果空闲，就进入临界区，否则一直反复。出临界区后lock置为true，即“开锁”。</p><blockquote><p>TS(x)指令等价于这段代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TS</span><span class="params">(<span class="keyword">bool</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">true</span>)&#123;</span><br><span class="line">        x = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><ol start="3"><li><p>用SWAP指令(在x86-64架构下是XCHG指令)</p><p> 一开始置临界区的lock变量为false，进程P的变量为key，置为true。交换一次lock和key(“上锁”)就检测一次key，如果key为false，说明临界区此时为空闲，进入临界区，出来后再次交换lock和key，即“开锁”。</p><p> 代码：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> lock = <span class="literal">false</span>;</span><br><span class="line">cobegin</span><br><span class="line">    <span class="function">process <span class="title">P</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            SWAP(key, lock);    <span class="comment">//上锁</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(key);</span><br><span class="line">        临界区;</span><br><span class="line">        SWAP(key, lock);        <span class="comment">//开锁</span></span><br><span class="line">    &#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure></li></ol><hr><p><strong>进程同步问题</strong></p><p><del>书上没讲定义，按我的理解就是对共享资源的读写一致性问题，说白了还是前面的并发进程问题没解决呗</del>。</p><p>百度说，进程同步是指的进程相互协作、等待的过程。</p><p>同步的办法有3种，信号量与PV操作、管程、消息传递。</p><hr><p><strong>信号量与PV操作</strong></p><p>信号量用来表示一个物理资源的使用情况，PV操作用来控制资源使用。</p><p>同步原语：P(Proberen,测试)，V(Verhogen,增量)。</p><p>除了赋初值外，信号量只能由同步原语操作。</p><p>(所谓原语，就是一段在执行过程中不许中断的指令序列)</p><hr><p><strong>管程</strong></p><hr><p><strong>进程通信</strong></p><hr><p><strong>死锁问题</strong></p><hr><p><strong>具体问题的解决方案</strong></p><ul><li>生产者-消费者问题</li><li>五个哲学家吃通心面问题</li><li>读者-写者问题</li><li>理发师问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
