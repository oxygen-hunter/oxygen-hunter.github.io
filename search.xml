<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OS讲课笔记</title>
      <link href="/2020/07/10/OS%E8%AE%B2%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/07/10/OS%E8%AE%B2%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>OS讲课笔记</p><hr><h1 id="ch1-概论"><a href="#ch1-概论" class="headerlink" title="ch1 概论"></a>ch1 概论</h1><h2 id="需要掌握的问题"><a href="#需要掌握的问题" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol><li>应用软件、支撑软件/系统软件、操作系统、硬件的层级关系</li><li>操作系统的两大功能是什么？</li><li>按功能和使用方式划分，操作系统有哪三种？</li><li>多道程序设计中，CPU的利用率怎么算？</li><li>多道程序设计提高了什么？损失了什么？</li><li>应用程序调用fprintf()之后，调用关系是怎样的？</li><li>系统调用的处理过程是怎样的？在用户态做了哪些事，在内核态做了哪些事？</li><li>系统调用和函数调用的区别？从调用方式/被调用代码位置/提供者回答</li><li>操作系统的三个基本元素是什么？</li><li>内核需要提供的4个基本功能是什么？</li><li>微内核和宏内核（也叫单内核）的优劣对比</li><li>微内核Linux和宏内核的操作系统代表有哪些？</li><li>操作系统的功能在用户进程内执行的代表是？作为独立进程执行的代表是？</li></ol><h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><h3 id="1-应用软件、支撑软件-系统软件、操作系统、硬件的层级关系"><a href="#1-应用软件、支撑软件-系统软件、操作系统、硬件的层级关系" class="headerlink" title="1. 应用软件、支撑软件/系统软件、操作系统、硬件的层级关系"></a>1. 应用软件、支撑软件/系统软件、操作系统、硬件的层级关系</h3><p>知道那张层次图、知道系统软件是编译器、数据库</p><h3 id="2-操作系统的两大功能是什么？"><a href="#2-操作系统的两大功能是什么？" class="headerlink" title="2. 操作系统的两大功能是什么？"></a>2. 操作系统的两大功能是什么？</h3><p>对上层：提供资源抽象</p><p>对下层：管理硬件</p><h3 id="3-按功能和使用方式划分，操作系统有哪三种？"><a href="#3-按功能和使用方式划分，操作系统有哪三种？" class="headerlink" title="3. 按功能和使用方式划分，操作系统有哪三种？"></a>3. 按功能和使用方式划分，操作系统有哪三种？</h3><p>批处理操作系统、分时操作系统、实时操作系统</p><h3 id="4-多道程序设计中，CPU的利用率怎么算？"><a href="#4-多道程序设计中，CPU的利用率怎么算？" class="headerlink" title="4. 多道程序设计中，CPU的利用率怎么算？"></a>4. 多道程序设计中，CPU的利用率怎么算？</h3><p>那两张图会算就行，利用率 = CPU时间/一个作业周期时间</p><h3 id="5-多道程序设计提高了什么？损失了什么？"><a href="#5-多道程序设计提高了什么？损失了什么？" class="headerlink" title="5. 多道程序设计提高了什么？损失了什么？"></a>5. 多道程序设计提高了什么？损失了什么？</h3><p>提高了资源利用率，增加了用户响应时间</p><h3 id="6-应用程序调用fprintf-之后，调用关系是怎样的？"><a href="#6-应用程序调用fprintf-之后，调用关系是怎样的？" class="headerlink" title="6. 应用程序调用fprintf()之后，调用关系是怎样的？"></a>6. 应用程序调用fprintf()之后，调用关系是怎样的？</h3><p>C库的fprintf() -&gt; C库的write() -&gt; write系统调用 -&gt; sys_write处理函数</p><h3 id="7-系统调用的处理过程是怎样的？在用户态做了哪些事，在内核态做了哪些事？"><a href="#7-系统调用的处理过程是怎样的？在用户态做了哪些事，在内核态做了哪些事？" class="headerlink" title="7. 系统调用的处理过程是怎样的？在用户态做了哪些事，在内核态做了哪些事？"></a>7. 系统调用的处理过程是怎样的？在用户态做了哪些事，在内核态做了哪些事？</h3><ol><li>设置系统调用号和参数（用户态）</li><li>陷入内核态（内核态）</li><li>保护被中断进程的CPU环境，将处理机状态字PSW、程序计数器PC、系统调用号、用户栈指针以及通用寄存器内容等压入内核堆栈（内核态）</li><li>根据系统调用号，作为下标，查系统调用入口表（内核态）</li><li>转到对应的处理函数处理（内核态）</li><li>恢复被中断进程的现场（内核态）</li><li>返回用户态，继续执行被中断进程的下一条指令（用户态）</li></ol><h3 id="8-系统调用和函数调用的区别？从调用方式-被调用代码位置-提供者回答"><a href="#8-系统调用和函数调用的区别？从调用方式-被调用代码位置-提供者回答" class="headerlink" title="8. 系统调用和函数调用的区别？从调用方式/被调用代码位置/提供者回答"></a>8. 系统调用和函数调用的区别？从调用方式/被调用代码位置/提供者回答</h3><p>调用方式：系统调用是用trap/int调用，函数调用用call 函数名调用</p><p>被调代码位置：内核代码，进程代码</p><p>提供者：操作系统，编程语言</p><h3 id="9-操作系统的三个基本元素是什么？"><a href="#9-操作系统的三个基本元素是什么？" class="headerlink" title="9. 操作系统的三个基本元素是什么？"></a>9. 操作系统的三个基本元素是什么？</h3><p>内核、进程、线程</p><h3 id="10-内核需要提供的4个基本功能是什么？"><a href="#10-内核需要提供的4个基本功能是什么？" class="headerlink" title="10. 内核需要提供的4个基本功能是什么？"></a>10. 内核需要提供的4个基本功能是什么？</h3><p>中断管理、时钟管理、进程调度、原语管理</p><h3 id="11-微内核和宏内核（也叫单内核）的优劣对比"><a href="#11-微内核和宏内核（也叫单内核）的优劣对比" class="headerlink" title="11. 微内核和宏内核（也叫单内核）的优劣对比"></a>11. 微内核和宏内核（也叫单内核）的优劣对比</h3><p>微内核：灵活、独立、稳定、便于维护。但进程通信开销大，效率低</p><p>宏内核：效率高，但不稳定，不易维护</p><h3 id="12-微内核和宏内核的操作系统代表有哪些？各举1个"><a href="#12-微内核和宏内核的操作系统代表有哪些？各举1个" class="headerlink" title="12. 微内核和宏内核的操作系统代表有哪些？各举1个"></a>12. 微内核和宏内核的操作系统代表有哪些？各举1个</h3><p>微内核：Minix、QNX、Mach</p><p>宏内核：Linux、Unix</p><p>（另，windows和mac os都是宏内核，不过借鉴了微内核的设计思路，不是纯粹的宏内核，所以不做明确分类，如果考到了，写宏内核）</p><h3 id="13-操作系统的功能在用户进程内执行的代表是？作为独立进程执行的代表是？"><a href="#13-操作系统的功能在用户进程内执行的代表是？作为独立进程执行的代表是？" class="headerlink" title="13. 操作系统的功能在用户进程内执行的代表是？作为独立进程执行的代表是？"></a>13. 操作系统的功能在用户进程内执行的代表是？作为独立进程执行的代表是？</h3><p>在用户进程执行的：unix</p><p>作为独立进程执行的：windows</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计网讲课笔记</title>
      <link href="/2020/07/10/%E8%AE%A1%E7%BD%91%E8%AE%B2%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/07/10/%E8%AE%A1%E7%BD%91%E8%AE%B2%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>计网讲课笔记</p><hr><h1 id="ch1-概论"><a href="#ch1-概论" class="headerlink" title="ch1 概论"></a>ch1 概论</h1><h2 id="需要掌握的问题"><a href="#需要掌握的问题" class="headerlink" title="需要掌握的问题"></a>需要掌握的问题</h2><ol><li>Internet是什么？由什么组成？</li><li>网络边缘是什么？</li><li>接入网络是什么？</li><li>网络核心是什么？</li><li>电路交换、分组交换、虚电路是怎么运作的？</li><li>为什么需要多层协议体系结构？（分层的好处）</li><li>OSI七层模型是哪七层？每一层的功能是什么？</li><li>TCP/IP模型是哪五层、每一层的功能是什么？</li><li>七层和五层的对应关系是什么样的？</li><li>网络核心是如何传输数据的（网络核心的两大功能）</li><li>电子邮件用到的应用层协议名称</li></ol><h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><h3 id="1-Internet是什么？由什么组成？"><a href="#1-Internet是什么？由什么组成？" class="headerlink" title="1. Internet是什么？由什么组成？"></a>1. Internet是什么？由什么组成？</h3><p>因特网是许多小网络相互连接而成，小网络中包含终端、路由器、网络传输介质</p><p>三大组成：网络边缘、接入网络、网络核心</p><h3 id="2-网络边缘是什么？"><a href="#2-网络边缘是什么？" class="headerlink" title="2. 网络边缘是什么？"></a>2. 网络边缘是什么？</h3><p>终端，比如手机、笔记本、智能手环、智能家电等等</p><h3 id="3-接入网络是什么？"><a href="#3-接入网络是什么？" class="headerlink" title="3. 接入网络是什么？"></a>3. 接入网络是什么？</h3><p>物理传输介质，比如双绞线、光纤</p><p>无线链路</p><h3 id="4-网络核心是什么？"><a href="#4-网络核心是什么？" class="headerlink" title="4. 网络核心是什么？"></a>4. 网络核心是什么？</h3><p>路由器（这里的路由器不是单单指家里的那个路由器，他是具备转发和路由功能的机器的统称）</p><h3 id="5-电路交换、分组交换、虚电路是怎么运作的？"><a href="#5-电路交换、分组交换、虚电路是怎么运作的？" class="headerlink" title="5. 电路交换、分组交换、虚电路是怎么运作的？"></a>5. 电路交换、分组交换、虚电路是怎么运作的？</h3><p>电路交换：类似于老电话，你告诉接线员你想打哪个号码，接线员给你接上去，建立专用电路，期间一直霸占专用电路，结束时拆除专用电路，实现简单，保证报文有序到达</p><p>分组交换：不建立专用电路，把长报文切成小块（分组），每个分组都记录源地址、目标地址、在长报文中的编号，然后逐个发出去。由于每个分组走的路不一定相同，所以需要处理达到报文乱序的问题、丢包问题、排队问题</p><p>虚电路：还是发分组，但是路由的路径预先确定好，需要建立虚电路-通信-拆除虚电路，期间不会霸占线路</p><h3 id="6-为什么需要多层协议体系结构？（分层的好处）"><a href="#6-为什么需要多层协议体系结构？（分层的好处）" class="headerlink" title="6. 为什么需要多层协议体系结构？（分层的好处）"></a>6. 为什么需要多层协议体系结构？（分层的好处）</h3><p>为上层屏蔽下层的细节，更专心上层的功能实现</p><p>每一层在更新自己的时候，只需要保持对上和对下的接口不变，提供的服务不变即可，不需要改动整体架构</p><h3 id="7-OSI七层模型是哪七层？每一层的功能是什么？"><a href="#7-OSI七层模型是哪七层？每一层的功能是什么？" class="headerlink" title="7. OSI七层模型是哪七层？每一层的功能是什么？"></a>7. OSI七层模型是哪七层？每一层的功能是什么？</h3><p>OSI七层从下到上分别是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><p>每一层都负责提供给上层更强一点的功能</p><p>物理层：按比特传数据，可能发生错误，常用介质是光纤、双绞线</p><ul><li>宏观上是光纤的两端在通信</li></ul><p>数据链路层：按帧（帧就是有格式的比特串）传数据，可以保证帧传出去和接到的是一样的，没有比特错误</p><ul><li>宏观上是两台有MAC地址的交换机在通信</li></ul><p>网络层：<strong>尽力</strong>让数据包（数据包就是头部信息+链路层的帧）到达目的地</p><ul><li>宏观上是两台有IP地址的计算机在通信</li></ul><p>传输层：<strong>保证</strong>让传输层的包（头部信息+数据包）到达目的地</p><ul><li>一台计算机上的一个进程，和另一台计算机上的一个进程的通信，标识符是进程的端口号</li></ul><p>会话层、表示层、应用层：通过前面4层发送数据，从而实现交流</p><p><em>示意图：应用层的信息M是如何一层层封装，传到另一台计算机，再一层层解封装的</em></p><p><img src="/2020/07/10/计网讲课笔记/image-20200710183325823.png" alt="image-20200710183325823"></p><p>777</p><h3 id="8、TCP-IP模型是哪五层、每一层的功能是什么？"><a href="#8、TCP-IP模型是哪五层、每一层的功能是什么？" class="headerlink" title="8、TCP/IP模型是哪五层、每一层的功能是什么？"></a>8、TCP/IP模型是哪五层、每一层的功能是什么？</h3><p>物理层、数据链路层、网络层、传输层、应用层</p><h3 id="9-七层和五层的对应关系是什么样的？"><a href="#9-七层和五层的对应关系是什么样的？" class="headerlink" title="9. 七层和五层的对应关系是什么样的？"></a>9. 七层和五层的对应关系是什么样的？</h3><p>七层里的上三层（会话层，表示层，应用层）合并为应用层</p><h3 id="10-网络核心是如何传输数据的（网络核心的两大功能）"><a href="#10-网络核心是如何传输数据的（网络核心的两大功能）" class="headerlink" title="10. 网络核心是如何传输数据的（网络核心的两大功能）"></a>10. 网络核心是如何传输数据的（网络核心的两大功能）</h3><p>路由和转发</p><p>路由：选择下一跳应该发往哪个router</p><p>转发：把数据从router的入口发往路由器的出口</p><h3 id="11-电子邮件用到的应用层协议名称"><a href="#11-电子邮件用到的应用层协议名称" class="headerlink" title="11. 电子邮件用到的应用层协议名称"></a>11. 电子邮件用到的应用层协议名称</h3><p>SMTP、MINE、POP、IMAP</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记</title>
      <link href="/2020/01/27/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/27/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h1><h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h2><ol><li><p>每次截取末位，*10，叠加，直到原数x = 0</p></li><li><p>处理溢出，整数范围在-2147483648~2147483647，每次要溢出之前都是大于2147483647/10，或者小于-2147483648/10，所以只要判定一下即可</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每次截取末位，*10，叠加</span></span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (last &gt; <span class="number">2147483647</span> / <span class="number">10</span> ||</span><br><span class="line">                last &lt; <span class="number">-2147483648</span> / <span class="number">10</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            last = last * <span class="number">10</span>;</span><br><span class="line">            last += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h2><ol><li>首先，负数不是回文数</li><li>对非负数，先得到逆序数，再判断是否和原数相等</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oldx = x;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (last &gt; <span class="number">2147483647</span> / <span class="number">10</span> ||</span><br><span class="line">                last &lt; <span class="number">-2147483648</span> / <span class="number">10</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    last = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            last = last * <span class="number">10</span>;</span><br><span class="line">            last += x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last == oldx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>官方题解说只要翻转一半的数字就可以了，同时可以避免溢出，如何判断到一半了呢？条件是x &lt; lastx</p><p>12345 - 54321，12345|0，1234|5，123|54，12|543。翻转到123 和543是否相等？12和54</p><p>123456-654321，123456|0,12345|6,12345|65,123|654。翻转到123和654是否相等，</p><p>修改了代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//负数，末位为0但本身不是0的数</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; lastx)</span><br><span class="line">        &#123;</span><br><span class="line">            lastx = lastx * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于偶数长度的x，lastx == x</span></span><br><span class="line">        <span class="comment">//对于奇数长度的x，lastx / 10 == x</span></span><br><span class="line">        <span class="keyword">return</span> lastx == x || lastx / <span class="number">10</span> == x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h2><p>一位位处理即可，遇到IXC，就再看下一位一起处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历，假设当前字符为c1，下个字符为c2</span></span><br><span class="line">        <span class="comment">//c1=I, 若c2=V,X, 4和9</span></span><br><span class="line">        <span class="comment">//c1=X, 若c2=L,C, 40和90</span></span><br><span class="line">        <span class="comment">//c1=C, 若c2=D,M, 400和900</span></span><br><span class="line">        <span class="comment">//其他, +对应</span></span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                help(i, s, N, <span class="string">'V'</span>, <span class="string">'X'</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">                help(i, s, N, <span class="string">'L'</span>, <span class="string">'C'</span>, <span class="number">40</span>, <span class="number">90</span>, <span class="number">10</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">                help(i, s, N, <span class="string">'D'</span>, <span class="string">'M'</span>, <span class="number">400</span>, <span class="number">900</span>, <span class="number">100</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'V'</span>:</span><br><span class="line">                N += <span class="number">5</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">                N += <span class="number">50</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">                N += <span class="number">500</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">                N += <span class="number">1000</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>&amp; i, <span class="built_in">string</span>&amp; s, <span class="keyword">int</span>&amp; N, <span class="keyword">char</span> c1, <span class="keyword">char</span> c2, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">int</span> n3)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i+<span class="number">1</span> &lt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i+<span class="number">1</span>] == c1)</span><br><span class="line">            &#123;</span><br><span class="line">                N += n1;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i+<span class="number">1</span>] == c2)</span><br><span class="line">            &#123;</span><br><span class="line">                N += n2;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                N += n3;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            N += n3;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>上面的方法写的不够简洁，遇到改需求（比如IXC之类的改成别的字符会比较麻烦）会大改代码，看了一篇写的挺简洁的，即把我的help函数改成查表法，值得注意的是第14行的<code>if (i+1 &lt; s.length() &amp;&amp; hash[s[i]-&#39;C&#39;] &lt; hash[s[i+1]-&#39;C&#39;])</code>的第二个条件，假如出现小面额在大面额之前的情况，我一开始以为这个写法有漏洞，比如IM这种情况，后来想想这种情况不属于合法输入，所以可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s1[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">500</span>, <span class="number">1000</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> s2[] = &#123;<span class="string">'I'</span>,<span class="string">'V'</span>,<span class="string">'X'</span>,<span class="string">'L'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'M'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> hash[<span class="string">'X'</span>-<span class="string">'C'</span>+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(s1)/<span class="keyword">sizeof</span>(s1[<span class="number">0</span>]); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[s2[i]-<span class="string">'C'</span>] = s1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; s.length() &amp;&amp; hash[s[i]-<span class="string">'C'</span>] &lt; hash[s[i+<span class="number">1</span>]-<span class="string">'C'</span>])</span><br><span class="line">            &#123;   <span class="comment">//第二个判断条件是基于不会有非法输入，比如IM之类的出现</span></span><br><span class="line">                N += hash[s[i+<span class="number">1</span>]-<span class="string">'C'</span>] - hash[s[i]-<span class="string">'C'</span>];</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                N += hash[s[i]-<span class="string">'C'</span>];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p>从下标0开始一列列对比</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.size() == <span class="number">0</span> || strs[<span class="number">0</span>].length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)</span><br><span class="line">        &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>][idx];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (idx &gt;= strs[i].length() || strs[i][idx] != c)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><p>用一个栈，遇到左括号入栈，遇到右括号看栈是否为空and栈顶是否为对应左括号。最后看栈是否为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (c)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>: st.push(c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>: st.push(c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#123;'</span>: st.push(c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> (st.empty() || st.top() != <span class="string">'('</span>) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">if</span> (st.empty() || st.top() != <span class="string">'['</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">                <span class="keyword">if</span> (st.empty() || st.top() != <span class="string">'&#123;'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;          </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>可以加一些判断过滤：</p><ol><li>s.length()为奇数</li><li>栈深度大于s.length()/2时，后面有再多的右括号也消化不了</li><li>栈深度大于剩余长度时，后面有再多的右括号也消化不了（强于2）</li></ol><p>但其实没怎么改进速度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">""</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.length() % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">switch</span> (c)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>: st.push(c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>: st.push(c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#123;'</span>: st.push(c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> (st.empty() || st.top() != <span class="string">'('</span>) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">                <span class="keyword">if</span> (st.empty() || st.top() != <span class="string">'['</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">                <span class="keyword">if</span> (st.empty() || st.top() != <span class="string">'&#123;'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;          </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st.size() &gt; s.length() - i - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><p>逐个比较两个链表的当前元素，小的插入新链表，然后当前元素后移一位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = l1, *p2 = l2;</span><br><span class="line">        ListNode* merge = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* tail = merge;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span> &amp;&amp; p2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* tmp = <span class="keyword">new</span> ListNode(p1-&gt;val);</span><br><span class="line">                tail-&gt;next = tmp;</span><br><span class="line">                tail = tmp;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* tmp = <span class="keyword">new</span> ListNode(p2-&gt;val);</span><br><span class="line">                tail-&gt;next = tmp;</span><br><span class="line">                tail = tmp;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = <span class="keyword">new</span> ListNode(p1-&gt;val);</span><br><span class="line">            tail-&gt;next = tmp;</span><br><span class="line">            tail = tmp;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp = <span class="keyword">new</span> ListNode(p2-&gt;val);</span><br><span class="line">            tail-&gt;next = tmp;</span><br><span class="line">            tail = tmp;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ret = merge-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> merge;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的写法没有利用l1和l2的空间，下面重复利用l1和l2的空间。用一个指针prev记录上一个选中的节点，然后选中当前节点cur后，将prev-&gt;next=cur。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = l1, *p2 = l2;</span><br><span class="line">        ListNode* merge = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* prev = merge;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span> &amp;&amp; p2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;next = p1;</span><br><span class="line">                prev = p1;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;next = p2;</span><br><span class="line">                prev = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = p1;</span><br><span class="line">            prev = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;next = p2;</span><br><span class="line">            prev = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ret = merge-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> merge;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><p>迭代器的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = nums.begin(); p != nums.end(); )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*p == val)</span><br><span class="line">            &#123;</span><br><span class="line">                p = nums.erase(p);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>第二种办法，注意到题目里说元素顺序可以改变，所以可以不真正删除元素，而是把元素调到数组的最后面去（用时反而比上面的解法慢，不解）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> revNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= p2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[p1] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                revNum++;</span><br><span class="line">                <span class="keyword">while</span> (nums[p2] == val &amp;&amp; p1 &lt; p2)</span><br><span class="line">                &#123;</span><br><span class="line">                    p2--;</span><br><span class="line">                    revNum++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p1 &lt; p2)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">std</span>::swap(nums[p1], nums[p2]);</span><br><span class="line">                    p2--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size() - revNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="28-实现strStr"><a href="#28-实现strStr" class="headerlink" title="28. 实现strStr()"></a>28. 实现strStr()</h2><p>改进的kmp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strStr(string haystack, string needle) &#123;</span><br><span class="line">        if (needle == &quot;&quot;) return 0;</span><br><span class="line">        string&amp; txt = haystack;</span><br><span class="line">        string&amp; pat = needle;</span><br><span class="line">        int n = txt.length();</span><br><span class="line">        int m = pat.length();</span><br><span class="line">        auto dp = new int[m][256];</span><br><span class="line">        memset(dp, 0, m*256*sizeof(int));</span><br><span class="line"></span><br><span class="line">        dp[0][pat[0]] = 1;</span><br><span class="line">        int X = 0;</span><br><span class="line">        for (int i = 1; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int c = 0; c &lt; 256; c++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (c == pat[i])</span><br><span class="line">                    dp[i][c] = i + 1;</span><br><span class="line">                else</span><br><span class="line">                    dp[i][c] = dp[X][c];</span><br><span class="line">            &#125;</span><br><span class="line">            X = dp[X][pat[i]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int j = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j = dp[j][txt[i]];</span><br><span class="line">            if (j == m)</span><br><span class="line">            &#123;</span><br><span class="line">                return i - m + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sunday</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle == <span class="string">""</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = haystack.length();</span><br><span class="line">        <span class="keyword">int</span> m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sunday[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sunday[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sunday[needle[i]] = m - i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( ; i+j &lt; n &amp;&amp; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i+j] != needle[j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i+m &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sunday[haystack[i+m]] != <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    i = i + sunday[haystack[i+m]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    i = i + m;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h2><p>二分查找递归版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[nums.size()<span class="number">-1</span>]) <span class="keyword">return</span> nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> re(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">re</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> sat, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sat == end) <span class="keyword">return</span> target &lt;= nums[sat] ? sat : sat+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (sat + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) </span><br><span class="line">            <span class="keyword">return</span> re(nums, sat, mid, target);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> re(nums, mid + <span class="number">1</span>, end, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二分查找迭代版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[nums.size()<span class="number">-1</span>]) <span class="keyword">return</span> nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sat = <span class="number">0</span>, end = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sat == end) <span class="keyword">return</span> target &lt;= nums[sat] ? sat : sat+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = (sat+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) </span><br><span class="line">                end = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                sat = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h2><p>BF，枚举之前的字符串，处理每个字符串的方法，遇到相同的字符，计数器+1，遇到不同的字符，将计数器和当前字符添加到nstr的尾部</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> nstr = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">char</span> cur = str[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; str.length())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; str.length() &amp;&amp; str[j] == cur)</span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                nstr.append(to_string(num));</span><br><span class="line">                nstr.push_back(cur);</span><br><span class="line">                <span class="keyword">if</span> (j &lt; str.length())</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = str[j];</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str = nstr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="困难题"><a href="#困难题" class="headerlink" title="困难题"></a>困难题</h1><h2 id="4-寻找两个有序数组的中位数"><a href="#4-寻找两个有序数组的中位数" class="headerlink" title="4. 寻找两个有序数组的中位数"></a>4. 寻找两个有序数组的中位数</h2><p>要求时间复杂度O(log(m+n))，想法每次砍掉一半的候选人，但出现了问题。</p><p>假如m和n均为奇数，或者均为偶数，那么中位数必然是(ai+bj)/2，如果m和n一奇一偶，那么中位数必然是ai或者bj。</p><p>每次砍掉一半，意味着m和n的奇偶性会变化，然后出事。</p><p>比如奇数，还是奇数，xxxx但是偶数，有可能变成奇数或者偶数。所以一奇一偶没问题。</p><p>两奇或者两偶的需要找第(m+n)/2-1大和(m+n)/2大的数</p><ul><li>一种想法是：把两个数组中最大的一个数去掉，变成了一奇一偶，算出原第(m+n)/2-1大的数；把最小的一个数也去掉，变成了一奇一偶，算出原第(m+n)/2-1大的数，然后相加除以二</li><li>不过这样相当于算了两遍，改进一下，算出原第(m+n)/2-1大的数后，下一个数的候选人是这个数所在数组的后一个数，或者另一个数组的二分查找的刚好大于等于这个数的数</li></ul><h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h2><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//原地哈希</span></span><br><span class="line">        <span class="comment">//1. 把不在[1, N]的负数和0设为N+1，因为是无效数据，不能影响后面的标记</span></span><br><span class="line">        <span class="comment">//2. 把在[1, N]的数m，令nums[m-1] = -abs(nums[m-1])，打上标记</span></span><br><span class="line">        <span class="comment">//3. 遍历数组，如果有正数，说明没被标记，返回下标+1；如果遍历完了，说明[1, N]都出现了，返回N+1</span></span><br><span class="line">        <span class="keyword">int</span> N = nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>)</span><br><span class="line">                nums[i] = N+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> absi = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (absi &gt;= <span class="number">1</span> &amp;&amp; absi &lt;= N)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[absi - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[absi - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019. 链表中的下一个更大节点"></a>1019. 链表中的下一个更大节点</h2><p>对于链表 [2, 5, 1, 1, 4]</p><p>next[] = [5, 0, 4, 4, 0]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; nextLargerNodes(ListNode* head) &#123;</span><br><span class="line">        //单调递减栈</span><br><span class="line">        //1. 把链表转为数组，方便后面按下标索引</span><br><span class="line">        //2. 遍历数组，如果nums[i] &lt;= nums[top]就一直pop，pop一个就令next[top] = i，然后push(i)</span><br><span class="line">        //3. 把栈里剩余的元素的next置为0</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; nums;</span><br><span class="line">        while (head != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        vector&lt;int&gt; answer(nums.size());</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            while (!stk.empty() &amp;&amp; nums[i] &gt; nums[stk.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                answer[stk.top()] = nums[i];</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!stk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            answer[stk.top()] = 0;</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="896-单调数列"><a href="#896-单调数列" class="headerlink" title="896. 单调数列"></a>896. 单调数列</h2><p>判断一个数列是否是单调递增or单调递减，解法1，往后看；解法2，两个单调栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMonotonic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//简单往后看</span></span><br><span class="line">        <span class="comment">//1. 设置dir = 0</span></span><br><span class="line">        <span class="comment">//2. 遍历A，如果dir = 0，prev &lt; cur，dir = 1（递增）；prev &gt; cur, dir = -1（递减）；相等不管</span></span><br><span class="line">        <span class="comment">//如果dir = -1，prev &lt; cur，return false；其他不管</span></span><br><span class="line">        <span class="comment">//如果dir = 1，prev &gt; cur，return false；其他不管</span></span><br><span class="line">        <span class="comment">//3. 最后return true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (A.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = A[i];</span><br><span class="line">            <span class="keyword">if</span> (dir == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev &lt; cur) dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (prev &gt; cur) dir = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev &lt; cur) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev &gt; cur) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMonotonic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//两个单调栈</span></span><br><span class="line">        <span class="comment">//1. 一个递增栈incStk，如果cur &gt;= top，就往incStk中push(cur)，否则一路pop直到cur &gt;= top，然后push(cur)</span></span><br><span class="line">        <span class="comment">//2. 一个递减栈decStk，一路pop直到 cur &lt;= top，然后push(cur)</span></span><br><span class="line">        <span class="comment">//3. 如果是单调数列，那么两个栈一定1个是满的，另一个无所谓</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; increaseStk, decreaseStk;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = A[i];</span><br><span class="line">            <span class="keyword">while</span> (!increaseStk.empty() &amp;&amp; cur &lt; increaseStk.top())</span><br><span class="line">            &#123;</span><br><span class="line">                increaseStk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            increaseStk.push(cur);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!decreaseStk.empty() &amp;&amp; cur &gt; decreaseStk.top())</span><br><span class="line">            &#123;</span><br><span class="line">                decreaseStk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            decreaseStk.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size1 = increaseStk.size();</span><br><span class="line">        <span class="keyword">int</span> size2 = decreaseStk.size();</span><br><span class="line">        <span class="keyword">if</span> (size1 == N || size2 == N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a>84. 柱状图中最大的矩形</h2><p><img src="/2020/01/27/LeetCode刷题笔记/C:/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200630090405899.png" alt="image-20200630090405899"></p><p>解法1：暴力</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;</span><br><span class="line">        //暴力</span><br><span class="line">        //1. 对于第i个柱子，他所在的最大矩形，开始位置在往左看第一个比他矮的柱子下标+1</span><br><span class="line">        //结束位置在往右看第一个比他矮的柱子下标-1</span><br><span class="line">        //高度是他自己的高度</span><br><span class="line">        //2. 遍历一遍，时间O(n2)，空间原地O(n)</span><br><span class="line">        //3. 为了方便处理头尾情况，在heights数组的前后各加一个0</span><br><span class="line"></span><br><span class="line">        heights.insert(heights.begin(), 0);</span><br><span class="line">        heights.push_back(0);</span><br><span class="line"></span><br><span class="line">        int N = heights.size();</span><br><span class="line">        int Max = 0;</span><br><span class="line">        for (int i = 1; i &lt; N - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int H = heights[i];</span><br><span class="line">            int W_begin = 0 + 1;</span><br><span class="line">            int W_end = N - 1; </span><br><span class="line">            for (int j = i - 1; j &gt;= 0; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                if (heights[j] &lt; H)</span><br><span class="line">                &#123;</span><br><span class="line">                    W_begin = j + 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = i + 1; j &lt; N; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (heights[j] &lt; H)</span><br><span class="line">                &#123;</span><br><span class="line">                    W_end = j - 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int W = W_end - W_begin + 1;</span><br><span class="line">            int Rectangle = W * H;</span><br><span class="line">            Max = max(Max, Rectangle);</span><br><span class="line">        &#125;</span><br><span class="line">        return Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解法2：单调栈</p><p>观察到，我们需要的是一个柱子的，左边第一个比他小的，和右边第一个比他小的；而单调递增栈恰好有这个性质：当一个元素被pop的时候，此刻的栈顶是左边第一个比他小的，让他pop的元素是右边第一个比他小的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//单调递增栈</span></span><br><span class="line">        <span class="comment">//1. 当一个元素被pop时，pop后的栈顶元素，是左边从右往左数第一个比他小的，</span></span><br><span class="line">        <span class="comment">//让他pop的元素，是右边从左往右数第一个比他小的</span></span><br><span class="line">        <span class="comment">//2. 由此可以在每个元素被pop时计算出对应的矩形面积</span></span><br><span class="line">        <span class="comment">//3. 注意，递增栈中存的是下标，不是值</span></span><br><span class="line">        <span class="comment">//4. 预先在heights数组的首尾插0，首部的0为了保证首元素计算正确，尾部的0是为了把栈里最后剩余元素都pop出去</span></span><br><span class="line"></span><br><span class="line">        heights.insert(heights.begin(), <span class="number">0</span>);</span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; incStk;</span><br><span class="line">        <span class="keyword">int</span> N = heights.size();</span><br><span class="line">        <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!incStk.empty() &amp;&amp; heights[i] &lt; heights[incStk.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> top = incStk.top();</span><br><span class="line">                <span class="keyword">int</span> H = heights[top];</span><br><span class="line">                <span class="keyword">int</span> W_end = i - <span class="number">1</span>;</span><br><span class="line">                incStk.pop();</span><br><span class="line">                <span class="keyword">if</span> (!incStk.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> W_begin = incStk.top() + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> W = W_end - W_begin + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> Rectangle = W * H;</span><br><span class="line">                    Max = max(Max, Rectangle);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            incStk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//双栈，一个headStk栈负责存队列的前半段，另一个tailStk负责存队列的后半段</span></span><br><span class="line">    <span class="comment">//1. 有appendTai的时候只要push到tailStk中</span></span><br><span class="line">    <span class="comment">//2. 有deleteHead时，先看headStk是否为空，</span></span><br><span class="line">    <span class="comment">//如果为空，从tailStk中依次pop出所有元素，</span></span><br><span class="line">    <span class="comment">//  并push到headStk中，如果仍然为空，返回-1，否则返回headStk的栈顶并pop</span></span><br><span class="line">    <span class="comment">//如果不为空，返回headStk的栈顶并pop</span></span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        tailStk.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!headStk.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> top = headStk.top();</span><br><span class="line">            headStk.pop();</span><br><span class="line">            <span class="keyword">return</span> top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!tailStk.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> val = tailStk.top();</span><br><span class="line">                tailStk.pop();</span><br><span class="line">                headStk.push(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!headStk.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> top = headStk.top();</span><br><span class="line">                headStk.pop();</span><br><span class="line">                <span class="keyword">return</span> top;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; headStk, tailStk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h2><p>解法1：</p><p>dp[i] 代表以nums[i]作为首元素的最长上升子序列的长度</p><p>转移方程：dp[i] = max(1, max(dp[j]) + 1)  (j &gt; i, num[j] &gt; nums[i])</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span>] * len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            max_len = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[i]:</span><br><span class="line">                    max_len = max(max_len, dp[j])</span><br><span class="line">            dp[i] = max_len + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><h2 id="x-矩阵连乘"><a href="#x-矩阵连乘" class="headerlink" title="x. 矩阵连乘"></a>x. 矩阵连乘</h2><p>思考：矩阵Ai … Aj 的乘法次数记做A[i, j]，最后一次左右两坨矩阵的乘法位置记做k，最少次数是 min(A[i, k] + A[k+1, j] + p[i] <em> p[k] </em> p[j])</p><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h2><p>只有+-*/四个运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用栈计算</span></span><br><span class="line">        <span class="comment">//1. 遇到数字push</span></span><br><span class="line">        <span class="comment">//2. 遇到操作符取出栈顶两个元素进行运算，然后push</span></span><br><span class="line">        <span class="comment">//3. 最后栈里剩下的就是结果</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>&amp; s = tokens[i];</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="string">'9'</span> || s.length() &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> val = atoi(s.c_str());</span><br><span class="line">                stk.push(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> right = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">int</span> left = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">switch</span> (s[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: result = left+right; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: result = left-right; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'*'</span>: result = left*right; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>: result = left/right; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a>224. 基本计算器</h2><p>包含()+-，非负整数和空格</p><p>解法1：中缀转后缀，计算后缀</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用栈计算</span></span><br><span class="line">        <span class="comment">//1. 遇到数字push</span></span><br><span class="line">        <span class="comment">//2. 遇到操作符取出栈顶两个元素进行运算，然后push</span></span><br><span class="line">        <span class="comment">//3. 最后栈里剩下的就是结果</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>&amp; s = tokens[i];</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="string">'9'</span> || s.length() &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> val = atoi(s.c_str());</span><br><span class="line">                stk.push(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> right = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">int</span> left = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">switch</span> (s[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: result = left+right; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: result = left-right; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'*'</span>: result = left*right; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>: result = left/right; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//中缀转后缀，再用栈算后缀</span></span><br><span class="line">        <span class="comment">//1. 遇到数字就输出，遇到空格跳过</span></span><br><span class="line">        <span class="comment">//2. 遇到+-就和栈顶比，如果入栈时优先级比栈顶的栈内优先级高，那就push</span></span><br><span class="line">        <span class="comment">//  否则一路pop并输出top，直到不满足条件</span></span><br><span class="line">        <span class="comment">//3. 遇到(直接push</span></span><br><span class="line">        <span class="comment">//4. 遇到)一路pop并输出top，直到遇到第一个(</span></span><br><span class="line">        <span class="comment">//5. 扫完字符串后把栈里剩下的东西输出出来</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">enum</span> &#123;plus = <span class="number">0</span>, minus, lb, rb, begin, end&#125;;</span><br><span class="line">        <span class="keyword">int</span> osp[<span class="number">6</span>] = &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> isp[<span class="number">6</span>] = &#123; <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; opStk;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; suffix;</span><br><span class="line"></span><br><span class="line">        opStk.push(pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">'#'</span>, <span class="number">0</span>));</span><br><span class="line">        s.push_back(<span class="string">'e'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (s[j] &gt;= <span class="string">'0'</span> &amp;&amp; s[j] &lt;= <span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j != i)</span><br><span class="line">            &#123;</span><br><span class="line">                suffix.push_back(s.substr(i, j-i));</span><br><span class="line">                i = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> op_enum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">switch</span> (c)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: op_enum = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: op_enum = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'('</span>: op_enum = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">')'</span>: op_enum = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'e'</span>: op_enum = <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (osp[op_enum] &lt;= opStk.top().second)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> op_str = <span class="string">"a"</span>;</span><br><span class="line">                    op_str[<span class="number">0</span>] = opStk.top().first;</span><br><span class="line">                    opStk.pop();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (op_str == <span class="string">"("</span> || op_str == <span class="string">"#"</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    suffix.push_back(op_str);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">')'</span> &amp;&amp; c != <span class="string">'e'</span>)</span><br><span class="line">                    opStk.push(pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(c, isp[op_enum]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> evalRPN(suffix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解法2：先词法分析，找exp的dominant operator，递归求解exp1 op exp2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> type &#123;num, plus, minus, lb, rb&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">token</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        type t;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> level;</span><br><span class="line">        <span class="keyword">int</span> match;</span><br><span class="line">        token(type <span class="keyword">_t</span> = num, <span class="keyword">int</span> _val = <span class="number">0</span>): t(<span class="keyword">_t</span>), val(_val) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//词法分析+递归解exp1 op exp2</span></span><br><span class="line">        <span class="comment">//1. 把s变成tokens数组</span></span><br><span class="line">        <span class="comment">//2. 对于exp(p, q)，</span></span><br><span class="line">        <span class="comment">//如果p &gt; q，错误</span></span><br><span class="line">        <span class="comment">//如果p = q，返回tokens[p].val</span></span><br><span class="line">        <span class="comment">//如果p &lt; q，如果pq是一对匹配的括号，返回exp(p+1, q-1)</span></span><br><span class="line">        <span class="comment">//由于加减法都是左结合，所以我们从q往p找第一个主加号，设其下标为k，</span></span><br><span class="line">        <span class="comment">//  返回 exp(p, k-1) op(k) exp(k+1, q)</span></span><br><span class="line">        <span class="comment">//主加号就是当前看来没被括号包着的加号，可以为每一个加号设置一个绝对包裹层数，传参时每脱掉一层括号，就把基础层数+1，然后去找第一个绝对层数-相对层数=0的加号</span></span><br><span class="line">        <span class="comment">//比如((a+b)+c)，绝对层数分别为2和1，脱掉第一层括号时，基础层数为1，发现第二个加号是主加号</span></span><br><span class="line">        <span class="comment">//绝对层数的计算可以由栈匹配括号时，遇到加号就把level设置成stack.size</span></span><br><span class="line">        <span class="comment">//匹配的括号可以由栈匹配括号时，为每个左括号记录他的右括号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//词法分析</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;token&gt; tokens;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'('</span>) tokens.push_back(token(lb));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span>) tokens.push_back(token(rb));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'+'</span>) tokens.push_back(token(plus));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'-'</span>) tokens.push_back(token(minus));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span> (s[j] &gt;= <span class="string">'0'</span> &amp;&amp; s[j] &lt;= <span class="string">'9'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> val = atoi(s.substr(i, j-i).c_str());</span><br><span class="line">                tokens.push_back(token(num, val));</span><br><span class="line">                i = j<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算层数</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; bStk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            type t = tokens[i].t;</span><br><span class="line">            <span class="keyword">if</span> (t == lb) bStk.push(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == rb) &#123; tokens[bStk.top()].match = i; bStk.pop(); &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == plus || t == minus) tokens[i].level = bStk.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解exp</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">exp</span>(tokens, <span class="number">0</span>, tokens.size()<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">exp</span><span class="params">(<span class="built_in">vector</span>&lt;token&gt;&amp; tokens, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q) <span class="keyword">return</span> tokens[p].val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tokens[p].t == lb &amp;&amp; tokens[q].t == rb &amp;&amp; tokens[p].match == q) <span class="keyword">return</span> <span class="built_in">exp</span>(tokens, p+<span class="number">1</span>, q<span class="number">-1</span>, level+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dominant_op = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q; i &gt;= p; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tokens[i].t == plus || tokens[i].t == minus) &amp;&amp; tokens[i].level == level)</span><br><span class="line">                &#123;</span><br><span class="line">                    dominant_op = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (tokens[dominant_op].t == plus)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">exp</span>(tokens, p, dominant_op<span class="number">-1</span>, level) + <span class="built_in">exp</span>(tokens, dominant_op+<span class="number">1</span>, q, level);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">exp</span>(tokens, p, dominant_op<span class="number">-1</span>, level) - <span class="built_in">exp</span>(tokens, dominant_op+<span class="number">1</span>, q, level);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/20/%E8%AE%A1%E7%BD%91%E5%90%8D%E8%AF%8D%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/06/20/%E8%AE%A1%E7%BD%91%E5%90%8D%E8%AF%8D%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-简介"><a href="#第1章-简介" class="headerlink" title="第1章 简介"></a>第1章 简介</h1><h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><p>DSL: digital subscriber line 数字用户线</p><p>FTTH: fiber to the home 到户光纤</p><p>HFC: hybrid fiber coax 混合光纤同轴 p10</p><p>WIFI: 无线 LAN (54Mbps)</p><p>接入网络的途径：</p><ol><li>住宅接入: DSL, 电缆, FTTH, 拨号, 卫星</li><li>公司接入: 以太网, wifi</li><li>广域无线接入: 3g, LTE</li></ol><h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><p>FDM: frequence-division multiplexing 频分复用</p><p>TDM: time-division multiplexing 时分复用</p><p>IXP: internet exchange point 因特网交换点</p><h1 id="第5章-链路层"><a href="#第5章-链路层" class="headerlink" title="第5章 链路层"></a>第5章 链路层</h1><h2 id="5-2-纠错"><a href="#5-2-纠错" class="headerlink" title="5.2 纠错"></a>5.2 纠错</h2><p>FEC: forward error correction 前向纠错</p><p>CRC: cyclic redundancy check 循环冗余校检测</p><p>检测方法：</p><ol><li>奇偶校验</li><li>checksum 的计算</li><li>CRC 的 R 的计算</li></ol><h2 id="5-2-多路访问链路和协议"><a href="#5-2-多路访问链路和协议" class="headerlink" title="5.2 多路访问链路和协议"></a>5.2 多路访问链路和协议</h2><h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><p>TDM, FDM: 单个节点只能享受 R/N 的传输速率</p><p>CDMA: code division multiple access: 每个节点单独编码，可同时传输</p><h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><p>每个节点全速 R 发送，撞了等会再重传</p><p>时隙 Aloha</p><p>Aloha</p><p>CSMA</p><p>CSMA/CD</p><h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><p>轮询, 令牌</p><h2 id="5-4-以太网"><a href="#5-4-以太网" class="headerlink" title="5.4 以太网"></a>5.4 以太网</h2><p>数据报长度必须 46-1500 字节</p><h1 id="第6章-无线网"><a href="#第6章-无线网" class="headerlink" title="第6章 无线网"></a>第6章 无线网</h1><h2 id="6-2-无线链路"><a href="#6-2-无线链路" class="headerlink" title="6.2 无线链路"></a>6.2 无线链路</h2><p>SNR: signal-to-noise ratio 信噪比</p><p>BER: bit error ration 比特差错率</p><p>SNR(x)-BER(y) 变化图</p><h2 id="6-3-802-11"><a href="#6-3-802-11" class="headerlink" title="6.3 802.11"></a>6.3 802.11</h2><p>BSS: basic service set 基本服务集（由多个无线站点 和 一个 AP 作为中心基站组成） p350</p><p>AP: access point 接入点</p><p>SSID: service set identifier 服务集标识符</p><p>CSMA/CA: CSMA/ collision avoidance</p><p>SIFS: short inter-frame spacing 短帧间间隔</p><p>DIFS: distributed inter-frame space 分布式帧间间隔</p><p>RTS: request to send 请求发送帧</p><p>CTS: clear to send 允许发送帧</p><p>链路层确认：</p><ul><li>发送方：<ol><li>有包就发</li></ol></li><li>接收方<ol><li>收到一个通过 CRC 校验的包</li><li>等待 SIFS 时间</li><li>回一个确认帧</li></ol></li><li>发送方：<ol><li>收到确认帧，ok</li><li>没收到，过一段时间，重发，直到收到</li><li>没收到若干次，放弃</li></ol></li></ul><p>CSMA/CA：p354</p><ul><li>发送方：<ol><li>监听信道，若空闲，等 DIFS，再发，期间监听信道</li><li>若忙碌，选择随机回退值，期间监听信道，若空闲则递减该值，若忙碌则冻结</li><li>回退值减到0，就发</li><li>如果收到确认帧，就回到第2步，并从更大范围选择随机回退值</li></ol></li></ul><p>发大数据前:</p><ol><li>RTS</li><li>CTS</li><li>DATA</li><li>ACK</li></ol><p>没收到 CTS 说明也撞了，不给你分配时间</p><h2 id="6-3-6-蓝牙-zigbee"><a href="#6-3-6-蓝牙-zigbee" class="headerlink" title="6.3.6 蓝牙 zigbee"></a>6.3.6 蓝牙 zigbee</h2><p>WPAN: wireless personal area network 无线个人区域网络</p><p>802.15.1, 4Mbps, 自组织皮可网, 8个活动设备, 1主7从</p><p>802.14.5, 20 40 100 250kbps, 控制器(主)+n从, TDM, 信标帧+活跃周期帧</p><h2 id="6-4-蜂窝3g"><a href="#6-4-蜂窝3g" class="headerlink" title="6.4 蜂窝3g"></a>6.4 蜂窝3g</h2><p>GSM: groupe special mobile 全球移动通信系统</p><p>BTS: base transceiver station 收发基站, 部署于每个六边形小区内或边界</p><p>BSC: basestation contoller 基站控制器</p><p>MSC: mobile switching center 移动交换中心</p><p>3GPP: 3rd generation partnership project 第三代合作伙伴项目</p><p>UMTS: universal movile telecommunications service 通用移动通信服务</p><h1 id="第4章-网络层"><a href="#第4章-网络层" class="headerlink" title="第4章 网络层"></a>第4章 网络层</h1><p>提供的服务 p205-206</p><p>三种协议：</p><ol><li>IP 协议</li><li>ICMP 协议</li><li>路由选择协议</li></ol><h2 id="ipv4"><a href="#ipv4" class="headerlink" title="ipv4"></a>ipv4</h2><p>flags(3 bits) R/D/M</p><ul><li>001 表示还有后续分片</li></ul><p>fragment offset * 8 = real offset</p><h2 id="4-2-虚电路和数据报网络"><a href="#4-2-虚电路和数据报网络" class="headerlink" title="4.2 虚电路和数据报网络"></a>4.2 虚电路和数据报网络</h2><p>VC: virtual circuit 虚电路，无连接</p><p>datagram network 数据报网络，有连接</p><h2 id="4-3-路由器原理"><a href="#4-3-路由器原理" class="headerlink" title="4.3 路由器原理"></a>4.3 路由器原理</h2><p>HOL: head-of-the-time-line 线路前部阻塞, 输入队列中排在后面的被排在前面的阻塞</p><p>交换的三种方式</p><ul><li>经内存交换：类似 I-&gt;CPU-&gt;O, 两次占用系统总线</li><li>经总线交换：类似单车道，一次只能跑一辆车</li><li>经互联网络交换：纵横线，控制器控制哪些交点开闭，可以并行</li></ul><h2 id="4-4-IP-编址"><a href="#4-4-IP-编址" class="headerlink" title="4.4 IP 编址"></a>4.4 IP 编址</h2><p>CIDR: classless interdomain routing 无类别域间路由选择</p><p>NAT 通过 NAT 表完成内部主机(内部 ip, port) &lt;=&gt; NAT 路由器(公网 ip, port) 的转换</p><h2 id="4-5-路由选择算法"><a href="#4-5-路由选择算法" class="headerlink" title="4.5 路由选择算法"></a>4.5 路由选择算法</h2><p>AS: autonomous system 自治系统</p><p>分类</p><ul><li>全局式 vs 分布式</li><li>静态 vs 动态</li><li>负载敏感 vs 负载迟钝</li></ul><p>LS 算法：</p><ul><li>基于 Dijkstra</li></ul><p>DV 算法：</p><ul><li>每个节点维护一张 N*N 的距离矩阵（N 个行向量）</li><li>初始化自己的那一行为 c(u, v)</li><li>向邻居们广播自己的那一行</li><li>(收到邻居的广播后，覆盖邻居的那一行)/(链路费用变化时)，然后重新计算自己的那一行 d(x, y) = min{c(x, w), d(w, y)}</li><li>如果自己那一行有变化，就向邻居们广播自己的那一行，没变化就静止等邻居以后的广播</li></ul><p>毒性逆转：<br>如果 z 经过 y 作为第一跳到达 x，那么 z 告诉 y：d(z, x) = +INF，即我打你这过，你别再给我整回来了</p><p>毒性逆转对三个以上结点无效：<br><a href="https://blog.csdn.net/tianlongtc/article/details/80261581" target="_blank" rel="noopener">https://blog.csdn.net/tianlongtc/article/details/80261581</a></p><p>域间路由<br>热土豆路由选择：当 AS 内部某路由器 R 发往外部网络 x 的包可以通过多个网关路由器丢出去时，选 AS 内部路由费用最低的</p><h2 id="4-6-域内路由-amp-域间路由"><a href="#4-6-域内路由-amp-域间路由" class="headerlink" title="4.6 域内路由 &amp; 域间路由"></a>4.6 域内路由 &amp; 域间路由</h2><p>RIP: routing information protocol 路由选择信息协议，基于 DV</p><p>OSPF: open shortest path first 开放最短路优先，基于 LS</p><p>BGP: broder gateway protocol 边界网关协议</p><p>ASN: AS number 自治系统号</p><p>stub: 桩网络，可以理解为用户，只负责收和发自己的包，不负责帮别人路由</p><p>IGP:<br>RIP:</p><ul><li>每 30s 发送一条 RIP 响应报文，超过 180s 没收到邻居的信息就默认邻居挂了，将该信息传递给其他邻居</li><li>通过 UDP 端口号 520 发 RIP 请求和响应，因为 RIP 是作为一个进程（应用层）来运作的</li></ul><p>OSPF:</p><ul><li>至少 30min 向区域内所有路由器广播链路状态</li><li>生成一棵以自己为根的最短路径树</li><li>将一个 AS 分成多个块</li></ul><p>BGP: (use TCP)<br>eBGP, iBGP</p><p>假设我是 AS3<br>AS-PATH: 指出要到达 x，需要经过 AS2 AS1<br>NEXT-HOP: 指出要到达 x，经过的 AS1 的网关路由器的 ip 是多少</p><p>向外网路由时，如果有多条路由，选择规则</p><ul><li>每条路由有一个本地偏好值，取决于 AS 的网络管理员，最高偏好值的优先</li><li>接下来，最短 AS-PATH 的优先</li><li>MED，越小越好</li><li>接下来，热土豆策略，离哪个网关路由器的最短路径短就用哪个</li><li>接下来，BGP 标识符</li></ul><p>BGP 针对 DV 的修改：</p><ol><li>选择是最优路而不是最短路</li><li>使用 path-vector 而不是 distance vector</li><li>将自己可达的路由选择性地通告出去</li><li>BGP 可能会聚合地址，为了减少规模</li></ol><p>Gao-Rexford rules:</p><ul><li>用户的出路由可以被发给任何人</li><li>peer 的出路由发给用户</li><li>provider 的出路由发给用户</li></ul><h2 id="4-7-广播"><a href="#4-7-广播" class="headerlink" title="4.7 广播"></a>4.7 广播</h2><p>RPF: reverse path forwarding 反向路径转发</p><p>RPF</p><ul><li>转发报文，仅当上一跳位于自己到源点的最短路径上</li></ul><p>广播的三种方法：</p><ul><li>洪泛</li><li>受控洪泛<ul><li>序号控制洪泛，维护已收到的[源地址, 序列号]</li><li>RPF 反向路径转发，利用生成树</li></ul></li><li>生成树广播<ul><li>选定中心，其他节点向中心单播路由</li><li>一旦遇到中心或树上的节点，就把这条路嫁接到生成树上</li></ul></li></ul><p>实际中的</p><ul><li>Gnutella<ul><li>16bit 标识符+16bit有效载荷描述符，监测这个包是不是被收到复制转发了</li><li>ttl 限制跳的范围，每次-1，再转发</li></ul></li><li>OSPF 的 LSA<ul><li>32bit 序号+16bit 年龄，年龄每次转发+1，等待洪泛也会+1</li></ul></li></ul><h2 id="4-7-多播"><a href="#4-7-多播" class="headerlink" title="4.7 多播"></a>4.7 多播</h2><p>DVMRP: distance vector multicast routing protocol 距离向量多播路由选择协议</p><p>PIM: protocol independent multicast 协议无关的路由选择协议</p><p>DVMRP</p><ul><li>基于剪枝的 RPF</li></ul><p>PIM</p><ul><li>稠密模式，大多数路由器参与到多播中，类似 DVMRP</li><li>稀疏模式，仅允许单一发送方向多播树中发送流量</li></ul><p>IGMP 协议号 2</p><p>IGMP:</p><ul><li>membership_query 路由器向主机周期性发送(想加入吗？/你还在吗？)</li><li>membership_report 主机(主动/收到query后)请求加入多播组</li><li>leave_group 主机礼貌地退出多播组</li></ul><p>多播路由算法</p><ul><li>一棵共享树，类似多播的生成树广播</li><li>以每个发送方为源，建树，然后用 RPF 进行多播<ul><li>稍作修改，如果某个路由器（叶子路由器）发现自己的主机都不在多播组，则向上一级汇报一个剪枝报文</li><li>如果某个路由器（非叶子路由器）的所有子孙路由器都汇报了剪枝，那么它就向上一级汇报一个剪枝</li></ul></li></ul><h1 id="IP-vs-MAC-addr"><a href="#IP-vs-MAC-addr" class="headerlink" title="IP vs MAC addr"></a>IP vs MAC addr</h1><p>MAC:</p><ul><li>硬编码</li><li>48bits</li><li>可移动，与位置无关</li><li>用来在同一网络下传送包</li><li>地址是平坦的</li><li>forwarding table 由数据包生成，自学习</li><li>“路由”协议计算无环拓扑</li></ul><p>IP:</p><ul><li>动态配置</li><li>32/128bits</li><li>与主机的位置有关</li><li>用来在IP子网下传送包</li><li>地址是聚合的</li><li>forwarding table 由路由协议计算</li><li>路由协议计算最短路径</li></ul><h1 id="第3章-运输层"><a href="#第3章-运输层" class="headerlink" title="第3章 运输层"></a>第3章 运输层</h1><p>多路分解：从网络中收集数据传（分解）给不同套接字<br>多路复用：把多个套接字的数据都（复用）交给网络</p><p>0-1023 周知端口<br>HTTP: 80<br>FTP: 21</p><h2 id="3-3-UDP"><a href="#3-3-UDP" class="headerlink" title="3.3 UDP"></a>3.3 UDP</h2><p>使用原因：</p><ol><li>简洁化运输，精细的问题交给应用层</li><li>无需握手</li><li>无需维护连接状态</li><li>首部开销小</li></ol><p>应用</p><ul><li>RIP 路由表更新</li><li>DNS 查询</li></ul><h2 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4 可靠数据传输原理"></a>3.4 可靠数据传输原理</h2><p>rdt: realiable data transfer 可靠数据传输</p><p>udt: unrealiable data transfer 不可靠数据传输</p><p>ARQ: automatic repeat request 自动重传请求，发 ACK/NACK 的</p><p>GBN: go back N 回退 N 步</p><p>SR: selective repeat 选择重传</p><p>停等协议：没收到 ack/nack 就不能从上层接受新数据</p><h2 id="3-5-TCP"><a href="#3-5-TCP" class="headerlink" title="3.5 TCP"></a>3.5 TCP</h2><p>MSS: maximum segment size 最大报文段（应用层数据）长度，通常为 1500-20-20 = 1460 byte</p><p>EstimateRTT = (1-a)<em>EstimateRTT + a </em>SampleRTT</p><p>DevRTT = (1-b)<em>DevRTT + b </em>|sample - estimate|</p><p>a 推荐 0.125<br>b 推荐 0.25</p><p>TimeoutInterval = estimate + 4* dev</p><p>推荐初值为 1 s</p><p>TCP 流量控制</p><ul><li>在报文中包括 rwnd</li><li>当 rwnd 为 0 时，对面主机也不会停，防止短暂时间后缓冲区清空但发送方被阻塞的情况</li></ul><p>拥塞控制类别</p><ul><li>端到端拥塞控制 (TCP)</li><li>网络辅助的拥塞控制 (ATM ABR)</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记</title>
      <link href="/2019/02/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>机器学习复习笔记</p><p>参考书目：西瓜书</p><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="课程任务"><a href="#课程任务" class="headerlink" title="课程任务"></a>课程任务</h2><ol><li>平时作业40%</li><li>期中30%</li><li>期末30%（投票决定闭卷/半开卷）</li></ol><p>平时作业有2次取较高分作为期中成绩，其他4次作为平时成绩<br>半开卷：允许带一张a4纸，上面写什么都可以，考完交a4纸</p><h2 id="机器学习示例："><a href="#机器学习示例：" class="headerlink" title="机器学习示例："></a>机器学习示例：</h2><p>文献筛选<br>在<code>循证医学</code>中，针对特定临床问题，要先查文献进行详细研究评估。<br>提取摘要-&gt;人工筛选。应用机器学习后专家读少量文献，标记有关/无关，模型去读剩下来的文献。</p><p>搜索引擎<br><code>用机器学习解决排序问题</code></p><p>战场战术层面<br><code>损害管制自主机器人</code><br><code>罗盘系统</code></p><h2 id="典型的机器学习过程："><a href="#典型的机器学习过程：" class="headerlink" title="典型的机器学习过程："></a>典型的机器学习过程：</h2><p>给模型以数据（包含一系列属性+1个label），训练，检测。</p><h2 id="几个分类："><a href="#几个分类：" class="headerlink" title="几个分类："></a>几个分类：</h2><p><code>符号主义学习</code>、<code>连接主义学习</code></p><p>贝叶斯学派：<br>第1天，太阳升起，建立模型，预测明天太阳升起概率1/2<br>第2天，太阳升起，修正参数，预测明天太阳升起概率1/3<br>…<br>第30000天，预测30000/300001</p><p>非贝叶斯学派：<br>第1天，太阳升起，预测1<br>第2天，太阳升起，预测1<br>…<br>第30000天，根据之前的事实证据，认为太阳升起概率恒为1</p><h2 id="面临问题"><a href="#面临问题" class="headerlink" title="面临问题"></a>面临问题</h2><p>现在的问题在于大厂缺少需求，算力过剩。Google收购DeepMind是为了消耗TPU，AI实际上是互联网商们的一个出口。</p><p>鲁棒性不行，人类棋手犯错，从九段跌到八段，机器犯错，从九段跌到业余。</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>预测目标：</p><ul><li>分类：最后的输出是离散值<ul><li>二分类：好瓜、坏瓜</li><li>多分类：冬瓜、南瓜、西瓜</li></ul></li><li>回归：连续值<ul><li>瓜的成熟度</li></ul></li><li>聚类：无标记信息（物以类聚/具有相同hash feature的数据被hash后放入同一个桶/韩信点兵/等价类划分）</li></ul><p>有无标记信息：</p><ul><li>监督学习：分类、回归</li><li>无监督学习：聚类</li><li>半监督学习：两者结合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论定理收集</title>
      <link href="/2019/02/26/%E5%9B%BE%E8%AE%BA%E5%AE%9A%E7%90%86%E6%94%B6%E9%9B%86/"/>
      <url>/2019/02/26/%E5%9B%BE%E8%AE%BA%E5%AE%9A%E7%90%86%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>参考书目：《图论与网络理论》和ppt</p><p>要求：复习的时候都会证明</p><h1 id="第一章-图的基本概念"><a href="#第一章-图的基本概念" class="headerlink" title="第一章 图的基本概念"></a>第一章 图的基本概念</h1><p>定理1.1.1 对任何图 $ G $ ，各顶点度数之和等于边数的2倍.即 $ \sum\limits_{\nu\in V(G)}d(\nu) = 2\varepsilon. $</p><p>推论1.1.1 任何图中，奇度顶点个数为偶数.</p><p>例1.1.2 设 $ G $ 是一个简单图，若最小度 $ \delta(G) \geq 2 $，则 $ G $ 中必含有圈.</p><p>例1.1.3 设 $ G $ 是一个简单图，若最小度 $ \delta(G) \geq 3 $，则 $ G $ 中必含有偶圈.</p><p>例1.1.4 设 $ G $ 是简单图，若最小度 $ \delta(G) \geq 3 $，则 $ G $ 中各个圈长的最大公因数是1或2.</p><p>定理1.1.2 一个图是二部图当且仅当它不含有奇圈.</p><p>定理1.1.3 如果图 $ G $ 连通，$ \varepsilon(G) \geq \nu(G)-1 $.</p><p>例1.1.6 设图 $ G $ 有 $ 2n $个顶点，$ \delta(G) \geq n $，求证 $ G $ 连通.</p><p>例1.1.7 求证：若图中有且仅有2个奇度顶点，则它们必然连通.</p><p>定理1.3.1<br>下列命题等价</p><ol><li>$ G $ 是树（无圈的连通图）.</li><li>$ G $ 无环边且 $ G $ 中任意两个顶点间有唯一的路.</li><li>$ G $ 无圈且 $ \varepsilon = v-1 $.</li><li>$ G $ 连通且 $ \varepsilon = v-1 $.</li><li>$ G $ 连通且对于任意 $ e \in E(G)$，$ G-e $ 不连通.</li><li>$ G $ 无圈且对于任意 $ e \in E(\overline{G}) $，$ G+e $ 恰有一个圈.</li></ol><hr><p>定理2.1.3 设 $ v $ 是树的顶点，则 $ v $ 是 $ T $ 的割点当且仅当 $ d(v)&gt;1 $.</p><p>推论2.1.1 每个非平凡无圈连通图至少有2个顶点不是割点.</p><p>定理2.1.5 边 $ e $ 是割边当且仅当 $ e $ 不在 $ G $ 的任何一个圈上.</p><p>定理2.2.1 $ \kappa(G) \leq \kappa’(G) \leq \delta(G) $</p><p>定理2.2.2 对具有 $ v $ 个顶点 $ \varepsilon $，有$ \kappa(G) \leq \lfloor \frac{2\varepsilon}{v} \rfloor $.</p><p>定理2.2.3 设 $ G $ 是一个简单图，$ k $ 是一个自然数，若$ \delta(G) \geq \frac{v+k+2}{2} $，则 $ G $ 是连通的.</p><p>推论2.2.1 设 $ G $ 是一个简单图，若 $ \delta(G) \geq \frac{v-1}{2} $，则 $ G $ 是连通图。</p><p>定理2.2.4 设 $ G $ 是一个直径为2的简单图，则 $ \kappa’(G)=\delta(G) $.</p><h1 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h1><h2 id="中国邮递员问题-gt-带权最短闭途径"><a href="#中国邮递员问题-gt-带权最短闭途径" class="headerlink" title="中国邮递员问题-&gt;带权最短闭途径"></a>中国邮递员问题-&gt;带权最短闭途径</h2><p>Edmonds-Johnson 算法（补成欧拉图）</p><ol><li>找出奇度顶点，拉出来</li><li>画一个完全图，需要找两两之间最短路</li><li>找最小权匹配</li><li>在原来的图中添边</li></ol><p>Fleury 算法（找欧拉闭迹）</p><ul><li>沿着图的非割边前行</li></ul><h1 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h1><h2 id="支配集"><a href="#支配集" class="headerlink" title="支配集"></a>支配集</h2><p>支配数 $ \gamma(G) $</p><p>支配周围的点</p><p>极小支配集的补集也是支配集</p><h2 id="点独立集"><a href="#点独立集" class="headerlink" title="点独立集"></a>点独立集</h2><p>点独立数 $ \alpha(G) $</p><p>任二顶点有 d(u)+d(v) &gt;= v(G)，则 a &lt; gamma</p><h2 id="点覆盖集"><a href="#点覆盖集" class="headerlink" title="点覆盖集"></a>点覆盖集</h2><p>覆盖了所有的边</p><h2 id="边覆盖集"><a href="#边覆盖集" class="headerlink" title="边覆盖集"></a>边覆盖集</h2><p>覆盖了所有的顶点</p>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高程学习笔记</title>
      <link href="/2019/02/26/%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/26/%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>高级程序设计复习笔记</p><p>参考书目：<br>《程序设计教程—用C++语言描述》陈家骏、郑滔<br>《Thinking in C++》机械工业出版社</p><h1 id="第1章-复习程设基础"><a href="#第1章-复习程设基础" class="headerlink" title="第1章 复习程设基础"></a>第1章 复习程设基础</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>分数组成：<br>作业10%<br>上机40%（现场oj和课后projects）<br>期末50%（据说较为简单）</p><h2 id="C-C-数据类型"><a href="#C-C-数据类型" class="headerlink" title="C/C++数据类型"></a>C/C++数据类型</h2><p><code>unsigned</code>类型运算不封闭，+*/封闭，-不封闭</p><p><code>float</code>类型 0.1+0.2!=0.3之类的</p><p><code>实数</code>相等条件，比较差的绝对值是否小于一个很小的数</p><p>联合类型用于用一种类型表示多种类型的数据，例如不同类型的数据组织在一起不能用array</p><p>指针是内存地址的抽象，用于动态变量（链表）、传递参数</p><h2 id="C-过程抽象"><a href="#C-过程抽象" class="headerlink" title="C++过程抽象"></a>C++过程抽象</h2><p><code>C++函数</code>与<code>数学函数</code>区别：</p><ol><li>C++函数可以没有返回值</li><li>可以有副作用(side effect)</li><li>同一个实参，不同时刻调用结果可以不一样</li></ol><h2 id="内存区安排"><a href="#内存区安排" class="headerlink" title="内存区安排"></a>内存区安排</h2><p>静态数据区</p><ul><li>全局变量</li><li>static局部变量</li><li>常量</li></ul><h1 id="第2章-对象与类"><a href="#第2章-对象与类" class="headerlink" title="第2章 对象与类"></a>第2章 对象与类</h1><p>把成员函数定义放在声明处，是建议编译器按内联函数处理。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>创建动态对象不用 malloc 和 free，原因是不会调用构造函数和析构函数。</p><p>无参数或全是默认参数的构造函数，是默认构造函数</p><p>隐式的构造函数仅调用<code>成员对象</code>所在类和基类的构造函数</p><p>一旦随便自定义了构造函数，编译器不再提供隐式构造函数</p><p>隐式的析构函数仅调用<code>成员对象</code>所在类和基类的析构函数</p><p>复制字符串时候 new char(strlen(str) <strong>+ 1</strong>)</p><h3 id="数据成员初始化"><a href="#数据成员初始化" class="headerlink" title="数据成员初始化"></a>数据成员初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span>&amp; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;a = <span class="number">1</span>;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> m, <span class="keyword">int</span> n):b(m), c(n)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    A a;</span><br><span class="line">    A1 a1;</span><br><span class="line">    A2 a2;</span><br><span class="line">    A3 a3;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;x = <span class="number">1</span>;&#125;</span><br><span class="line">    B(<span class="keyword">int</span> m):a(m, m)&#123;x = <span class="number">7</span>;&#125;</span><br><span class="line">    ~B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const int 和 int&amp; 数据成员必须用成员初始化表，如果这样的类不自定义构造函数，编译器不会为其生成默认构造函数，因此这样的类不能用于构造对象？</p><p>成员对象的初始化：默认按照成员对象的默认构造函数来，除非用<strong>成员初始化表</strong>进行显式调用，顺序 A1-A2-A3-B函数体，析构顺序 B函数体-A3-A2-A1</p><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A(<span class="keyword">const</span> A&amp; a);</span><br><span class="line">A(<span class="keyword">const</span> A&amp; a, <span class="keyword">int</span> m = <span class="number">1</span>, <span class="keyword">int</span> n = <span class="number">2</span>); <span class="comment">// 后面的必须是默认参数</span></span><br><span class="line">A(<span class="keyword">const</span> A a); <span class="comment">// 不行，考虑下面的例子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A re;</span><br><span class="line">    f(re); </span><br><span class="line">    <span class="comment">// 调用时，x需要用re初始化，相当于A x=A(re)</span></span><br><span class="line">    <span class="comment">// re又作为参数去初始化const A a，相当于A a = A(re)...无限递归[UST]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐式拷贝构造函数：普通成员直接拷贝（涉及资源申请的小心），成员对象调用它的拷贝构造函数</p><p>自定义拷贝构造函数：默认按照成员对象的默认构造函数来，除非用<strong>成员初始化表</strong>显式调用成员对象的拷贝构造函数，如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    A a;</span><br><span class="line">    B(<span class="keyword">const</span> B&amp; b):a(b.a) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h2><p>const 对象不能调用非 const 成员函数，所以<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="keyword">const</span> A* pa); <span class="comment">// *pa无法被改变</span></span><br><span class="line">f(<span class="keyword">const</span> A&amp; a); <span class="comment">// a无法被改变</span></span><br></pre></td></tr></table></figure></p><p>const 成员函数可以重载，效果[UST]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 谁调用？</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// A a 和 const A a？</span></span><br></pre></td></tr></table></figure></p><p>题外话<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p / <span class="keyword">int</span> <span class="keyword">const</span> * p; <span class="comment">// *p无法修改</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p <span class="comment">// p无法修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p <span class="comment">// *p和p均无法修改</span></span><br><span class="line">记忆方式：<span class="keyword">const</span>的右边第一个是*还是p</span><br></pre></td></tr></table></figure></p><h2 id="static-成员"><a href="#static-成员" class="headerlink" title="static 成员"></a>static 成员</h2><p>算是 class 的属性，所有对象共享。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    static int x = 0; // 或者类外 x = 1 都行</span><br><span class="line">    static B b; // 类外定义</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::x = 1; // ok</span><br><span class="line">int main() &#123;</span><br><span class="line">    A::x = 1; // error，别的函数看不到这一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>访问 private 和 protected</p><p>是<code>数据保护</code>和<code>数据访问效率</code>的折衷</p><h2 id="Demeter-法则"><a href="#Demeter-法则" class="headerlink" title="Demeter 法则"></a>Demeter 法则</h2><p>一个类的成员函数除了自己的直接子结构（数据成员），不能依赖于其他类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function">A <span class="title">func</span><span class="params">()</span></span>; <span class="comment">// 不遵守 Demeter 法则？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转移构造函数"><a href="#转移构造函数" class="headerlink" title="转移构造函数"></a>转移构造函数</h2><p>系统自动调用，用于返回一个对象的时候，节约资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A(A&amp;&amp; x) &#123;</span><br><span class="line">    p = x.p;</span><br><span class="line">    x = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>作为类的非静态成员函数</p><p>单目还是单目，双目还是双目。</p><p><em>既作为解引用，又作为乘法，咋办？[UST][CJJ: </em>默认已经作为解引用重载好了，只管乘法就行]</p><p>“.”, “.*”, “::”, “?:”, “sizeof” 不能重载</p><p>A&amp; operator++(); // 效果++a<br>A operator++(int i); // 效果a++，似乎是个右值表达式，似乎有骚操作</p><h3 id="操作符重载-1"><a href="#操作符重载-1" class="headerlink" title="= 操作符重载"></a>= 操作符重载</h3><p>=操作符被隐式重载，但如果类中有 const int 和 int&amp; 成员时，=不会隐式重载。</p><p>同拷贝构造函数的理，=操作符同样有即将消亡的对象赋值浪费的问题。<br>改进方法如下，该调用的时候编译器自动调用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>=(A&amp;&amp; x) &#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;x = *<span class="keyword">this</span>)&#123; <span class="comment">// 防止递归</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] x.p; <span class="comment">// 释放原来的资源</span></span><br><span class="line">    p = x.p; <span class="comment">// 转移资源</span></span><br><span class="line">    x.p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="new-重载"><a href="#new-重载" class="headerlink" title="new 重载"></a>new 重载</h3><p>作为类的 static 函数重载，static 可以不写<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> <span class="comment">// size_t size必须有，别的无所谓</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> x)</span></span></span><br></pre></td></tr></table></figure></p><h1 id="第3章-lamda-表达式"><a href="#第3章-lamda-表达式" class="headerlink" title="第3章 lamda 表达式"></a>第3章 lamda 表达式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="keyword">int</span> k,m,n; <span class="comment">//环境变量</span></span><br><span class="line">   ......</span><br><span class="line">   ...[](<span class="keyword">int</span> x)-&gt;<span class="keyword">int</span> &#123; <span class="keyword">return</span> x*x; &#125;... <span class="comment">//不能使用k、m、n</span></span><br><span class="line">   ...[&amp;](<span class="keyword">int</span> x)-&gt;<span class="keyword">int</span> &#123; k++; m++; n++; </span><br><span class="line">               <span class="keyword">return</span> x+k+m+n; &#125;... <span class="comment">//k、m、n可以被修改</span></span><br><span class="line">   ...[=](<span class="keyword">int</span> x)-&gt;<span class="keyword">int</span> &#123; <span class="keyword">return</span> x+k+m+n; &#125;...</span><br><span class="line"><span class="comment">//k、m、n不能被修改</span></span><br><span class="line">   ...[&amp;,n](<span class="keyword">int</span> x)-&gt;<span class="keyword">int</span> &#123; k++; m++; </span><br><span class="line">                         <span class="keyword">return</span> x+k+m+n; &#125;... <span class="comment">//n不能被修改</span></span><br><span class="line">   ...[=,&amp;n](<span class="keyword">int</span> x)-&gt;<span class="keyword">int</span> &#123; n++; <span class="keyword">return</span> x+k+m+n; &#125;... </span><br><span class="line">                                          <span class="comment">//n可以被修改</span></span><br><span class="line">   ...[&amp;k,m](<span class="keyword">int</span> x)-&gt;<span class="keyword">int</span> &#123; k++; <span class="keyword">return</span> x+k+m; &#125;...   </span><br><span class="line">                                    <span class="comment">//只能使用k和m，k可以被修改</span></span><br><span class="line">   ...[=] &#123; <span class="keyword">return</span> k+m+n; &#125;... <span class="comment">//没有参数，返回值类型为int</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记</title>
      <link href="/2019/02/25/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/25/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>计算机网络（Computer Network）复习笔记</p><p>参考书目：《计算机网络自顶向下方法（第5版）》机械工业出版社</p><h1 id="CH1-Introduction-of-Networking-1"><a href="#CH1-Introduction-of-Networking-1" class="headerlink" title="CH1-Introduction of Networking-1"></a>CH1-Introduction of Networking-1</h1><h2 id="杂记："><a href="#杂记：" class="headerlink" title="杂记："></a>杂记：</h2><p>CN负责数字通信（数字信号）</p><p>哈罗车筐前黑色是太阳能板？</p><p>宿舍-一层-一楼-学校网络中心-南京教育网（东大）-全国教育网</p><p>第一台联网计算机在UCLA</p><p>remote medicine 瓶颈在于时延</p><p>行星间联网，光速瓶颈</p><p>因特网是一个复杂系统，分解为<strong>5个子问题</strong>，谁来分解？如何分解？</p><hr><h2 id="课程主要讲述："><a href="#课程主要讲述：" class="headerlink" title="课程主要讲述："></a>课程主要讲述：</h2><ol><li>因特网如何工作？</li><li>子问题为什么这样解决？</li></ol><h2 id="讲解顺序："><a href="#讲解顺序：" class="headerlink" title="讲解顺序："></a>讲解顺序：</h2><ol><li>基础：包、链路、复用、时延、丢包</li><li>低级技术：以太网，无线局域网，3g，4g</li><li>IP，路由，BGP</li><li>网络互通后如何交换信息：DNS,CDN,HTTP,TCP</li><li>热点问题：数据中心、</li></ol><h2 id="课程任务："><a href="#课程任务：" class="headerlink" title="课程任务："></a>课程任务：</h2><ol><li>实验25%（现场提问，验收，改代码，严格）</li><li>作业15%</li><li>期末考试60%</li></ol><hr><h2 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h2><ol><li>电路交换：最基础的交换方式。点对点<br> 特点：<ol><li>中间所有资源都预留好</li><li>admission control per connection</li></ol></li><li>包交换：大家都把数据分为小数据包，一股脑发到交换机，交换机再转发，自由竞争，冲突了就丢一个，一个小包失败了就再发一次。（核心思想：统计复用）<br> 特点：<ol><li>包独立处理</li><li>admission control per packet</li></ol></li><li>虚链路：在包交换中模拟电路交换给vip用户优先权，以便冲突时优先满足vip用户</li></ol><hr><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>电路交换：在两点之间建立通道，src和dst之间直接连接（中间类似于多刀多掷开关）</p><p>建链-传输-拆链。想象成老电影里的电话局，处长和局长通话需要接线员接线、通话、拔线。</p><p>时间分片：比如，将1ms分为1000片，1000个用户同话，用户1通话时只占用1ms的第1片，然后若干个1ms组成了通话时间。如果有人通话量大，就多分几片。</p><p>频率分片：将频率切片，比如1Mhz的一段切成100片分给不同的用户，实际上要分很多级/空间复用，不然没法满足几亿用户的分配需求，频率之间不干扰，频率由国家法律严格控制，比如联通被分在800-850Mhz。</p><p>低频波的波长长，容易绕开障碍物。所以停用2G用户，这样子那一段频率就可以用来给5G了。</p><p>1G频分，2G时分，后面的利用更高级原理。</p><p><img src="/2019/02/25/计网学习笔记/" alt="电路交换的时序图1"></p><p><strong>为什么建链时有delay，拆链时没有delay？</strong><br>因为建链时，需要预留电路，要时间，可能会失败。拆链直接拆就行。</p><p><img src="/2019/02/25/计网学习笔记/" alt="电路交换的时序图2"></p><p>传输data时，不一定是连续的，不传输的时候就浪费了。比如2G/3G时代的手机QQ，发一个消息要建链-拆链一次，电费消耗大。在传大文件或者看电影才划算。</p><p><strong>优点：</strong></p><ol><li>predictable performance（保证一定送到，速度也有保障）</li><li>simple/fast switching (once circuit established)（建链后很简单）</li></ol><p><strong>缺点：</strong></p><ol><li>complexity of circuit setup/teardown（建链和拆链很麻烦）</li><li>inefficient when traffic is bursty（上述手机QQ的浪费、驿站的一匹马只运输一串荔枝，但实际上可以驼很多东西，这些空间浪费了。）</li><li>circuit setup adds delay（建链需要一来一回，增加时延，聊微信会很花时延）</li><li>switch fails-&gt;circuit fails（建链失败就完蛋）</li></ol><p>相似工作原理：华为手机之所以省电，在于有1个主CPU和几个小CPU，微信等通过小CPU。天线也是自己开屏幕才会工作，所以微信可能会收到不及时。</p><hr><h2 id="包交换"><a href="#包交换" class="headerlink" title="包交换"></a>包交换</h2><p>包交换：通信时像快递一样，只要写好每个数据包发货地址和收货地址，交换机只要负责查地址，就可以发了。核心思想是<code>统计复用</code>。</p><p>不保证性能：如果一大堆人同时发包，只能送一个，其他丢掉。或者用一个buffer缓存一下，再发。</p><p><strong>优点：</strong></p><ol><li>Efficient use of network resources</li><li><strong>simpler to implement</strong>（要求交换机做的事情很少，复杂的事交给端系统完成，就很便宜）</li><li>robust: can “route around trouble”（不存在链路建立失败的问题，比如一家快递倒闭了我换一家就可以了）</li></ol><p><strong>缺点：</strong></p><ol><li>unpredictable performance（由于buffer容量有限，只能保证大部分快递不送丢，类比双11快递公司的爆仓）</li><li>requires buffer management and congestion control（需要管理仓库和拥塞控制，管理仓库是这个快递费20，那个快递费5块，冲突就丢掉5块的。拥塞控制是双11短期取货码（被动，拥塞已经发生）、提前两三周开始双11（主动从源头控制）、南大驿站装不下就返回到上一级驿站）</li></ol><h2 id="统计复用-statistical-multiplexing"><a href="#统计复用-statistical-multiplexing" class="headerlink" title="统计复用 statistical multiplexing"></a>统计复用 statistical multiplexing</h2><p>Allowing more demands than the network can handle.</p><ul><li><p>hoping that not all demands are required at the same time（小区接入宽带，允许10个用户100M，但只给他们分配100M，因为假定他们不会同时用网，且一家人用不了100M。）（旅馆也住不了那么多人，正常情况下不会这么多人同时去住，如果想专享线路，建个行宫吧）</p></li><li><p>results in unpredictability（世界杯期间突然爆满）</p></li><li><p>works well except for the extreme cases（爆满的情况不符合统计复用的条件）</p></li></ul><h2 id="如何评价网络性能"><a href="#如何评价网络性能" class="headerlink" title="如何评价网络性能"></a>如何评价网络性能</h2><ul><li>时延delay</li><li>丢包率loss</li><li>吞吐量throughput（速率）</li></ul><p>无线网络侧重于丢包率</p><p>数据中心侧重时延</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>Consists</p><ul><li>transmission delay (link，取决于带宽，$数据量/带宽$)</li><li>propagation delay (link，取决于路长，$长度/光速$)</li><li>queueing delay<br>(取决于来的包，冲突就进队列，队列溢出就丢掉，由于包有编号，接收端数一数123457，丢了6号，那么通知发送方重发)(按均值和variance来衡量，由排队论设计好)（数据中心的主要时延）（平均排队时长）<blockquote><p>Littes’s law(1961)<br>L = A * W</p></blockquote></li><li>processing delay (有但可以忽略不计了，和电子工业发展有关) </li></ul><p>链路带宽bandwidth：八车道的八（同时有几个比特在链路里跑）</p><p>BDP = Bandwidth * propagation delay</p><p>$1G=10^9$</p><p>对于小文件，$D_{prop}$占主导，对于大文件，$D_{trans}$占主导时延</p><p>普通交换机遵循store-forward模式，交换机收到包先存起来解析包头再发下一站。<br>端(trans,prop,queue&amp;process)交换机()交换机()端</p><p>高频交换机（高频率股票交易）不遵循上述模式<br>带宽极高不用queue，收到1bit就直接发。</p><h3 id="丢包loss"><a href="#丢包loss" class="headerlink" title="丢包loss"></a>丢包loss</h3><h3 id="吞吐率throughput"><a href="#吞吐率throughput" class="headerlink" title="吞吐率throughput"></a>吞吐率throughput</h3><p>transmission rate R bits/sec</p><p>file of size F bits<br>packets of size L bits</p><p>Transfer time(T) = F/R + propagation delay</p><p>木桶原理，端到端的速率取决于最细的那一段</p><h2 id="Little-laws的证明"><a href="#Little-laws的证明" class="headerlink" title="Little laws的证明"></a>Little laws的证明</h2><p>$<br>\begin{equation}<br>\lambda\overset{def}{=}\lim\limits_{t\to \infty} \frac{N(t)}{t}, \text{the arrival rate into the system}<br>\end{equation}<br>$</p><p>$<br>\begin{equation}<br>\omega\overset{def}{=}\lim\limits_{n\to \infty} \frac{1}{n}\sum\limits_{j=1}^{n}W_j, \text{average sojourn time}<br>\end{equation}<br>$</p><p>$<br>\begin{equation}<br>l\overset{def}{=}\lim\limits_{t\to \infty} {\frac{1}{t}\int_{0}^{t}L(s)ds}, \text{average number in system}<br>\end{equation}<br>$</p><p>$<br>L(t):\text{the total number of customers in the system at time t.}<br>$</p><p>$<br>N(t)=max\{n:t_n\leq t\}<br>$</p><p>$<br>L(t)=\sum\limits_{n=1}^{\infty}{I\{t_n\leq t\leq t_n^a\}}=<br>$</p><p>$<br>\frac{1}{t}\sum\limits_{j:t_j^{\alpha}\leq t}{W_j} \leq \frac{1}{t}\int_{0}^{t}{L(s)ds} \leq \frac{1}{t}\sum\limits_{j:t_j &lt; t}{W_j}<br>$</p><p>后者=$ \lim\limits_{t\to \infty} \frac{N(t)}{t} \frac{1}{N(t)}\sum\limits_{j=1}{N(t)}W_j $</p><p>Lemme: if $\lambda$ and $\omega$ exists and finite, then</p><script type="math/tex; mode=display">\lim\limits_{n\to \infty}{\frac{W_n}{n}=0}, \lim\limits_{n\to \infty}{\frac{W_n}{t_n}=0}</script><p>前者<img src="/2019/02/25/计网学习笔记/" alt="手机图片"></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>层与层之间没有耦合关系，所以更新时候方便。</p><p>OSI七层（L7应用层，L6表示层，L5会话层），TCP\IP五层</p><p>沙漏状的五层：（海淘）<br>应用层-CEO写的内容（确定到南大的哪个人）（千万种协议）<br>传输层-秘书（写美国哪个州哪个县）（TCP可靠，UDP不可靠）<br><strong>网络层-全球可达（only IP，基石）</strong><br>链路层-局部可达<br>物理层-计科不管</p><p>应用层-&gt;传输层，加header指明给对方的哪个进程<br>传输层-&gt;…，类似</p><p>端系统5层全要，中间的交换机只要下3层即可，负责信息的到达（联邦快递）。</p><p>传输层和网络层原本部署在 CPU 上，现在为了快速转到了网卡上。</p><p>pros:</p><ol><li>reduce complexity（分而治之）（负责分拣的就分拣，运货的就运货）</li><li>improve flexibility（每一层只对上层负责，内部实现可以改）（用飞机送和用马车送）</li></ol><p>cons:</p><ol><li>higher overheads（每一层的header，占总大小5%-8%）</li><li>cross-layer information often useful（上下层可以互相偷窥对方的内容，因为只是加了header）</li></ol><p>IP层不好改，打过了很多补丁。IPv4-&gt;IPv6的演进。就像给行驶中的高铁换轮子还不能让高铁发现。<br>IPv4是32bit的，所以它只能有4G个地址，不够用。</p><p><strong>End-to-end argument</strong><br>中间节点越简单越好，只负责转发就行了，复杂的事情交给终端。不然中间的设备太复杂成本高。</p><p>墙的效果：在物理层偷窥应用层，不符合要求就咔嚓</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>分层很棒</li><li>网络层最重要，将应用和底层完全隔离开</li><li>E2E arguments 激励我们 keep IP simple</li></ol><h1 id="第2章-链路层"><a href="#第2章-链路层" class="headerlink" title="第2章 链路层"></a>第2章 链路层</h1><p>术语<br>L3: packet<br>L2: frame</p><h3 id="data-link-layer-做的事："><a href="#data-link-layer-做的事：" class="headerlink" title="data link layer 做的事："></a>data link layer 做的事：</h3><ul><li>framing（将 L3 的 packet 封成 frame）</li><li>link access（宿舍四个人在使用同一个物理机，决定谁来用）</li><li>reliable delivery（应对错误和丢包丢 frame，用于无线网/基站通信，一个包发两次或者其他保护机制）</li><li>error detection and correction（包收到了，但内容不对，用校验码，纠错码）</li></ul><h3 id="传输方式："><a href="#传输方式：" class="headerlink" title="传输方式："></a>传输方式：</h3><ul><li>point to point（海底光缆，电话线，以太网-墙上的网口）</li><li>broadcast（无线局域网，不安全= =，几个人会同时讲话）</li></ul><h4 id="广播-broadcast"><a href="#广播-broadcast" class="headerlink" title="广播 broadcast"></a>广播 broadcast</h4><p>广播方式中，物理媒介是共享的，如何决定谁说话？</p><ul><li>channel partitioning: 切片，一人一片，类似电路交换，分频率，效率不高</li><li>taking turns: 轮流上</li><li>random access: 每个人想发就发，协议决定谁发（不避免 collision，而是解决 collision）（分布式）</li></ul><p>random access protocol(MAC)<br>do: <strong>detect and recover</strong> from collisions</p><p>所谓 protocol:</p><ul><li>pattern（先说一句hello）</li><li>senmatic（然后开始交流）</li></ul><h3 id="broadcast-Ethernet（老）"><a href="#broadcast-Ethernet（老）" class="headerlink" title="broadcast Ethernet（老）"></a>broadcast Ethernet（老）</h3><p>CD: collision detection</p><p>老的是 broadcast 方式，新的是网口直连交换机。</p><p>CSMA(carrier sense multiple access)<br>发之前监听一下，媒体空着我就说话，没空着我就等等再说<br>问题在于，有传播时延、还是有冲突没法消灭</p><p>CSMA/CD<br>limits:</p><ul><li>包的最小值</li><li>传输距离最大值</li></ul><p>原因：propagation delay</p><p>以太网最短帧限定 64bytes</p><p>Q: 冲突后 AB 都停止发送，何时重新开始？<br>AQ: 随机一段时间再发，随机多久？<br>A: binary exponential back-off（在小区间里取随机数，发，失败了就在更大区间里取随机数，重复，直到不拥塞）</p><p>CSMA/CD 效率<br>$ Efficiency \approx \frac{d_{trans}}{d_{trans}+5d_{prop}} $</p><h3 id="switched-Ethernet（新）"><a href="#switched-Ethernet（新）" class="headerlink" title="switched Ethernet（新）"></a>switched Ethernet（新）</h3><p>点到点，交换机判断 A 和 C 通信，那么 A 的消息就不往 B 和 D 发了。</p><h3 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h3><p>以太网协议除了帧格式没变，其他基本都变了，API 为帧格式。</p><p><img src="/2019/02/25/计网学习笔记/" alt="PPT图示以太网帧结构"></p><ul><li>preamble: 8 bytes 前导码，7用于时钟同步，1用于表示帧开始</li><li>address: 6 bytes，dst+source</li><li>type: 2 bytes，表明高层协议</li><li>data payload: max 1500, min 64 bytes</li><li>CRC: 4 bytes for error dectection</li></ul><p>Q: 如何决定帧在传输时，从何开始从何结束？<br>A1: 开头说明帧多长（弊端，可能会在传输中出错）<br>A2: 开头结尾加哨兵，比如0111110表示开头，01111111表示结尾（弊端，哨兵出现在 frame contents 中，提前结束）（解决方法：发送端向 frame contents 中加0，由网卡自动完成，接收端去0，使得哨兵不会出现在 contents 中）</p><p>MAC address（48 bit，二层地址，局部有效，身份证）<br>IP address（标识你在网络空间里的位置，邮政编码）</p><h3 id="路由-routing"><a href="#路由-routing" class="headerlink" title="路由 routing"></a>路由 routing</h3><h4 id="routing-with-broadcast-ethernet"><a href="#routing-with-broadcast-ethernet" class="headerlink" title="routing with broadcast ethernet"></a>routing with broadcast ethernet</h4><p>Q: 如何在广播以太网里路由？<br>A: 即插即用，都接在一根铜缆上</p><p>Q: 同一楼层用一根线，不同楼层<br>A: 用网桥 bridges，连接不同 LAN</p><p>broadcast storm 问题：假如不同 LANS 间有环路，信号永生，信号循环加强，gg</p><p>解决思路：无环路的连通图是树，给网络图找生成树，保留节点，去掉链路。</p><h5 id="spanning-tree-protocol"><a href="#spanning-tree-protocol" class="headerlink" title="spanning tree protocol"></a>spanning tree protocol</h5><p>nice properties:</p><ul><li>zero configuration（即插即用，自动配置）</li><li>self healing（坏了一台，可以迅速重新构建拓扑）</li></ul><h4 id="routing-with-switched-ethernet"><a href="#routing-with-switched-ethernet" class="headerlink" title="routing with switched ethernet"></a>routing with switched ethernet</h4><p>要求：即插即用</p><p>问题：依然存在广播数据包，交换机之间会有环<br>flooding 洪泛</p><h4 id="spaning-tree-算法"><a href="#spaning-tree-算法" class="headerlink" title="spaning tree 算法"></a>spaning tree 算法</h4><p>思想：</p><ol><li>pick a root（选一个 MAC 地址最小的作为 root，约定俗成）</li><li>计算其他节点到 root 的最短路，只保留最短路上的链路，多个最短路就选一条（比如选 MAC addr 最小的，约定俗成）</li></ol><p>算法内容：<br>[UST]见PPT</p><p>1次洪泛可以确定所有主机 MAC 地址、root 地址？<br>A 不知道 B 在哪时，就把 dst 设为全 f，总能传播到，路上的交换机也知道 A 在哪了，这样 B 再回个包就能顺利到 A</p><p>交换机干的事：</p><ol><li>看看 A 来的包以前来过没，没来过就加入 switch table</li><li>表里的项如果过了生存期还没有被使用，就删掉表项（原因：容量有限、A 可能会离开这片有线网）</li><li>收到单播数据包，当发现目标节点不认识时，就 forwarding</li></ol><h4 id="以太网-pros-and-cons"><a href="#以太网-pros-and-cons" class="headerlink" title="以太网 pros and cons"></a>以太网 pros and cons</h4><p>pros</p><ol><li>即插即用</li><li>自愈</li><li>便宜</li></ol><p>cons</p><ol><li>带宽浪费（spanning tree 把很多枝砍掉了）</li><li>重建 spanning tree 时的延迟（新插入节点的 id 是0，那么它会是新 root）</li><li>对付移动中的设备比较慢（云平台，虚拟机快速移动）</li><li>可预测性差（A 找 B 不知道找多久，但问题不大，因为很快）</li></ol><h3 id="即插即用咋实现的"><a href="#即插即用咋实现的" class="headerlink" title="即插即用咋实现的"></a>即插即用咋实现的</h3><p>Q: 一台主机来时，只有 MAC 地址，怎么知道 IP 地址，邮政编码？<br>A: ARP, DHCP protocol</p><p>功能：</p><ul><li>discovery of local end-host<ul><li>for communication between hosts on the same LAN</li></ul></li><li>bootstrap communication with remote hosts<br>  what is my<ul><li>IP addr</li><li>local DNS server</li><li>first hop router</li></ul></li></ul><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>a host uses DHCP to discover</p><ul><li>IP addr</li><li>netmask</li><li>IP addr for its local DNS name server （没有DNS也能通信，直接输入 IP 地址就行，DNS 坏了表现为 www.baidu.com 上不去，但QQ（内置了对方IP地址）可以用）</li><li>IP addr for its fist-hop “default” router(s)</li></ul><p>过程如下：<br>一个 DHCP 服务器把 IP addr，DNS addr 都弄好<br>用户先用全 f 进行广播，所有的 DHCP 服务器（一个就能工作，多个为了鲁棒）回一个 offer<br>用户选择一个，发一个 request， DHCP 服务器回一个 ACK<br>然后就能用了</p><p>DHCP uses “soft state”（软状态就好比普通内存，得不停的刷它，不然比特会翻转，所以得一直耗电，硬状态好比固态硬盘，即使不给他电，比特也不会翻转）<br>一个用户比如12小时不继续申请，DHCP server 就收回 IP addr，适用于咖啡馆这类客户用会就走了<br>如果用户在到期前“续租”，配置不会改变，应用不会断（网上银行之类，换个 IP addr 就直接断开），如果过期后续租，IP addr 可能就改了</p><p>如果用户挂了，租约到期时 DHCP 回收回<br>如果 DHCP 挂了，租约到期前用户正常使用，到期后用户企图续租，但没人鸟他，该 IP addr 就没法用了<br>如果用户和 DHCP 之间的链路挂了，用户到期前正常，到期后找别的 DHCP 服务器</p><h4 id="ARP-DNS"><a href="#ARP-DNS" class="headerlink" title="ARP, DNS"></a>ARP, DNS</h4><p>假设我的 IP addr 为 1.2.3.53<br>掩码 netmask 是 1.2.3.0/24<br>DNS IP addr 为 1.2.3.156</p><ol><li>在网页浏览器输入 www.sina.com</li><li>浏览器一看，就去问 DNS，由于在以太网内，就要知道 DNS 的 MAC addr</li><li>怎么知道呢，在以太网内广播一次，就知道哪个 MAC addr 拥有 1.2.3.156 这个 IP addr（即使要通信10000次也只要广播一次就知道 MAC addr 了）</li><li>利用每个主机都有一张 ARP table，记录最近和本主机通信过的 <ip addr,="" mac="" addr=""></ip></li></ol><p>本地通信：<br>直接丢局域网就解决了（类似同一个宿舍传递毛巾）</p><p>远程通信：<br>丢到网关里，然后事情丢给网关（类似快递丢给快递员，怎么送我就不关心了）</p><p>远程通信的四大关键要素：<br>IP addr<br>netmask<br>DNS IP addr<br>Gateway IP addr</p><p>ARP 负责 链路层和网络层映射<br>DNS 负责 应用层和网络层映射</p><p>DNS 是一级级的，有南大级别的，教育网级别的，中国级别的…</p><h3 id="无线网络-WLAN"><a href="#无线网络-WLAN" class="headerlink" title="无线网络 WLAN"></a>无线网络 WLAN</h3><p>wireless != mobility</p><p>handoff: mobile changes base station providing connection into wired network（从南校门走到北校门，手机用的基站已经换了一个了）<br>5G 目标就是解决高铁高速移动中迅速切换基站</p><p>基站：<br>可以理解为连接无线和有线的，解决最后一公里问题。<br>部署在位置比较好的地方，铁塔公司把基站后连接有线连入因特网核心</p><p>无线链路：<br>按照目标来划分，目标有：通信距离</p><p>无线网络通信的两种方式</p><ol><li>infrastructure mode（一台通信车，其他人通过通信车进行通讯，通信车被炸了就没法通信了）</li><li>ad-hoc mode（每个人都是一个节点，能和其他人进行通信，挂了一个其他人不影响）</li></ol><p>single hop: 宿舍两个人手机通信，实际上 A-AP-B<br>multiple hop: MANET, VANET（车联网用的到，企图把道路上的一片区域的车组成小网络，防止碰撞）</p><p>无线连接的特征：</p><ol><li>decreased signal strength: 信号衰减<br> 自由路径损失公式<br> free space path loss(FSPL)<br> $ FSPL = (\frac{4\pi df}{c})^2 $<br> d = distance<br> $\lamda$ = wave length(c/f)<br> f = frequency<br> c = speed of light</li></ol><hr><p><strong>TODO:</strong><br>第5周周四的课补</p><hr><h1 id="第3章-网络层"><a href="#第3章-网络层" class="headerlink" title="第3章 网络层"></a>第3章 网络层</h1><h2 id="IP-Layer"><a href="#IP-Layer" class="headerlink" title="IP Layer"></a>IP Layer</h2><p>IP 包：IP header + 四层的 payload</p><p>IP 层只关心 header，类比快递员只关心快递盒子上贴了什么快递单</p><p>IP header 作为下两者的 interface：</p><ol><li>source and destination（发件人和收货人）</li><li>source and network（发件人和收货地址）</li></ol><h3 id="IP-协议设计时要完成的目标"><a href="#IP-协议设计时要完成的目标" class="headerlink" title="IP 协议设计时要完成的目标"></a>IP 协议设计时要完成的目标</h3><ol><li>解析包</li><li>传送包</li><li>处理第三层遇到的问题：<ol><li>routing 的死循环（类似二层交换机的死循环）</li><li>出错误</li><li>包太大</li></ol></li><li>协议可扩展</li><li>信息传递优先级（类似顺丰隔日达、今日达，只看你给钱多）</li></ol><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><h4 id="目标1-parse-packet"><a href="#目标1-parse-packet" class="headerlink" title="目标1 parse packet"></a>目标1 parse packet</h4><ul><li>IP version number（4 bit），packet length（16 bit）</li></ul><h4 id="目标2-carry-packet-to-Destination"><a href="#目标2-carry-packet-to-Destination" class="headerlink" title="目标2 carry packet to Destination"></a>目标2 carry packet to Destination</h4><ul><li>destination packet addr（32 bit）</li></ul><h4 id="目标3-handle-problem"><a href="#目标3-handle-problem" class="headerlink" title="目标3 handle problem"></a>目标3 handle problem</h4><ol><li><p>preventing loops（TLL）<br> 为什么不用二层的 spanning tree？</p><ol><li>太大了不好剪</li><li><p>局域网里链路很便宜，广域网太贵了，一条光纤不能扔那不用</p><p>解决：<br>在包里加了 Time-to-Live（TTL）field（8 bit），每被发一次，TTL 就减一点，减到0就丢掉这个包<br>负责丢的路由器告诉 source 没发成</p></li></ol></li><li><p>corruption<br> checksum（16 bit），每发一次都计算一次 checksum，保证刚才一跳中包头未发生改变</p></li><li><p>fragmentation<br> frag（32 bit）</p></li><li><p>evolution<br> version number（4 bit）+ special handling</p><p> special handling：</p><ul><li>type of service（8 bit）</li></ul></li></ol><h3 id="IP-header-结构"><a href="#IP-header-结构" class="headerlink" title="IP header 结构"></a>IP header 结构</h3><p><img src="/2019/02/25/计网学习笔记/" alt="PPT完整图！"></p><h4 id="fragmentaion"><a href="#fragmentaion" class="headerlink" title="fragmentaion"></a>fragmentaion</h4><p>每个 link 有一个最大传输单元，从一段大链路到另一段小链路时需要切片加头。</p><p>Q: 何时重组？<br>A: 接收端重组比较好，不要让中间路由器做重组的事，否则</p><ol><li>影响效率</li><li>且包可以走很多条路，只有接收端这个唯一终点。</li><li>还能再被切更小</li></ol><p>体现了 E2E principle（中间节点傻，只干转发的事，终端智能）</p><p>切片重组需要</p><ol><li>知道是谁的分片</li><li>是第几片分片</li><li>还能继续切小</li></ol><p>fragmentation fields:</p><ol><li>identifier</li><li>flags</li><li>offset</li></ol><h3 id="IPv6-小览"><a href="#IPv6-小览" class="headerlink" title="IPv6 小览"></a>IPv6 小览</h3><ol><li>解决 IPv4 地址只有 32 bit IP 地址，地址不够的问题。进化到 128 bit 的地址，足以给太阳系内每一颗沙子分地址</li><li>简化 IPv4 里不必要的东西（</li></ol><h4 id="IPv6-哲学"><a href="#IPv6-哲学" class="headerlink" title="IPv6 哲学"></a>IPv6 哲学</h4><ol><li>don’t deal with problems: leave to ends（网络要做的只是传得快、不丢包）<ul><li>删去 fragmentation 和 checksum</li><li>保留 ttl</li></ul></li><li>simplify handling<ul><li>use next header</li><li>删去 header length</li></ul></li><li>provide general flow label for packet<ul><li>not tied to semantics(语义)</li><li>高灵活性</li></ul></li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li>网络层可分为数据平面和控制平面<ul><li>数据平面负责转发</li><li>控制平面负责指挥</li></ul></li></ol><h2 id="IP-router"><a href="#IP-router" class="headerlink" title="IP router"></a>IP router</h2><p>IP router 的架构大大小小都差不多，差别就是吞吐量</p><p>如何评价 router？</p><ul><li>Router capacity = N * R</li><li>N = number of external router “ports”（有几个口）</li><li>R = speed(“line rate”) of a port（一个口有多快）</li></ul><p>router 分类：</p><ol><li>core</li><li>edge（两种，一种和别的运营商交互，另一种和自家用户交互）</li><li>small business（家庭用）</li></ol><h3 id="router-结构："><a href="#router-结构：" class="headerlink" title="router 结构："></a>router 结构：</h3><p><img src="/2019/02/25/计网学习笔记/" alt="router结构ppt"></p><h4 id="入线卡-input-linecards"><a href="#入线卡-input-linecards" class="headerlink" title="入线卡 input linecards"></a>入线卡 input linecards</h4><p>任务：</p><ul><li>接受发过来的数据包</li><li>更新 IP 包头<ul><li>TTL-1, checksum, options and fragment(ipv4)</li><li>TTL-1(ipv6)</li></ul></li><li>查本地的 forwarding table 去找 dest IP addr 的出端口</li></ul><p>挑战：speed<br>100B packets @ 40Gbps -&gt; new packet every 20 nano secs</p><p>IP 包最小长度 64 bit，路由器能力评价标准 是能处理最小的包是多小，因为这决定了速度</p><p>查 forwarding table</p><ul><li>1个端口对应一块地址，而不是1个 IP addr</li></ul><p>如何找端口呢？找端口主要是根据 IP addr 的网络号进行找</p><ol><li>软件方法：用树的结构，根据网络号一级级往下分</li><li>硬件方法：?</li></ol><h4 id="出线卡-output-linecards"><a href="#出线卡-output-linecards" class="headerlink" title="出线卡 output linecards"></a>出线卡 output linecards</h4><p>任务：</p><ul><li>分类：map packets to flows</li><li>决定何时、丢哪个包</li><li>传输哪个包（优先级）</li></ul><p>调度策略：</p><ol><li>fair</li><li>weighted</li></ol><h4 id="入卡和出卡的连接"><a href="#入卡和出卡的连接" class="headerlink" title="入卡和出卡的连接"></a>入卡和出卡的连接</h4><ol><li>共享一块内存（低端货</li><li>总线（低端货</li><li>系统内部网络，做到入口和出口间传输不互相干扰（有点像数电的可编程阵列？</li></ol><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ol><li>IP router 是因特网骨干</li><li>速度和公平</li></ol><h2 id="routing-算法"><a href="#routing-算法" class="headerlink" title="routing 算法"></a>routing 算法</h2><p>goal:</p><ol><li>find a path</li><li>make the state contained in forwarding tables meets our goal</li></ol><p>评价路由算法：</p><ol><li>有效正确，即收敛</li><li>收敛地越快越好</li></ol><h3 id="local-state-vs-global-view-of-state"><a href="#local-state-vs-global-view-of-state" class="headerlink" title="local state vs. global view of state"></a>local state vs. global view of state</h3><p>单看一个路由器，无法判断它正确与否。要判断正确（即是否能正确转发到目的地），得看全局。</p><h3 id="路由正确性的充要条件"><a href="#路由正确性的充要条件" class="headerlink" title="路由正确性的充要条件"></a>路由正确性的充要条件</h3><ol><li>没有死路（即不会出现一个路由器在接到包后，不知道这个数据包该往哪发）<pre><code>     （case 1, case 2, ..., default。default 来保证没有 dead ends)</code></pre></li><li>没有环路</li></ol><h3 id="least-cost-path-routing（收敛的越快越好）"><a href="#least-cost-path-routing（收敛的越快越好）" class="headerlink" title="least-cost path routing（收敛的越快越好）"></a>least-cost path routing（收敛的越快越好）</h3><p>dijkstra 算法</p><h2 id="routing-协议（自治域内部）"><a href="#routing-协议（自治域内部）" class="headerlink" title="routing 协议（自治域内部）"></a>routing 协议（自治域内部）</h2><p>基于 dijkstra 算法</p><ul><li>link-state routing</li><li>distance-vector routing</li></ul><p>dijkstra 算法要知道全局的拓扑</p><p>工程做起来有两种方法：</p><ol><li>一个独立的 machine 计算完，再分发给各个节点</li><li>将全网拓扑广播给所以路由器，每个路由器都算一下，结果是一样的</li></ol><p>Internet 使用2</p><h3 id="link-state-routing"><a href="#link-state-routing" class="headerlink" title="link-state routing"></a>link-state routing</h3><p>每个节点都知道和自己直接相邻的路的 cost<br>每个节点都会把自己的状态广播给其他所有路由器，周期性地。<br>还有就是 cost 改变时也会广播。</p><p>洪泛过后大家重新计算 least-cost path</p><p>点数为 N, 边数为 E<br>复杂度 N*E</p><h4 id="何时洪泛？"><a href="#何时洪泛？" class="headerlink" title="何时洪泛？"></a>何时洪泛？</h4><p>洪泛不需要 routing 规则，直接发到广播端口的。所以在这里只能用洪泛不能用路由，因为路由还没建立呢。</p><ol><li>拓扑改变了（节点挂了，下线了）</li><li>cost 改变了</li><li>周期性的，告诉别人你还活着</li></ol><h4 id="收敛时延-convergence-delay"><a href="#收敛时延-convergence-delay" class="headerlink" title="收敛时延 convergence delay"></a>收敛时延 convergence delay</h4><p>时延太长会导致一台 router 还活在旧的状态理解里，搞不好会出环路</p><h4 id="收敛过程中可能发生"><a href="#收敛过程中可能发生" class="headerlink" title="收敛过程中可能发生"></a>收敛过程中可能发生</h4><ol><li>looping packets</li><li>包进死胡同丢了</li><li>由于发的过程中 path 可能改变，先发的数据后到了，而后发的数据先到了</li></ol><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ol><li>O(NE) messages 洪泛</li><li>O(N^2) computation time | dijkstra算法时间</li><li>O(network diameter) 收敛时延，主要是传播时延</li><li>O(N) entries in forwarding table</li></ol><h4 id="link-state-routing-协议"><a href="#link-state-routing-协议" class="headerlink" title="link-state routing 协议"></a>link-state routing 协议</h4><p>OSPF: open shortest path first</p><p>IS-IS: intermediate system to intermediate system</p><p><strong>讲到现在的所有协议都是 AS 内部的协议</strong></p><h3 id="distance-vector-协议"><a href="#distance-vector-协议" class="headerlink" title="distance-vector 协议"></a>distance-vector 协议</h3><p>router 不需要把自己的信息洪泛给全网，只要告诉邻居节点他对世界的看法就行了，这有益于分布式</p><h4 id="B-F-算法"><a href="#B-F-算法" class="headerlink" title="B-F 算法"></a>B-F 算法</h4><p>看 ppt 上的具体示例</p><p>节点 x 知道它到所有邻居的距离 d_i ，然后他的邻居 i 到目标的距离 dis_i 是已知的，所以只要遍历邻居，取 d_i + dis_i 之和的最小值即可。</p><p>节点发生改变时告诉它的邻居，然后向外更新 vector</p><h4 id="B-F-算法有的问题"><a href="#B-F-算法有的问题" class="headerlink" title="B-F 算法有的问题"></a>B-F 算法有的问题</h4><p>看 ppt 具体例子</p><ol><li>形成 routing loops，要互相丢包很久才能恢复到正确状态，期间没有包能被发送</li></ol><h4 id="解决办法-poinsoned-reverse-毒药逆转"><a href="#解决办法-poinsoned-reverse-毒药逆转" class="headerlink" title="解决办法 poinsoned reverse 毒药逆转"></a>解决办法 poinsoned reverse 毒药逆转</h4><p>若 z 经过 y 到达 x，那么 z 会告诉 y 自己到 x 的距离是 正无穷，这样 y 就不会考虑通过 z 到达 x。<br>否则 z 会告诉 y 它到 x 的真实距离。</p><p>x-y cost &lt; y-z cost</p><p>这样子假如 x-y 挂了，y 发现自己到 x 是无路可走的，y-x 更新为正无穷。这个消息传到 z，z-x 被启用，这个消息再正确的传给 y，y 就可以通过 z 到达 x 啦。</p><p>看 ppt 具体例子</p><h4 id="解决办法-path-routing"><a href="#解决办法-path-routing" class="headerlink" title="解决办法 path routing"></a>解决办法 path routing</h4><p>不单单广播距离，还广播向量，这样邻居就知道它之前是怎么走的了。（不考）</p><h3 id="LS-和-DV-不同点"><a href="#LS-和-DV-不同点" class="headerlink" title="LS 和 DV 不同点"></a>LS 和 DV 不同点</h3><p>信息告知：<br>LS: O(NE) 因为是全网洪泛<br>DV: O(E) 只要告诉邻居就行</p><p>收敛速度：<br>LS: 比较快<br>DV: 可能出现 loop，然后要一段时间才能恢复，即使用了毒药逆转</p><p>鲁棒性：（假定所有节点都是善意的）（节点挂了尽快恢复，且不出错就是鲁棒）<br>LS:</p><ul><li>可能广播错误的 link cost，然后影响其他节点</li><li>每个节点自己算自己的</li></ul><p>DV:</p><ul><li>可能传播错误的 path cost</li><li>每个节点算自己的，但别人还依赖你的计算结果，所以错误会蔓延</li></ul><h3 id="LS-和-DV-相似点"><a href="#LS-和-DV-相似点" class="headerlink" title="LS 和 DV 相似点"></a>LS 和 DV 相似点</h3><p>目的都是找最短路</p><p>用于同一个 AS 域内，都是友军</p><p>下节课讲 AS 之间的 routing</p><h2 id="routing-协议-（自治域之间）"><a href="#routing-协议-（自治域之间）" class="headerlink" title="routing 协议 （自治域之间）"></a>routing 协议 （自治域之间）</h2><p>IXP: 不提供服务，只负责交换 ISP 和 ISP 之间的信息，这样两个 ISP 之间就不用特地建立物理线了。（运营商间的交换机）</p><p>域间路由的挑战：</p><ol><li>全球寻址</li><li>管理<ul><li>自治管理，策略，隐私（可以不告诉对方自己的内部路由细节）</li></ul></li></ol><h3 id="scaling"><a href="#scaling" class="headerlink" title="scaling"></a>scaling</h3><p>路由器必须全球可达</p><p>一个操作就是把一个范围内的 IP 一个 entry。而不是一个 IP 一个 entry。</p><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><p>涉及商业竞争：</p><ol><li>我不走我竞争者的网</li><li>我不让竞争者走我的网</li></ol><h3 id="域间路由算法"><a href="#域间路由算法" class="headerlink" title="域间路由算法"></a>域间路由算法</h3><p>丢弃 Link-state</p><ol><li>没隐私，因为要广播自己的世界看法</li><li>得商量 cost 咋定义</li></ol><p>distance-vector</p><ol><li>需要改进，叫 BGP</li><li>需要去环路</li><li>需要加入 policy</li></ol><h3 id="IPv4-设计（为了scaling）"><a href="#IPv4-设计（为了scaling）" class="headerlink" title="IPv4 设计（为了scaling）"></a>IPv4 设计（为了scaling）</h3><p>一段 host 地址一般全0，全1，01不能用（留给网关）</p><p>一开始分为 ABCD 四类地址，愚蠢的设计</p><p>CIDR: 无类别的</p><p>比如一个公司 50 台主机，2^5 &lt; 50 &lt; 2^6，移动就给你 32 - 6 = 26 位前缀，IP 范围就是 128.23.9/26。掩码 26 个 1，6 个 0</p><p>大运营商层层分 IP，比如分给南大一段，南大再给下面的机子分配，运营商联系南大的时候，不需要知道南大下面的具体细节，只要知道是发往南大就行，剩下来的事情交给南大的路由器。</p><p>这就是聚合。</p><h3 id="AS-之间的关系"><a href="#AS-之间的关系" class="headerlink" title="AS 之间的关系"></a>AS 之间的关系</h3><p>AS A 可以是 B 的客户（付钱）</p><p>可以是 B 的提供商（付钱）</p><p>可以是 B 的对端，有双向合作的那种（互相不收钱，交换起来数据比不能过 1:3 或 3:1，在这个范围内不收钱，超了就收钱了）</p><h3 id="为什么会有-peer？"><a href="#为什么会有-peer？" class="headerlink" title="为什么会有 peer？"></a>为什么会有 peer？</h3><p>本来因特网是树，只有上下级关系，但因为钱，同级别的可以不经过上层传，而是直接传</p><p><img src="/2019/02/25/计网学习笔记/" alt="routing follows the money 图片"></p><p>B 没有义务帮 A 和 C 省钱，所以 D 走到 E 不能通过 A-B-C 路</p><p>域间路由的第一要义不是最短路！是省钱！题目分析是要看 经过的路上的 AS 是不是得到了利益，没得到就不能过这个 AS。</p><p>以及，不会先向下走再向上走。因为下层没有义务帮上层的 AS 传数据，不赚钱。</p><h3 id="BGP-协议"><a href="#BGP-协议" class="headerlink" title="BGP 协议"></a>BGP 协议</h3><p>先选一条 ASes 路，这条路反映了 物理链路通达 且 有商业关系。</p><p>两个 AS 的边防局互相交流就是 “讲 BGP 语言”</p><p>类似 DV，一个 AS 广播它到某一个 IP 域的 cost</p><h4 id="BGP-和-DV-的区别"><a href="#BGP-和-DV-的区别" class="headerlink" title="BGP 和 DV 的区别"></a>BGP 和 DV 的区别</h4><ol><li>不一定选最短路（钱）</li><li>path-vector 广播到某个 IP 网络的 path，而不只是距离，这样就可以避免环路了，还可以自己选择路径</li><li>广播策略可选，比如可以不广播</li><li>aggregate route，目的地址都在一起，可以合并以减少路由表</li></ol><h4 id="路怎么选"><a href="#路怎么选" class="headerlink" title="路怎么选"></a>路怎么选</h4><ul><li>为了赚钱，路由的路选哪好？customer &gt; peer &gt; provider</li><li>最大化 performance，最短 AS path 长度</li><li>最小化带宽，热土豆策略</li></ul><p>Gao-Rexford：<br>路由不往下走？<br>AS policy graph 应当是有向无环图</p><p>边防局 border routers</p><p>RFC: request for comments 制定于每年三次的 ietf 会议</p><h4 id="eBGP-iBGP-IGP"><a href="#eBGP-iBGP-IGP" class="headerlink" title="eBGP, iBGP, IGP"></a>eBGP, iBGP, IGP</h4><p>eBGP: 边防局交流</p><p>iBGP: 边防局和内部人员交流（学习外交部文件，交给内部人员学习）</p><p>IGP: 内部人员交流</p><h4 id="BGP-中的基本信息"><a href="#BGP-中的基本信息" class="headerlink" title="BGP 中的基本信息"></a>BGP 中的基本信息</h4><p>Open: 验明身份</p><p>notification：报故障</p><p>update：</p><p>keep alive：</p><h4 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h4><ol><li><p>AS path 矢量（每个 AS 都有独立编号）</p></li><li><p>local preference（对内消息，有多条出去的路的情况下，告诉内部人员走哪比较好，机密）</p></li><li><p>MED: multi-exit discriminator（对于每个 IP 的前缀，指定走哪里，南京的联通和移动通话没必要走到北京再走回来）</p></li><li><p>IGP cost（hot-potato）</p></li></ol><h4 id="可达问题"><a href="#可达问题" class="headerlink" title="可达问题"></a>可达问题</h4><p>不一定</p><h4 id="安全问题（想断就断，不想断就让他连着）"><a href="#安全问题（想断就断，不想断就让他连着）" class="headerlink" title="安全问题（想断就断，不想断就让他连着）"></a>安全问题（想断就断，不想断就让他连着）</h4><h4 id="收敛问题"><a href="#收敛问题" class="headerlink" title="收敛问题"></a>收敛问题</h4><p>很可能收敛不了</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层是端到端的</p><p>存在的意义：比如 NJU x 楼 x 宿舍 -&gt; PKU y 楼 y 宿舍，网络层就编址到这里，NJUer 对 PKUer 发文件、发 QQ 经过不同的端口？<br>NJUer 需要复用物理地址，PKUer 需要解复用</p><p>IP 层保证全球可达（但不是一定到达），包会 崩溃、延迟、丢包、乱序、重复包（电子设备出错、对抗前面的问题）<br>传输层需要提供手段解决上述问题（这些问题不交由网络层解决的原因是：不是所有业务都需要稳得一批，低价看视频就不用）</p><p>传输层要告诉 网络层 传多块（速度），比如传输层知道某个路由器拥堵了，那就发慢点让它能处理</p><h2 id="Ports"><a href="#Ports" class="headerlink" title="Ports"></a>Ports</h2><p>区分是哪个应用在发包</p><p>端口号自动分配，NJU 某机子一个端口，PKU 某机子一个端口，返回 1024~65536 ?</p><p>UDP 与 TCP 区别：<br>UDP</p><ul><li>不保证传达到</li><li>不面向连接，丢出去就完事了，野蛮人的交流方式</li></ul><p>TCP</p><ul><li>保证送达，发不到的会重发等等</li><li>面向连接，要握手，文明人的交流方式</li></ul><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>一直没怎么更新过，简陋但简单</p><p>包头就</p><ul><li>src port（这都可以不给，意思就是不需要你回复我）（每个主机一个 16 bit 的 port号）</li><li>dst port</li><li>length</li><li>checksum（可以置为0，意思就是别检查我了，对不对和你没关系）</li></ul><h3 id="TCP-简介"><a href="#TCP-简介" class="headerlink" title="TCP 简介"></a>TCP 简介</h3><p>精致，啥都干了</p><h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><p>一系列对抗机制 Mechanisms，来处理 bad events</p><ul><li>checksum</li><li>ACK（没收到）</li><li>NACK（没收到</li><li>Sequence number</li><li>Retransmission</li><li>timeout</li><li>forward error correction</li></ul><h4 id="检错、纠错"><a href="#检错、纠错" class="headerlink" title="检错、纠错"></a>检错、纠错</h4><p>checksum</p><h4 id="告诉发送端发生了啥"><a href="#告诉发送端发生了啥" class="headerlink" title="告诉发送端发生了啥"></a>告诉发送端发生了啥</h4><p>ACK/NACK</p><p>PPT 图</p><p>如果 ACK/NACK 包出错，那么也再发一遍 ACK/NACK（对于发送端来说，它只感受到刚发的没发好）</p><p>如果 A-&gt;B P1(yes), B-&gt;A ACK(no), A 重发 B P1，如果不编号，那么 B 不知道收到的是第几个包<br>所以要用 sequence number</p><h4 id="处理丢包"><a href="#处理丢包" class="headerlink" title="处理丢包"></a>处理丢包</h4><p>PPT 图</p><p>用 Timeout，如果过了时间没收到回复，那就重新发</p><p>会有伪丢包现象，只是传的慢了，确实可达了，但 timeout 超了</p><h4 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h4><h5 id="stop-and-wait"><a href="#stop-and-wait" class="headerlink" title="stop and wait"></a>stop and wait</h5><p>@sender</p><ol><li>send, then wait</li><li>if(ack) i++; repeat;</li><li>if(nack/timeout) repeat;</li></ol><p>弊端：不高效，因为 send 1 个 data 时间少，等待时间 RTT 太长！</p><p>效率 = data/RTT</p><p>在广域网情况下，带宽利用率会很低！<br>但如果很短的线直连，利用率还是挺高的</p><h5 id="sliding-window"><a href="#sliding-window" class="headerlink" title="sliding window"></a>sliding window</h5><p>PPT 图</p><p>窗里 记录应当在传输，而还未确认的那些包</p><p>一次发一批，发送端和接收端维护相同长度的滑动窗</p><p>效率 = min{n*data/RTT, link bandwidth}</p><p>n 太大的情况下（一次传的超过带宽），包会堆积，然后丢包</p><p>接收端收到了一个包就滑动一格，然后顺便发出 ack，然后发送端收到 ack 后也滑动一格。</p><h6 id="如何确认"><a href="#如何确认" class="headerlink" title="如何确认"></a>如何确认</h6><ol><li>cumulative ack</li></ol><p>每次收到连续的 包 时更新 ack 的编号，再发</p><p>如果中间有一个没收到，那么后面的包都不发 ack 了</p><ol><li>selective ack</li></ol><p>每次收到都更新 ack 编号，发（导致 ack 数量很多，这是消耗）</p><p>这样可以直接定位丢了哪个</p><h6 id="如何重传"><a href="#如何重传" class="headerlink" title="如何重传"></a>如何重传</h6><ol><li>Go-back-N（逻辑简单，多用硬件实现，超级计算机常用）</li></ol><p>发送端按序发送（12345），接收端按序接受（12 45），其中 3 在路上丢了，则接收端没收到 3，就把 45 都丢了，然后无作为，发送端的 timeout 到了没收到 3 的 ack，察觉到 3 丢了，则发送端把 345.. 都重传</p><p>要求错误率极低，这样效率才不会很差（1% 的错误率就 gg 了）</p><ol><li>selective repeat</li></ol><p>发送端按序发送（12345），接收端按序接受（12 45），其中 3 在路上丢了，则接收端没收到 3，就把 45 都 buffer 存住先不提交给应用层，回 45 的 ack，接收端的 timeout 到了没收到 3 的 ack，察觉到 3 丢了，重传 3，接收端收到 3 之后再将 3 和 buffered 45 拼起来，再提交给应用层。</p><p>适用广域网（TCP 用的就是这个）</p><h3 id="TCP-详细"><a href="#TCP-详细" class="headerlink" title="TCP 详细"></a>TCP 详细</h3><h4 id="TCP-头部"><a href="#TCP-头部" class="headerlink" title="TCP 头部"></a>TCP 头部</h4><p>PPT 图</p><p>（checksum 算的时候先把 checksum 设定一个初始值，再算完 checksum 写回去。）</p><p>头里的 sequence number 不是包的编号，是 byte offset，做字节定位用的</p><h4 id="TCP-段"><a href="#TCP-段" class="headerlink" title="TCP 段"></a>TCP 段</h4><p>基于字节流，但不是一字节一字节发，也不是一个大东西发，而是分成段再发</p><p>分段条件；</p><ol><li>比如传一个大文件，一个段装不下，那么分成段</li><li>段没满但时间到了，也发的情况，比如敲命令</li></ol><p>段的大小：</p><ul><li>不超过最大传输单元大小 (缩写 MTU)（以太网 1500 byte）</li><li>IP 包头不带选项是 20 字节，TCP 包头 20 字节，那么最大不超过 1460</li></ul><h4 id="TCP-sequence-number、acknowledgement"><a href="#TCP-sequence-number、acknowledgement" class="headerlink" title="TCP sequence number、acknowledgement"></a>TCP sequence number、acknowledgement</h4><p>seqno 是我正在发送的数据位于数据流的哪个位置</p><p>sender: seqno = X, length = B<br>recv: ack = X + B</p><p>sender: seqno = X + B, length = B<br>recv: ack = X + 2B</p><p>…</p><h4 id="如果丢包了"><a href="#如果丢包了" class="headerlink" title="如果丢包了"></a>如果丢包了</h4><p>比如一个包 100B，期望 seqno 如下<br>100, 200, 300, 400, 500, 600</p><p>假如第五个丢了，即第 500~599 字节丢了，ack 为 200,300,400,500(seqno 600),500(seqno 700)…</p><p>快速重传：不用等 timeout 耗尽，改为：看PPT，我课上没听到</p><h4 id="timeout-怎么设定"><a href="#timeout-怎么设定" class="headerlink" title="timeout 怎么设定"></a>timeout 怎么设定</h4><p>采样得到 sampleRTT</p><p>estimateRTT = (1-a) <em> old_estimateRTT + a </em> sampleRTT</p><h3 id="TCP-建立过程"><a href="#TCP-建立过程" class="headerlink" title="TCP 建立过程"></a>TCP 建立过程</h3><p>进行三次握手</p><p>ISN 不是从 0 开始编号的</p><p><em>*</em> 2019-5-20 断线重连</p><h2 id="TCP-缺陷"><a href="#TCP-缺陷" class="headerlink" title="TCP 缺陷"></a>TCP 缺陷</h2><ol><li><p>misled by non-congetion losses</p></li><li><p>fills up queues leading to high delays</p></li><li><p>short flows comlete before discovering availale capacity</p></li><li><p>AIMD impractical for high speed links</p></li><li><p>saw tooth discovery too choppy for some apps</p></li><li><p>unfair under heterogeneous RTTs</p></li><li><p>tight couplin with reliablity mechanisms</p></li><li><p>end host can cheat</p></li></ol><h3 id="7-cheating"><a href="#7-cheating" class="headerlink" title="7 cheating"></a>7 cheating</h3><h3 id="8-Implications"><a href="#8-Implications" class="headerlink" title="8 Implications"></a>8 Implications</h3><p>P2P 传输早期被禁止，开多个 tcp 连接，带宽占满</p><h2 id="TCP-缺陷解决"><a href="#TCP-缺陷解决" class="headerlink" title="TCP 缺陷解决"></a>TCP 缺陷解决</h2><h3 id="借助路由器"><a href="#借助路由器" class="headerlink" title="借助路由器"></a>借助路由器</h3><ol><li>发现拥塞</li><li>调整达到公平</li></ol><h4 id="公平针对欺骗"><a href="#公平针对欺骗" class="headerlink" title="公平针对欺骗"></a>公平针对欺骗</h4><p>数据包都塞入流中，轮转</p><h4 id="ECN"><a href="#ECN" class="headerlink" title="ECN"></a>ECN</h4><p>多用于数据中心</p><h4 id="终极解决，给钱"><a href="#终极解决，给钱" class="headerlink" title="终极解决，给钱"></a>终极解决，给钱</h4><h4 id="大企业解决办法"><a href="#大企业解决办法" class="headerlink" title="大企业解决办法"></a>大企业解决办法</h4><p>自己接管拥塞控制，方法是 UDP+应用层 Quic，这样快速</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>翘课</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>翘课</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>最早出现在欧洲核子中心</p><p>HTTP/1.1 明文表示，便于调试，消耗空间</p><p>HTTP/2 二进制表示，省空间</p><h3 id="Web-组成部分"><a href="#Web-组成部分" class="headerlink" title="Web 组成部分"></a>Web 组成部分</h3><p>客户端-用户</p><p>URL 全球资源标识</p><p>资源格式 HTML</p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>protocol://host-name[:port]/directory-path/resource</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>GET, HEAD</p><p>POST, PUT, DELETE</p><h4 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h4><p>为无状态的 HTTP 加上状态，这个状态不放在服务器端，放在客户端 </p><h1 id="复习课"><a href="#复习课" class="headerlink" title="复习课"></a>复习课</h1><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>TTL 防止包永生</p><p>traceroute 对动态路由不管用，即每次 traceroute 的结果可能不一样，因为中间路由器可能会针对负载改走别的路</p><h2 id="ip协议类型"><a href="#ip协议类型" class="headerlink" title="ip协议类型"></a>ip协议类型</h2><p>1 ip</p><p>6 tcp</p><p>7 udp</p><h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><h2 id="包交换-电路交换"><a href="#包交换-电路交换" class="headerlink" title="包交换-电路交换"></a>包交换-电路交换</h2><h2 id="统计复用"><a href="#统计复用" class="headerlink" title="统计复用"></a>统计复用</h2><h2 id="如何刻画一条链路的特征"><a href="#如何刻画一条链路的特征" class="headerlink" title="如何刻画一条链路的特征"></a>如何刻画一条链路的特征</h2><p>带宽，点到点</p><h2 id="OSI-模型和-TCP-IP-模型"><a href="#OSI-模型和-TCP-IP-模型" class="headerlink" title="OSI 模型和 TCP-IP 模型"></a>OSI 模型和 TCP-IP 模型</h2><p>OSI 七层，TCP-IP 五层</p><p>考一个设备是第几层的</p><h2 id="时延由那几个部分组成"><a href="#时延由那几个部分组成" class="headerlink" title="时延由那几个部分组成"></a>时延由那几个部分组成</h2><h2 id="包是怎么封装-解封的"><a href="#包是怎么封装-解封的" class="headerlink" title="包是怎么封装/解封的"></a>包是怎么封装/解封的</h2><p>给定链路层 MTU，给头部大小，问应用层数据该有多大</p><p>中间路由器会不会分片</p><h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="TDMA-FDMA-CDMA"><a href="#TDMA-FDMA-CDMA" class="headerlink" title="TDMA/FDMA/CDMA"></a>TDMA/FDMA/CDMA</h2><h2 id="Aloha-Slotted-Aloha-什么时候用哪个"><a href="#Aloha-Slotted-Aloha-什么时候用哪个" class="headerlink" title="Aloha/Slotted-Aloha 什么时候用哪个"></a>Aloha/Slotted-Aloha 什么时候用哪个</h2><p>发数据的成功概率</p><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>CSMA/CD 是怎么做的，重点看</p><h2 id="Wireless"><a href="#Wireless" class="headerlink" title="Wireless"></a>Wireless</h2><p>CSMA/CA or <em>Distributed Coordination&lt;-这个没讲过，自己看一下</em></p><p>问为什么不直接用 CD 而要用 CA</p><p>特征<br>Hidden terminal</p><p>Multi-path</p><p>信号衰减</p><p>有线网无线网区别</p><h2 id="交换机和网桥有什么区别"><a href="#交换机和网桥有什么区别" class="headerlink" title="交换机和网桥有什么区别"></a>交换机和网桥有什么区别</h2><p>地址的 self learning（交换机）</p><p>spanning tree（交换机）防止环路</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP-header"><a href="#IP-header" class="headerlink" title="IP header"></a>IP header</h2><h2 id="link-state-算法-distance-vector-算法，区别，代表性算法"><a href="#link-state-算法-distance-vector-算法，区别，代表性算法" class="headerlink" title="link-state 算法 distance vector 算法，区别，代表性算法"></a>link-state 算法 distance vector 算法，区别，代表性算法</h2><p>dijkstra and bf</p><h2 id="域间，域内-routing"><a href="#域间，域内-routing" class="headerlink" title="域间，域内 routing"></a>域间，域内 routing</h2><p>RIP/OSPF/BGP，用的什么算法</p><p>哪些是用于域间，哪些域内</p><h2 id="subnet，netmask，gateway"><a href="#subnet，netmask，gateway" class="headerlink" title="subnet，netmask，gateway"></a>subnet，netmask，gateway</h2><p>是什么，为什么gateway</p><p>如果没配置会有什么后果</p><h2 id="CIDR-是什么"><a href="#CIDR-是什么" class="headerlink" title="CIDR 是什么"></a>CIDR 是什么</h2><h2 id="ARP-是干什么的"><a href="#ARP-是干什么的" class="headerlink" title="ARP 是干什么的"></a>ARP 是干什么的</h2><p>谁是 1.1.1.1？告诉我它的 mac</p><h2 id="DHCP-是干什么的"><a href="#DHCP-是干什么的" class="headerlink" title="DHCP 是干什么的"></a>DHCP 是干什么的</h2><h1 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h1><h2 id="UDP-和-TCP-区别"><a href="#UDP-和-TCP-区别" class="headerlink" title="UDP 和 TCP 区别"></a>UDP 和 TCP 区别</h2><h2 id="UDP-TCP-header里有什么"><a href="#UDP-TCP-header里有什么" class="headerlink" title="UDP TCP header里有什么"></a>UDP TCP header里有什么</h2><h2 id="TCP-三次握手，分手"><a href="#TCP-三次握手，分手" class="headerlink" title="TCP 三次握手，分手"></a>TCP 三次握手，分手</h2><p>为什么要三次握手</p><p>分手有几种，友好的，不友好的</p><h2 id="TCP-的细节，可靠性和流控"><a href="#TCP-的细节，可靠性和流控" class="headerlink" title="TCP 的细节，可靠性和流控"></a>TCP 的细节，可靠性和流控</h2><p>流控和拥塞控制的区别</p><h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>sliding window</p><p>AIMD</p><p>RTT</p><h2 id="ICMP-1"><a href="#ICMP-1" class="headerlink" title="ICMP"></a>ICMP</h2><p>有什么黑科技功能</p><h2 id="NAT-1"><a href="#NAT-1" class="headerlink" title="NAT"></a>NAT</h2><p>有两种类别，运行于不同层？</p><p>静态绑定动态绑定</p><p>一个子网怎么划分？网关怎么配？dns怎么设，防火墙怎么设，要不要设NAT</p><h1 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h1><h2 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP"></a>HTTP</h2><p>有多少种，取数据的方式有什么不同 1.0 2.0，中间建立几个连接</p><h2 id="DNS-1"><a href="#DNS-1" class="headerlink" title="DNS"></a>DNS</h2><p>是主机在发 query 还是别的实体在发 query</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h2><h2 id="公私密钥"><a href="#公私密钥" class="headerlink" title="公私密钥"></a>公私密钥</h2><p>RSA 实例</p><h2 id="信任第三方-CA"><a href="#信任第三方-CA" class="headerlink" title="信任第三方 CA"></a>信任第三方 CA</h2><p>为什么需要可信第三方</p><h2 id="DH-key-exchange"><a href="#DH-key-exchange" class="headerlink" title="DH key exchange"></a>DH key exchange</h2><p>不需要第三方，为什么也能安全交换</p><h2 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h2><p>什么时候用，有几种协议模式，有几种运行模式</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>什么时候用</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记</title>
      <link href="/2019/02/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇供日后复习，跳跃性很大，随性更新。</p><p>参考书目：《算法设计与分析》 黄宇 机械工业出版社</p><h1 id="第2章-从算法的角度重新审视数学的概念"><a href="#第2章-从算法的角度重新审视数学的概念" class="headerlink" title="第2章 从算法的角度重新审视数学的概念"></a>第2章 从算法的角度重新审视数学的概念</h1><h3 id="2-1-3-阶乘n"><a href="#2-1-3-阶乘n" class="headerlink" title="2.1.3 阶乘n!"></a>2.1.3 阶乘n!</h3><p>根据<code>Stirling公式</code>，可以将<code>n!</code>转化为更易于处理的闭形式，对<code>n&gt;=1</code>，有：</p><script type="math/tex; mode=display">\sqrt{2\pi n}(\frac{n}{e})^n < n! < \sqrt{2\pi n}(\frac{n}{e})^n(1+\frac{1}{11n})</script><p><code>Stirling公式</code>也可以写成：</p><script type="math/tex; mode=display">n! = \sqrt{2\pi n}(\frac{n}{e})^n e^{\varepsilon(n)},其中\frac{1}{12n+1} \leq \varepsilon(n) \leq \frac{1}{12n}</script><p>写成近似形式：</p><script type="math/tex; mode=display">n! = \sqrt{2\pi n}(\frac{n}{e})^n(1+\Theta(\frac{1}{n}))</script><p>由于 $\Theta(\frac{1}{n})$ 是无穷小量，$\lim\limits_{n \to \infty} \frac{1}{n}=0$ ，忽略。所以得到进一步的近似式：</p><script type="math/tex; mode=display">n! \approx \sqrt{2\pi n}(\frac{n}{e})^n</script><h3 id="2-1-4-常见级数求和-sum-limits-i-1-n-f-i"><a href="#2-1-4-常见级数求和-sum-limits-i-1-n-f-i" class="headerlink" title="2.1.4 常见级数求和 $\sum\limits_{i=1}^{n}f(i)$"></a>2.1.4 常见级数求和 $\sum\limits_{i=1}^{n}f(i)$</h3><ul><li>多项式级数(polynomial series)<br>  $ \sum\limits_{i=1}^{n}i = \dfrac{n(n+1)}{2} $<br>  .<br>  $ \sum\limits_{i=1}^{n}i^2 = \dfrac{1}{3}n(n+\dfrac{1}{2})(n+1) $<br>  .<br>  $ \sum\limits_{i=1}^{n}i^k = \Theta(\dfrac{1}{k+1}n^{k+1}) $<br>  .</li><li>几何级数(geometric series)<br>  $ \sum\limits_{i=0}^{k}ar^i = a(\dfrac{r^{k+1}-1}{r-1}) $</li></ul><p>测试用<br>$\begin{eqnarray}f(x,y)<br>    &amp;=&amp;2xy+(x-y)^2\\<br>    &amp;=&amp;x^2+y^2<br>\end{eqnarray}$</p><h1 id="第0章-概论"><a href="#第0章-概论" class="headerlink" title="第0章 概论"></a>第0章 概论</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>Q1: 在数组中找最大元素和最小元素</p><p>A1: 最优：n为偶数时，将数组切分为($a_0$,$a_1$)($a_2$,$a_3$)…($a_{n-2}$, $a_{n-1}$)，组内比较后分出胜者组和败者组，胜者组遍历一遍得到最大元素，败者组遍历一遍得到最小元素。n为奇数时先抛开最后一个元素，最后额外比较一下。</p><hr><p>Q2: 比较3匹马的预测性</p><p>A2: 将马的过去两百场比赛进行huffman编码，所用字符最少的马预测性越强，原理是信息熵。</p><hr><p>Q3: 停机问题</p><p>A3: 不可判定，假设有程序terminate(p:program, x:input)能判断对于程序p，给一个输入x，p是否会终止（即判定p(x)是否终止），那么定义程序paradox(z:file)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paradox(z:file):</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">if</span>(terminate(z, z)) <span class="keyword">goto</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>paradox(z)的执行结果为</p><script type="math/tex; mode=display">\left\{\begin{array}{aligned}z(z)不终止   &&  {paradox(z)终止}\\z(z)终止     &&  {paradox(z)不终止}\\\end{array} \right.</script><p>此时，paradox(paradox)便成为矛盾体</p><script type="math/tex; mode=display">\left\{\begin{array}{aligned}paradox(paradox)不终止 &&   {paradox(paradox)终止}\\paradox(paradox)终止   &&   paradox(paradox)不终止\end{array} \right.</script><h2 id="课程任务："><a href="#课程任务：" class="headerlink" title="课程任务："></a>课程任务：</h2><p>书面作业15%（8次，准备2个作业本）<br>编程15%（6-8次，每次2-4题，时间2-3周）<br>期中20%<br>期末50%</p><h1 id="第1章-概论"><a href="#第1章-概论" class="headerlink" title="第1章 概论"></a>第1章 概论</h1><p>《proof without words》中的有趣证明？</p><p>double counting 思想用于证明</p><h2 id="平均复杂度"><a href="#平均复杂度" class="headerlink" title="平均复杂度"></a>平均复杂度</h2><p>$ \sum\limits_{i=1}^{n}Pr(i)I(i) $</p><h2 id="算法的最优性"><a href="#算法的最优性" class="headerlink" title="算法的最优性"></a>算法的最优性</h2><p>如果一个算法的最坏情况等于问题的下界，那么这个算法是最优的。</p><h1 id="第2讲-渐进时间复杂度"><a href="#第2讲-渐进时间复杂度" class="headerlink" title="第2讲 渐进时间复杂度"></a>第2讲 渐进时间复杂度</h1><p>$ log_{n}, n^\alpha, c^n, n!, n^n $</p><script type="math/tex; mode=display">\lim\limits_{n\to \infty}\frac{f(n)}{g(n)}=c,\left\{\begin{array}{aligned}c=0 &&  f=o(g)\\0 \leq c < \infty   && f=O(g)\\0 < c < \infty      && f=\Theta(g)\\0 < c \leq \infty   && f=\Omega(g)\\c = \infty          && f=\omega(g)\end{array} \right.</script><p>不是所有俩函数之间都有上述五种关系，比如$ f(n)=n, g(n)=n^{1+sin n}$，极限不存在。</p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树的高度p是问题的lower bound，基于比较的决策树节点数为n，有$ n \leq 2^{p-1} $，所以$ p &gt;= lgn $，所以查找问题的lower bound为$lgn$，二分查找是最优算法。</p><p>无关思考题：圆的内接八边形，边长4个2，4个3，求八边形面积。<br>放到正方形里去，减去四个角的等腰直角三角形</p><script type="math/tex; mode=display">f(n) =\begin{cases}n/2,  & \text{if $n$ is even}\\3n+1, & \text{if $n$ is odd}\end{cases}</script><h1 id="第3讲-递归"><a href="#第3讲-递归" class="headerlink" title="第3讲 递归"></a>第3讲 递归</h1><p>时间复杂度计算</p><h3 id="齐次线性"><a href="#齐次线性" class="headerlink" title="齐次线性"></a>齐次线性</h3><p>$ a_n = r_1a_{n-1} + r_2a_{n-2} + … + r_ma_{n-k} $</p><p>特例<br>$ 形如T(n)=r_1T(n-1)+r_2T(n-2),有特征方程x^2 = r_1x + r_2x $<br>$ 则T(n) = ux_1^n + vx_2^n. $</p><p>证明：<br>$ B.C: T(1), T(2) $</p><p>$ I.H: 1 \leq m &lt; n, T(m) = ux_1^m + vx_2^m $</p><p>$\begin{eqnarray}T(n)<br>    &amp;=&amp; ux_1^n+vx_2^n\\<br>    &amp;=&amp; ux_1^{n-2}x_1^2+vx_2^{n-2}x_2^2\\<br>    &amp;=&amp; ux_1^{n-2}(r_1x_1+r_2)+vx_2^{n-2}(r_1x_2+r_2)\\<br>    &amp;=&amp; r_1(ux_1^{n-1}+vx_1^{n-2})+r_2(ux_1^{n-2}+vx2^{n-2})\\<br>    &amp;=&amp; r_1T(n-1)+r_2T(n-2)<br>\end{eqnarray}$</p><p>代价 = 递归代价 + 非递归代价</p><p>$ T(n) = bT(\frac{n}{c})+f(n) $</p><p>after $k$ th expansion</p><p>$ T(n) = b^kT(\frac{n}{c^k})+\sum\limits_{i=1}^{k}f(\frac{n}{c^{i-1}}) $</p><p>意味着递归树高度$\log_c n$</p><script type="math/tex; mode=display">\sum\limits_{i=0}^{n-1}=\begin{cases}n/2, \text{xxx} \\ss\end{cases}</script><h2 id="最大子序列之和"><a href="#最大子序列之和" class="headerlink" title="最大子序列之和"></a>最大子序列之和</h2><ol><li>暴力枚举<br> 算法：取所有sequence[i, j]，比较。<br> 时间复杂度：$O(n^3)$</li><li>减少重复计算</li><li>二分，最长要么在左，要么在右，要么有左有右</li><li><p>假设A[0, n]中最大和为M[0, n]，那么A[0, n+1]中最大和为$\max\{M[0,n], \sum\limits_{i=0}^{n}A_i, \sum\limits_{i=1}^{n}A_i, …,\sum\limits_{i=n-1}^{n}, A_n\}$</p><p> 当前和一直加，保持增长，如果小于0，就丢弃前面的（即丢弃当前和）</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ThisSum = MaxSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">    ThisSum += A[j];</span><br><span class="line">    <span class="keyword">if</span>(ThisSum &gt; MaxSum) &#123;</span><br><span class="line">        MaxSum = ThisSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ThisSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ThisSum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="一个盘子可以被n个直线最多分为多少块"><a href="#一个盘子可以被n个直线最多分为多少块" class="headerlink" title="一个盘子可以被n个直线最多分为多少块"></a>一个盘子可以被n个直线最多分为多少块</h2><p>L(0) = 1<br>L(n) = L(n-1) + n</p><h2 id="合法字符串"><a href="#合法字符串" class="headerlink" title="合法字符串"></a>合法字符串</h2><p>字符串只有abc三种字符，aa不允许出现，长度为n的合法字符串有多少个</p><p>f(1) = 3<br>f(2) = 8<br>str(n)  : ab+str(n-2)<br>        : ac+str(n-2)<br>        : b+str(n-1)<br>        : c+str(n-1)<br>f(n) = 2f(n-1)+2f(n-2)</p><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>strassen’s alogorithm runs in $O(n^{2.81})$</p><p>f(n) = 7f(n/2) + $\Theta(n^2)$</p><h1 id="第4讲-quick-sort"><a href="#第4讲-quick-sort" class="headerlink" title="第4讲 quick sort"></a>第4讲 quick sort</h1><p>易合难分</p><p>partition的方法不同<br>最坏复杂度分析<br>平均复杂度分析</p><h1 id="第5讲-merge-sort"><a href="#第5讲-merge-sort" class="headerlink" title="第5讲 merge sort"></a>第5讲 merge sort</h1><p>易分难合</p><h1 id="第6讲-heap-sort"><a href="#第6讲-heap-sort" class="headerlink" title="第6讲 heap sort"></a>第6讲 heap sort</h1><h2 id="common-version"><a href="#common-version" class="headerlink" title="common version"></a>common version</h2><h2 id="accelerated-heap-sort"><a href="#accelerated-heap-sort" class="headerlink" title="accelerated heap sort"></a>accelerated heap sort</h2><h1 id="第7讲-选择"><a href="#第7讲-选择" class="headerlink" title="第7讲 选择"></a>第7讲 选择</h1><h2 id="找最大最小元素"><a href="#找最大最小元素" class="headerlink" title="找最大最小元素"></a>找最大最小元素</h2><h2 id="找第2大元素"><a href="#找第2大元素" class="headerlink" title="找第2大元素"></a>找第2大元素</h2><h2 id="找第k大-小元素"><a href="#找第k大-小元素" class="headerlink" title="找第k大/小元素"></a>找第k大/小元素</h2><h2 id="找中位数"><a href="#找中位数" class="headerlink" title="找中位数"></a>找中位数</h2><p>算法1：</p><ol><li>寻找 pivot，将数组分两半，在基数比较大的一半里找第 n/2 - |S小| - 1 小的元素<br>最坏情况：<br>类似快排，pivot选不好</li></ol><p>6次比较找出5个元素中的中位数：</p><p>算法2：</p><h1 id="第8讲-adversary-amp-BST"><a href="#第8讲-adversary-amp-BST" class="headerlink" title="第8讲 adversary &amp; BST"></a>第8讲 adversary &amp; BST</h1><h2 id="判断5个元素中是否有3个连续的1"><a href="#判断5个元素中是否有3个连续的1" class="headerlink" title="判断5个元素中是否有3个连续的1"></a>判断5个元素中是否有3个连续的1</h2><p>3次之内不够<br>对手策略：定义 x: 1 1 1 1 1, y: 0 0 0 0 0，我想看第i位的值，就先去 x 里看，如果把 xi 变成0还能保证有3个连续1，那么把 xi 变成0，否则把 yi 变成1.</p><p>4次：</p><h2 id="判断图的连通性"><a href="#判断图的连通性" class="headerlink" title="判断图的连通性"></a>判断图的连通性</h2><p>必须看$\frac{n(n-1)}{2}$次，否则<br>对手策略：</p><p>性质的单调性：图有这个性质，它的子图也有这个性质</p><p>图可平面化：图在平面上可以画出边不相交，条件是不含 K3,3 和 K5 这两个子图</p><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>例如求$\sqrt{N}$<br>当 N 很大时，等于是找 x，使得 $ x^2 \leq N, (x+1)^2 &gt; N $</p><h2 id="AVL-tree"><a href="#AVL-tree" class="headerlink" title="AVL tree"></a>AVL tree</h2><h2 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB tree"></a>RB tree</h2><h2 id="搜索的-tutorial"><a href="#搜索的-tutorial" class="headerlink" title="搜索的 tutorial"></a>搜索的 tutorial</h2><h3 id="扔鸡蛋问题"><a href="#扔鸡蛋问题" class="headerlink" title="扔鸡蛋问题"></a>扔鸡蛋问题</h3><p>Q: n 层楼，从某层楼扔下去鸡蛋会碎，求这个楼层</p><ol><li>如果只有1个鸡蛋，easy</li><li>如果有无穷多个鸡蛋，二分法</li><li>如果有2个鸡蛋<br>A1: 每隔$\sqrt(n)$层扔1个鸡蛋，尝试次数为$\sqrt(n) ~ 2\sqrt(n)$<br>A2: 第1次，从x层扔（碎了，最坏比x次，没碎继续），第2次从2x-1层扔（碎了，比1+x-1次，没碎继续），。。。共 (x+1)x/2 层，令它 &gt;=n 就求得了 x</li></ol><h3 id="找名人"><a href="#找名人" class="headerlink" title="找名人"></a>找名人</h3><p>Q: n 个人，名人定义：被其他所有人认识，但不认识其他任何人，操作是拿A和B来，问A是否认识B，B是否认识A<br>O(n)算法：每次比较可以淘汰1个人</p><h3 id="赛马问题"><a href="#赛马问题" class="headerlink" title="赛马问题"></a>赛马问题</h3><p>Q: 共25匹马，每次可以选5匹马进行比赛，并得到次序（无法计时），问至少要多少次比赛才能确定跑的 最快、第二快、第三块的马</p><p>最快的：比赛6次即可<br>第二快：出现在第1快的那一组的第2名（1匹），以及所有组第一快里的那5匹里输给第1快的第2名（1匹）（只输给最大元素的元素是候选人）。<br>第三快：候选人，第1组第3快，第2组第2快，第3组第一快</p><p>共7次找出前三快的马</p><h3 id="2018-mid-term"><a href="#2018-mid-term" class="headerlink" title="2018 mid-term"></a>2018 mid-term</h3><p>Q: 有sort5算法，一次排序5个元素，求n个元素的最大值和第二大</p><p>最大值：一次sort5丢弃4个元素，所以最多比较$\frac{n-1}{4}$取上整</p><p>第二大：采用5叉胜者树，即可得出 max，和仅仅输给 max 的元素</p><h3 id="带权中位数"><a href="#带权中位数" class="headerlink" title="带权中位数"></a>带权中位数</h3><p>Q: 所有权之和为1，带权中位数$ x_k: \sum_{x_i &lt; x_k}{w_i} &lt; 1/2 且 \sum_{x_i &gt; x_k}{w_i} \leq 1/2 $<br>A: 找普通中位数，判断行不行，小不行就将小于它的权和加到它头上，然后递归后半部，大不行就同理</p><h3 id="最小未出现自然数"><a href="#最小未出现自然数" class="headerlink" title="最小未出现自然数"></a>最小未出现自然数</h3><p>n个大小不同的自然数E[1]~E[n]，找出不在这个自然数序列中出现的最小自然数</p><ol><li>若已排序，二分查找，若E[n/2]&gt;n/2，在前一半，若等于，在后一半，不可能小于..</li><li>若未排序，<br>法1：开n位数组，遍历，出现置1，然后第一个0元素下标就是<br>法2：找中位数x，按x和n/2大小丢掉一半元素</li></ol><h3 id="前k大的数们"><a href="#前k大的数们" class="headerlink" title="前k大的数们"></a>前k大的数们</h3><ol><li>排序，取后k个，nlogn</li><li>建堆+取出k个元素，n+klogn</li><li>先找第k大元素，n，再遍历找出比第k大都大的元素，n，然后排序，klogk，合计 n+klogk</li></ol><h3 id="两个已排序数组中的第k小元素-LeetCode"><a href="#两个已排序数组中的第k小元素-LeetCode" class="headerlink" title="两个已排序数组中的第k小元素 LeetCode-"></a>两个已排序数组中的第k小元素 LeetCode-</h3><ol><li>merge到第k个就行，$\Theta(k)$</li><li>找两数组中位数A[m/2], B[n/2]<br>若 m/2+n/2 &lt; k，若A[m/2] &gt; B[n/2]，说明比B[n/2]小的元素数量[n/2, m/2+n/2]，所以确定比B小的B的前半部分可以丢了<pre><code>         若       &lt; ，丢A的前半部分</code></pre></li></ol><h3 id="5个元素6次比较找中位数讲过了，7次比较排序"><a href="#5个元素6次比较找中位数讲过了，7次比较排序" class="headerlink" title="5个元素6次比较找中位数讲过了，7次比较排序"></a>5个元素6次比较找中位数讲过了，7次比较排序</h3><p>ppt</p><h3 id="k个已排序树组-merge-策略"><a href="#k个已排序树组-merge-策略" class="headerlink" title="k个已排序树组 merge 策略"></a>k个已排序树组 merge 策略</h3><p>两两merge</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>简单一致哈希假设</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h2 id="均摊时间代价"><a href="#均摊时间代价" class="headerlink" title="均摊时间代价"></a>均摊时间代价</h2><h3 id="accounting-cost"><a href="#accounting-cost" class="headerlink" title="accounting cost"></a>accounting cost</h3><p>这个真不会，[UST]</p><p>一般是对一系列操作进行分析才使用均摊分析，分析出一次操作的代价，而且这些操作是由规律的</p><p>accounting cost 之和必须大于0，这样计算出的 amortized cost 是 actual cost 的一个上界</p><h4 id="二-计数器-ppt上的"><a href="#二-计数器-ppt上的" class="headerlink" title="二-计数器 ppt上的"></a>二-计数器 ppt上的</h4><p>发现：一开始每一位都是0，<br>每一位想要从1变为0，首先得从0变为1，于是把0-&gt;1的accost 为1，1-&gt;0的ac cost为-1，这样 ac cost 始终大于0</p><h3 id="聚合法"><a href="#聚合法" class="headerlink" title="聚合法"></a>聚合法</h3><p>比如作业那个 三-计数器，个位每次变，十位每3次变，百位每9次变。。所以操作n次increment，变了n+n/3+n/3^2+…. &lt; 2n</p><p>栈的pop，multipop，可见每次操作</p><h3 id="势能法？potential-method"><a href="#势能法？potential-method" class="headerlink" title="势能法？potential method"></a>势能法？potential method</h3><h2 id="统一-hash"><a href="#统一-hash" class="headerlink" title="统一 hash"></a>统一 hash</h2><p>解决类似快排 partition 没选好的问题，快排随机选 pivot</p><h1 id="期中考试讲解"><a href="#期中考试讲解" class="headerlink" title="期中考试讲解"></a>期中考试讲解</h1><ol><li><p>根节点到最深节点的路径长度就是基于比较的排序的最坏情况</p></li><li><p>(2) 逆序对的情况只能是 (i,i+1) (j, j+1)  或 (i, i+2) (i, i+1) 或 (i, i+2) (i+1,i+2) </p></li><li><p>(2) 看 tutorial，找中位数，如果满足直接返回，不满足就把某一半边的权重加到中位数上，然后继续递归另一半边</p></li><li><p>其实链表就可以了？删除时的代价n在插入时每次 accounting cost 预付掉，然后就是常数级别的了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记</title>
      <link href="/2019/02/05/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/05/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title="?"></a>?</h1><h2 id="while中的let问题"><a href="#while中的let问题" class="headerlink" title="while中的let问题"></a>while中的let问题</h2><p>这是一段简单的遍历数组代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> array: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, array[index]);</span><br><span class="line"></span><br><span class="line">    index = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果显然</p><p><img src="/2019/02/05/Rust学习笔记/正常遍历结果.png" alt="正常遍历结果"></p><p>但如果略作修改，即index的mut关键字去掉，在迭代时用let index 隐藏原来的index<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> array: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, array[index]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> index = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果就是无限输出10。</p><hr><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安装参考网站</title>
      <link href="/2019/02/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/"/>
      <url>/2019/02/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文包含一些软件的优秀安装指南，都是亲测可用的。以备以后重新安装系统快速使用，本文会热更新。</p><p>每段的格式为：</p><ul><li><p>[已有教程网址]</p></li><li><p>[排除教程中的坑]</p></li><li><p>[对教程中的简要概括(防止教程404)]</p></li></ul><hr><h1 id="蓝灯lantern"><a href="#蓝灯lantern" class="headerlink" title="蓝灯lantern"></a>蓝灯lantern</h1><ul><li><p>教程：<a href="http://www.pianshen.com/article/5553973/" target="_blank" rel="noopener">lantern傻瓜式安装教程</a></p></li><li><p>排坑：进入 <a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">https://github.com/getlantern/lantern</a> 最下面。如果左击 <strong>ubuntu 14.04 64 bit</strong> 后没有直接下载：右击 <strong>ubuntu 14.04 64 bit</strong> 用迅雷下载链接。</p></li></ul><hr><h1 id="sublime-text-3"><a href="#sublime-text-3" class="headerlink" title="sublime text 3"></a>sublime text 3</h1><ul><li><p>教程：<a href="https://jingyan.baidu.com/article/64d05a023cd849de55f73be4.html" target="_blank" rel="noopener">命令行安装sublime text 3</a></p></li><li><p>概括：三条命令即可</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/sublime-text-3</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sublime-text-installer</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust环境安装+换中科大源</title>
      <link href="/2019/02/03/Rust%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2019/02/03/Rust%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>vct说Rust环境配置很复杂，小李哥不信邪地来打算试一试。</p><p>操作系统：Ubuntu 16.04</p><h1 id="1-安装curl"><a href="#1-安装curl" class="headerlink" title="1-安装curl"></a>1-安装curl</h1><blockquote><p>$ apt install curl</p></blockquote><h1 id="2-安装rustup"><a href="#2-安装rustup" class="headerlink" title="2-安装rustup"></a>2-安装rustup</h1><blockquote><p>$ curl <a href="https://sh.rustup.rs" target="_blank" rel="noopener">https://sh.rustup.rs</a> -sSf | sh</p></blockquote><p>这个命令会帮你装好rustc, cargo等一系列后面要用到的东西，可以说是一键安装了。</p><p>中途会遇到这个3个选项，需要选一个，手动输入1，回车。</p><p><img src="/2019/02/03/Rust环境安装/rustup安装选项.png" alt="rustup安装选项"></p><p>安装成功后提示</p><p><img src="/2019/02/03/Rust环境安装/rustup安装成功.png" alt="rustup安装成功"></p><p>然后<strong>重启系统</strong>，重启会使得<strong>rust被添加到PATH中</strong>。这一步很重要。</p><p>重启后，查看是否成功。</p><blockquote><p>$ rustc —version</p></blockquote><p><img src="/2019/02/03/Rust环境安装/rustc版本.png" alt="rustc版本"></p><h1 id="3-Hello-world"><a href="#3-Hello-world" class="headerlink" title="3-Hello, world!"></a>3-Hello, world!</h1><p>Rust源文件以.rs结尾，文件中的单词以下划线分割，编写hello_world.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译+运行</p><blockquote><p>$ rustc hello_world.rs -o hello_world</p><p>$ ./hello_world</p></blockquote><p>如果显示如下，那便成功了。</p><p><img src="/2019/02/03/Rust环境安装/Hello_world.png" alt="Hello_world"></p><h1 id="4-换中科大的源"><a href="#4-换中科大的源" class="headerlink" title="4-换中科大的源"></a>4-换中科大的源</h1><p>按照上面完成后，rustc和cargo都应该自动装好了。但问题在于，速度不够快。使用cargo管理项目的时候，会涉及更新问题，但rust是被墙挡在外面的，更新速度慢是小事，可是卡的根本更新不了，就是大事了。</p><p>所以我们需要，换 <strong>中科大的源</strong> 。</p><p>操作如下：</p><ul><li>在完成上面的步骤的基础上</li><li>进入<strong>root</strong>目录，如果有 <strong>.cargo</strong> 目录就进入(应该是一个隐藏目录，用 <code>ls -a</code> 查看)，没有就新建一个 <strong>.cargo</strong> 目录，然后进入</li><li>进入 <strong>.cargo</strong> 目录后，如果有 <strong>config</strong> 文件就打开，没有就新建 <strong>config</strong> 文件</li><li><p>在 <strong>config</strong> 文件中写入如下内容，保存退出</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class="line">replace-with = &apos;ustc&apos;</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;git://mirrors.ustc.edu.cn/crate.io-index&quot;</span><br></pre></td></tr></table></figure></li><li><p>然后重启一下系统就行了，以后更新就不用翻墙啦。</p></li></ul><h1 id="5-疑难杂症"><a href="#5-疑难杂症" class="headerlink" title="5-疑难杂症"></a>5-疑难杂症</h1><p>小李哥遇到一个奇怪的问题，就是2-安装rustup完成后，重启，查看version后发现是ok的。结果装了个vim，敲完hello_world.rs，编译的时候它提示：找不到rustc！我再查看version的时候发现我的rustc没了？！</p><p>很玄学……我重启了一下系统就好了，原因未知。</p><p>emmm……查看cargo的version时再次遇到找不到cargo！rustc也找不到了！和上次的共同之处在于：我试图关闭终端的时候提示还有进程在运行，然后我直接关掉终端，再次打开终端，cargo和rustc再次出现！</p><p>真奇怪啊……</p><p>见鬼图↓，估计和环境变量有关系，应该是我自己的问题……</p><p><img src="/2019/02/03/Rust环境安装/su后找不到rustc.png" alt="su后找不到rustc"></p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 环境安装 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS2019_winter</title>
      <link href="/2019/01/31/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/31/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经一年半的学习，发现计科本科生课程中与计算机原理相关的课程多是隔靴搔痒，用到时再查书/百度也不迟，故接下来的课程中将关注点放在各章的开头1~2节，若有兴趣再继续深入。</p><p>参考书目：《操作系统教程（第5版）》费翔林</p><hr><h1 id="第一章-操作系统概论"><a href="#第一章-操作系统概论" class="headerlink" title="第一章 操作系统概论"></a>第一章 操作系统概论</h1><p><strong>PPT内容主要讲述以下问题：</strong></p><h2 id="1-单道-多道程序的CPU效率问题。"><a href="#1-单道-多道程序的CPU效率问题。" class="headerlink" title="1. 单道/多道程序的CPU效率问题。"></a>1. 单道/多道程序的CPU效率问题。</h2><h2 id="2-对于一个操作系统来说，它要有哪些功能？"><a href="#2-对于一个操作系统来说，它要有哪些功能？" class="headerlink" title="2. 对于一个操作系统来说，它要有哪些功能？"></a>2. 对于一个操作系统来说，它要有哪些功能？</h2><h2 id="3-从发明至今，有哪些操作系统，特点是什么？"><a href="#3-从发明至今，有哪些操作系统，特点是什么？" class="headerlink" title="3. 从发明至今，有哪些操作系统，特点是什么？"></a>3. 从发明至今，有哪些操作系统，特点是什么？</h2><hr><h1 id="第三章-同步、通信与死锁"><a href="#第三章-同步、通信与死锁" class="headerlink" title="第三章 同步、通信与死锁"></a>第三章 同步、通信与死锁</h1><p><strong>PPT内容主要讲述以下问题：</strong></p><h2 id="什么是并发进程"><a href="#什么是并发进程" class="headerlink" title="什么是并发进程"></a>什么是并发进程</h2><hr><h2 id="并发进程与时间无关的充分条件Bernstein条件"><a href="#并发进程与时间无关的充分条件Bernstein条件" class="headerlink" title="并发进程与时间无关的充分条件Bernstein条件"></a>并发进程与时间无关的充分条件Bernstein条件</h2><blockquote><p><strong>Bernstein条件</strong>：</p><p>设进程<strong>A</strong>引用变量集合为<strong>R1</strong>，改变变量集合为<strong>W1</strong>，进程<strong>B</strong>引用变量集合为<strong>R2</strong>，改变变量集合为<strong>W2</strong>。那么只要满足：</p><p>(R1 ∩ W2) ∪ (R2 ∩ W1) ∪ (W1 ∩ W2) = ∅</p><p>那么进程<strong>A</strong>和进程<strong>B</strong>与时间无关。</p><p>简而言之就是A和B的读写不冲突，也不会往同一个变量里写。</p></blockquote><hr><h2 id="并发进程间的交互："><a href="#并发进程间的交互：" class="headerlink" title="并发进程间的交互："></a>并发进程间的交互：</h2><ul><li>竞争关系/间接制约关系：对于同一资源区，进程互斥访问，一个进程在用资源区的时候，其他进程只能等着</li><li>协作关系/直接制约关系：进程间互发信号控制对方是沉睡还是唤醒</li></ul><hr><h2 id="并发进程引起的时间问题："><a href="#并发进程引起的时间问题：" class="headerlink" title="并发进程引起的时间问题："></a>并发进程引起的时间问题：</h2><ul><li>结果不唯一，比如订票，抢红包</li><li>永远等待</li></ul><hr><h2 id="临界区-critial-section-是什么？"><a href="#临界区-critial-section-是什么？" class="headerlink" title="临界区(critial section)是什么？"></a>临界区(critial section)是什么？</h2><blockquote><p>定义：共享资源所在程序段</p><p>调度原则：</p><ul><li>一次只能进一个</li><li>里面的，不能一直呆在里面</li><li>外面的，不能一直等在外面</li><li>有空让进，无空等待，择一而入，算法可行</li></ul></blockquote><hr><h2 id="临界区管理方法："><a href="#临界区管理方法：" class="headerlink" title="临界区管理方法："></a>临界区管理方法：</h2><ul><li><p>先检测，后置位。弊端是检测完后可能有其他进程也进入临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inside1, inside2: Boolean</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br><span class="line">inside2 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>先置位，后检测。弊端是置位后可能inside2又被置1，可能永远等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="临界区管理软件方法："><a href="#临界区管理软件方法：" class="headerlink" title="临界区管理软件方法："></a>临界区管理软件方法：</h2><ol><li><p>Dekker算法</p><blockquote><p>基本思想：</p><ol><li>进程P1进入临界区时，将inside1置为true。</li><li>若P2在临界区，则P1等待。若P2不在临界区但也想进入，询问turn变量，由turn指示谁进入。若P2不在临界区且不想进入临界区，那么P1进入临界区。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Peterson算法</p><blockquote><p>基本思想：</p><ol><li>进程P1进入临界区时，将inside1置为true，指示器turn置为2。</li><li>若P2在临界区内且turn为2，则P1等待。否则P1进入临界区，然后inside1置为false。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol><hr><h2 id="临界区管理硬件方法："><a href="#临界区管理硬件方法：" class="headerlink" title="临界区管理硬件方法："></a>临界区管理硬件方法：</h2><ol><li><p>关中断</p><p> 进入临界区前关中断，进入临界区，出临界区后开中断</p></li><li><p>用TS指令(test and set)</p><p> 反复TS代表临界区的lock变量，即“上锁”，如果该临界区空闲，会返回true，否则返回false。如果空闲，就进入临界区，否则一直反复。出临界区后lock置为true，即“开锁”。</p><blockquote><p>TS(x)指令等价于这段代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TS</span><span class="params">(<span class="keyword">bool</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">true</span>)&#123;</span><br><span class="line">        x = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><ol><li><p>用SWAP指令(在x86-64架构下是XCHG指令)</p><p> 一开始置临界区的lock变量为false，进程P的变量为key，置为true。交换一次lock和key(“上锁”)就检测一次key，如果key为false，说明临界区此时为空闲，进入临界区，出来后再次交换lock和key，即“开锁”。</p><p> 代码：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> lock = <span class="literal">false</span>;</span><br><span class="line">cobegin</span><br><span class="line">    <span class="function">process <span class="title">P</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            SWAP(key, lock);    <span class="comment">//上锁</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(key);</span><br><span class="line">        临界区;</span><br><span class="line">        SWAP(key, lock);        <span class="comment">//开锁</span></span><br><span class="line">    &#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h2><p><del>书上没讲定义，按我的理解就是对共享资源的读写一致性问题，说白了还是前面的并发进程问题没解决呗</del>。</p><p>百度说，进程同步是指的进程相互协作、等待的过程。</p><p>同步的办法有3种，信号量与PV操作、管程、消息传递。</p><hr><h2 id="信号量与PV操作"><a href="#信号量与PV操作" class="headerlink" title="信号量与PV操作"></a>信号量与PV操作</h2><p>信号量用来表示一个物理资源的使用情况，PV操作用来控制资源使用。</p><p>同步原语：P(Proberen,测试)，V(Verhogen,增量)。</p><p>除了赋初值外，信号量只能由同步原语操作。</p><p>(所谓原语，就是一段在执行过程中不许中断的指令序列)</p><hr><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><hr><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><hr><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><hr><h2 id="具体问题的解决方案"><a href="#具体问题的解决方案" class="headerlink" title="具体问题的解决方案"></a>具体问题的解决方案</h2><ul><li>生产者-消费者问题</li><li>五个哲学家吃通心面问题</li><li>读者-写者问题</li><li>理发师问题</li></ul><hr><h1 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h1><h2 id="成绩组成"><a href="#成绩组成" class="headerlink" title="成绩组成"></a>成绩组成</h2><p>平时作业：10%<br>实验：30%<br>期中：10%<br>期末：50%</p><p>实验类似PA，阶段之间有联系，硬DDL<br>期中讲完3章考</p><h1 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>一些敏感系统不用操作系统的原因：</p><ol><li>直接汇编放内存速度快</li><li>防止出错？？</li></ol><p>裸机：未安装操作系统的计算机</p><p>操作系统的主要目标：</p><ol><li>扩大机器功能</li><li>管理系统资源</li><li>提高系统效率</li><li>构筑开发环境</li><li>方便用户使用</li></ol><p>资源管理技术：复用、虚拟、抽象</p><h2 id="资源复用"><a href="#资源复用" class="headerlink" title="资源复用"></a>资源复用</h2><h3 id="空分复用共享"><a href="#空分复用共享" class="headerlink" title="空分复用共享"></a>空分复用共享</h3><p>例如，将内存、磁盘，按4KB一页划分，分配给不同进程。</p><h3 id="时分复用共享"><a href="#时分复用共享" class="headerlink" title="时分复用共享"></a>时分复用共享</h3><p>时分独占式：<br>进程1使用一个完整周期后才释放资源。</p><p>时分共享式：<br>例如，将CPU使用时间分为若干个时间片，进程1使用第1、3、5片，进程2使用第2、4、6片…</p><h2 id="资源虚拟"><a href="#资源虚拟" class="headerlink" title="资源虚拟"></a>资源虚拟</h2><p>把物理资源变成逻辑上的多个对应物。<br>例如，计算机连接到打印机，发送打印命令时，先发到虚拟的打印机，等一个打印文件完全发到虚拟打印机后，物理打印机才开始打印。有多个文件请求打印时，进入虚拟的打印机的队列。</p><h2 id="资源抽象"><a href="#资源抽象" class="headerlink" title="资源抽象"></a>资源抽象</h2><p>用软件来屏蔽硬件实现细节，只要调用API就行了</p><p>操作系统：管理计算机硬件资源的系统软件，为用户提供交互界面，提升硬件使用效率，主要方法是复用、虚拟和抽象。<br>2019-2-26</p><hr><h2 id="认识操作系统的四种观点"><a href="#认识操作系统的四种观点" class="headerlink" title="认识操作系统的四种观点"></a>认识操作系统的四种观点</h2><h3 id="服务用户观点"><a href="#服务用户观点" class="headerlink" title="服务用户观点"></a>服务用户观点</h3><p>系统调用向API提供服务</p><p>操作系统提供良好的人机界面</p><h3 id="进程交互观点"><a href="#进程交互观点" class="headerlink" title="进程交互观点"></a>进程交互观点</h3><p>操作系统作为<strong>进程执行的控制者和执行者</strong></p><ul><li>OS需要提供机制，解决并发进程的<strong>互斥、同步、通信和死锁问题</strong></li></ul><h3 id="系统实现观点"><a href="#系统实现观点" class="headerlink" title="系统实现观点"></a>系统实现观点</h3><p>操作系统作为扩展机或虚拟机，把硬件的复杂性与用户隔离开来。</p><ul><li>把操作系统分为若干层次，逐步添加到裸机上，系统功能就能增加一点形成操作系统虚拟机</li><li>扩充后的虚拟机不仅能使用<strong>硬件指令</strong>，还能使用<strong>系统指令</strong></li></ul><h3 id="资源管理观点"><a href="#资源管理观点" class="headerlink" title="资源管理观点"></a>资源管理观点</h3><p>操作系统对软硬件资源进行<strong>资源复用、虚拟和抽象</strong></p><p>管理各种资源</p><h2 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h2><h3 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h3><p>多道程序设计，提高处理器效率。</p><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><p>主要是管理内存，包括</p><ul><li>内存分配</li><li>地址转换</li><li>存储保护</li><li>内存共享</li><li>存储扩充</li></ul><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>主要任务</p><ul><li>管理外设</li><li>发挥设备的并行性</li><li>提供设备驱动程序和中断处理程序</li></ul><p>核心功能</p><ul><li>设备中断处理</li><li>缓冲区管理</li><li>设备独立性<ul><li>实现逻辑设备到物理设备之间的映射</li></ul></li><li>设备的分配和回收</li><li>共享型设备的驱动调度</li><li>虚拟设备</li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>对用户文件和系统文件进行管理</p><ul><li>文件逻辑组织方法</li><li>文件物理组织方法</li><li>文件存取和使用方法</li><li>文件目录管理</li><li>文件共享和安全性控制</li></ul><h3 id="网络与通信管理"><a href="#网络与通信管理" class="headerlink" title="网络与通信管理"></a>网络与通信管理</h3><p>通过网络协议进行管理</p><h2 id="操作系统主要特性"><a href="#操作系统主要特性" class="headerlink" title="操作系统主要特性"></a>操作系统主要特性</h2><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><p>并发：指的是两个或两个以上的事件在同一时间间隔内（比如1分钟内）发生<br>并行：在同一时刻发生</p><p>要求实现多个进程间的安全切换</p><h3 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h3><p>解决读写一致问题、临界区之类的问题</p><h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><p>进程的开始、暂停、前进速度都是随机的</p><p>作业到达系统的类型和时间是随机的</p><p>操作员发命令或按按钮的时刻是随机的</p><p>程序出错是随机的</p><p>软硬件中断是随机的</p><p><strong>所以需要解决和时间有关的错误</strong></p><h2 id="多道程序设计效果"><a href="#多道程序设计效果" class="headerlink" title="多道程序设计效果"></a>多道程序设计效果</h2><ol><li><p>提高了系统效率</p></li><li><p>延长了每道题的计算时间</p></li><li><p>牺牲了用户的响应时间</p></li></ol><p>假设程序等待IO的时间占其运行时间比为p，n道程序同时等待的概率是$p^n$，那么CPU效率是$1-p^n$。</p><h2 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h2><p>作业是指把程序、数据连同作业说明书组织起来的任务单位</p><p>批作业是指把批中的作业预先输入作业队列，由操作系统按照说明来调度和控制作业执行，形成自动转接和连续处理作业。</p><p>特点：</p><ul><li>用户脱机工作</li><li>成批处理作业</li><li>多道程序运行</li><li>作业周转时间长</li></ul><h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><ul><li>多个联机用户同时使用一个计算机系统在各自的终端上进行交互式对话</li><li>程序、数据和命令都在会话过程中产生，通过问答方式控制程序</li><li>处理器分为时间片给不同用户</li></ul><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><ul><li>外部事件产生时，快速处理</li></ul><hr><p>地址转换</p><p>2019-2-28</p><hr><h2 id="操作系统基本服务和用户接口"><a href="#操作系统基本服务和用户接口" class="headerlink" title="操作系统基本服务和用户接口"></a>操作系统基本服务和用户接口</h2><h3 id="基本服务和用户接口"><a href="#基本服务和用户接口" class="headerlink" title="基本服务和用户接口"></a>基本服务和用户接口</h3><p>基本服务</p><ul><li>创建程序</li><li>执行程序</li><li>数据IO</li><li>通信服务</li><li>错误检测和处理</li><li>资源分配、统计、保护</li></ul><h3 id="程序接口与系统调用"><a href="#程序接口与系统调用" class="headerlink" title="程序接口与系统调用"></a>程序接口与系统调用</h3><p>各种Linux版本之间相同点在于内核，内核只有版本号不一样。即内核版本相同的ubuntu和debian，能支持一样的软件。</p><p>用户态-&gt;内核态通过IDT，内核态-&gt;用户态iret</p><p>异常分类：</p><ul><li>故障(fault)：可恢复错误</li><li>陷阱(trap)：用户态-&gt;内核态</li><li>终止(abort)：不可恢复错误，不返回</li></ul><p>POSIX标准：<br>规定操作系统必须提供API，未规定接口的实现是采用系统调用、库函数还是其他形式。</p><p>函数库：</p><ul><li>静态库：编译时把库函数作为代码的一部分，生成bin</li><li>动态库/共享库：如DLL，编译时只给出入口地址，运行到这才加载</li></ul><p>系统调用时的过程、内核栈</p><p>区分系统调用过程中的中断向量号和系统调用号：压栈时取反再压</p><p>禁用一个syscall: sys_ni_syscall</p><p>添加一个syscall: 看ppt</p><h3 id="操作接口"><a href="#操作接口" class="headerlink" title="操作接口"></a>操作接口</h3><p>作业控制方式：</p><ul><li>联机：有命令行交互，人敲一句机器干一句/处理一个.bat文件</li><li>脱机：用JCL(job control language)语言把作业说明书塞给机器，然后人走了机器继续干活</li></ul><h3 id="系统程序"><a href="#系统程序" class="headerlink" title="系统程序"></a>系统程序</h3><p>运行于用户态</p><p>分类：</p><ul><li>文件管理</li><li>状态信息</li><li>对编程语言的支持</li></ul><h2 id="操作系统结构与运行模型"><a href="#操作系统结构与运行模型" class="headerlink" title="操作系统结构与运行模型"></a>操作系统结构与运行模型</h2><h3 id="结构分类"><a href="#结构分类" class="headerlink" title="结构分类"></a>结构分类</h3><ul><li>单体式：模块组合，互相接口，可以互相调用，数据是全程量，缺点：牵一发而动全身</li><li>层次式：分中断-内存-进程-IO（不全）等等多层，自下到顶</li><li>微内核：仅具有很少的必要功能，很小</li><li>虚拟机：用一个物理机模拟另一个物理机，通过分时使用管理多台机器。CMS?用户交互CMS，CMS交互硬件。</li></ul><p>原语不可中断</p><p>单内核功能多，效率高，但修改之后要重新编译<br>微内核容量小，额外功能都通过服务来完成，不用重新编译</p><p>Linux的做法：可加载内核模块，需要的时候像零件一样装上去拆下来，不用重新编译整个内核</p><h3 id="Linux中断处理"><a href="#Linux中断处理" class="headerlink" title="Linux中断处理"></a>Linux中断处理</h3><p>中断分快中断和慢中断</p><p>x86提供了15根 IRQ 线，但可以接入的设备不止15台，连到同一根 IRQ 线的设备有不同的<code>中断服务例程</code></p><p>最早的“下半部”实现机制：bottom half，静态创建，32个元素的链表，全局同步，不允许在任何两个 BH 同时执行</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
