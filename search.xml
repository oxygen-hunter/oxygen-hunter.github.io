<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习笔记</title>
      <link href="/2019/02/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>机器学习复习笔记</p><p>参考书目：西瓜书</p><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="课程任务"><a href="#课程任务" class="headerlink" title="课程任务"></a>课程任务</h2><ol><li>平时作业40%</li><li>期中30%</li><li>期末30%（投票决定闭卷/半开卷）</li></ol><p>平时作业有2次取较高分作为期中成绩，其他4次作为平时成绩<br>半开卷：允许带一张a4纸，上面写什么都可以，考完交a4纸</p><h2 id="机器学习示例："><a href="#机器学习示例：" class="headerlink" title="机器学习示例："></a>机器学习示例：</h2><p>文献筛选<br>在<code>循证医学</code>中，针对特定临床问题，要先查文献进行详细研究评估。<br>提取摘要-&gt;人工筛选。应用机器学习后专家读少量文献，标记有关/无关，模型去读剩下来的文献。</p><p>搜索引擎<br><code>用机器学习解决排序问题</code></p><p>战场战术层面<br><code>损害管制自主机器人</code><br><code>罗盘系统</code></p><h2 id="典型的机器学习过程："><a href="#典型的机器学习过程：" class="headerlink" title="典型的机器学习过程："></a>典型的机器学习过程：</h2><p>给模型以数据（包含一系列属性+1个label），训练，检测。</p><h2 id="几个分类："><a href="#几个分类：" class="headerlink" title="几个分类："></a>几个分类：</h2><p><code>符号主义学习</code>、<code>连接主义学习</code></p><p>贝叶斯学派：<br>第1天，太阳升起，建立模型，预测明天太阳升起概率1/2<br>第2天，太阳升起，修正参数，预测明天太阳升起概率1/3<br>…<br>第30000天，预测30000/300001</p><p>非贝叶斯学派：<br>第1天，太阳升起，预测1<br>第2天，太阳升起，预测1<br>…<br>第30000天，根据之前的事实证据，认为太阳升起概率恒为1</p><h2 id="面临问题"><a href="#面临问题" class="headerlink" title="面临问题"></a>面临问题</h2><p>现在的问题在于大厂缺少需求，算力过剩。Google收购DeepMind是为了消耗TPU，AI实际上是互联网商们的一个出口。</p><p>鲁棒性不行，人类棋手犯错，从九段跌到八段，机器犯错，从九段跌到业余。</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>预测目标：</p><ul><li>分类：最后的输出是离散值<ul><li>二分类：好瓜、坏瓜</li><li>多分类：冬瓜、南瓜、西瓜</li></ul></li><li>回归：连续值<ul><li>瓜的成熟度</li></ul></li><li>聚类：无标记信息（物以类聚/具有相同hash feature的数据被hash后放入同一个桶/韩信点兵/等价类划分）</li></ul><p>有无标记信息：</p><ul><li>监督学习：分类、回归</li><li>无监督学习：聚类</li><li>半监督学习：两者结合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论定理收集</title>
      <link href="/2019/02/26/%E5%9B%BE%E8%AE%BA%E5%AE%9A%E7%90%86%E6%94%B6%E9%9B%86/"/>
      <url>/2019/02/26/%E5%9B%BE%E8%AE%BA%E5%AE%9A%E7%90%86%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>参考书目：《图论与网络理论》和ppt</p><p>要求：复习的时候都会证明</p><h1 id="第一章-图的基本概念"><a href="#第一章-图的基本概念" class="headerlink" title="第一章 图的基本概念"></a>第一章 图的基本概念</h1><p>定理1.1.1 对任何图G，各顶点度数之和等于边数的2倍。即 $ \sum\limits_{\nu\in V(G)}d(\nu) = 2\varepsilon. $</p><p>推论1.1.1 任何图中，奇度顶点个数为偶数。</p><p>例1.1.2 设G是一个简单图，若最小度 $ \delta(G) \geq 2 $，则G中必含有圈。</p><p>例1.1.3 设G是一个简单图，若最小度 $ \delta(G) \geq 3 $，则G中必含有偶圈。</p><p>例1.1.4 设G是简单图，若最小度 $ \delta(G) \geq 3 $，则G中各个圈长的最大公因数是1或2。</p><p>定理1.1.2 一个图是二部图当且仅当它不含有奇圈。</p><p>定理1.1.3 如果图G连通，$ \varepsilon(G) \geq \nu(G)-1 $。</p><p>例1.1.6 设图G有2n个顶点，$ \delta(G) \geq n $，求证G连通。</p><p>例1.1.7 求证：若图中有且仅有2个奇度顶点，则它们必然连通。</p>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高程学习笔记</title>
      <link href="/2019/02/26/%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/26/%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>高级程序设计复习笔记</p><p>参考书目：<br>《程序设计教程—用C++语言描述》陈家骏、郑滔<br>《Thinking in C++》机械工业出版社</p><h1 id="第一章-复习程设基础"><a href="#第一章-复习程设基础" class="headerlink" title="第一章 复习程设基础"></a>第一章 复习程设基础</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>分数组成：<br>作业10%<br>上机40%（现场oj和课后projects）<br>期末50%（据说较为简单）</p><h2 id="C-C-数据类型"><a href="#C-C-数据类型" class="headerlink" title="C/C++数据类型"></a>C/C++数据类型</h2><p><code>unsigned</code>类型运算不封闭，+*/封闭，-不封闭</p><p><code>float</code>类型 0.1+0.2!=0.3之类的</p><p><code>实数</code>相等条件，比较差的绝对值是否小于一个很小的数</p><p>联合类型用于用一种类型表示多种类型的数据，例如不同类型的数据组织在一起不能用array</p><p>指针是内存地址的抽象，用于动态变量（链表）、传递参数</p><h2 id="C-过程抽象"><a href="#C-过程抽象" class="headerlink" title="C++过程抽象"></a>C++过程抽象</h2><p><code>C++函数</code>与<code>数学函数</code>区别：</p><ol><li>C++函数可以没有返回值</li><li>可以有副作用(side effect)</li><li>同一个实参，不同时刻调用结果可以不一样</li></ol><h2 id="内存区安排"><a href="#内存区安排" class="headerlink" title="内存区安排"></a>内存区安排</h2><p>静态数据区</p><ul><li>全局变量</li><li>static局部变量</li><li>常量</li></ul><p>2019-2-26</p><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记</title>
      <link href="/2019/02/25/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/25/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>计算机网络（Computer Network）复习笔记</p><p>参考书目：《计算机网络自顶向下方法（第5版）》机械工业出版社</p><h1 id="CH1-Introduction-of-Networking-1"><a href="#CH1-Introduction-of-Networking-1" class="headerlink" title="CH1-Introduction of Networking-1"></a>CH1-Introduction of Networking-1</h1><h2 id="杂记："><a href="#杂记：" class="headerlink" title="杂记："></a>杂记：</h2><p>CN负责数字通信（数字信号）</p><p>哈罗车筐前黑色是太阳能板？</p><p>宿舍-一层-一楼-学校网络中心-南京教育网（东大）-全国教育网</p><p>第一台联网计算机在UCLA</p><p>remote medicine 瓶颈在于时延</p><p>行星间联网，光速瓶颈</p><p>因特网是一个复杂系统，分解为<strong>5个子问题</strong>，谁来分解？如何分解？</p><hr><h2 id="课程主要讲述："><a href="#课程主要讲述：" class="headerlink" title="课程主要讲述："></a>课程主要讲述：</h2><ol><li>因特网如何工作？</li><li>子问题为什么这样解决？</li></ol><h2 id="讲解顺序："><a href="#讲解顺序：" class="headerlink" title="讲解顺序："></a>讲解顺序：</h2><ol><li>基础：包、链路、复用、时延、丢包</li><li>低级技术：以太网，无线局域网，3g，4g</li><li>IP，路由，BGP</li><li>网络互通后如何交换信息：DNS,CDN,HTTP,TCP</li><li>热点问题：数据中心、</li></ol><h2 id="课程任务："><a href="#课程任务：" class="headerlink" title="课程任务："></a>课程任务：</h2><ol><li>实验25%（现场提问，验收，改代码，严格）</li><li>作业15%</li><li>期末考试60%</li></ol><hr><h2 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h2><ol><li>电路交换：最基础的交换方式。点对点<br> 特点：<ol><li>中间所有资源都预留好</li><li>admission control per connection</li></ol></li><li>包交换：大家都把数据分为小数据包，一股脑发到交换机，交换机再转发，自由竞争，冲突了就丢一个，一个小包失败了就再发一次。（核心思想：统计复用）<br> 特点：<ol><li>包独立处理</li><li>admission control per packet</li></ol></li><li>虚链路：在包交换中模拟电路交换给vip用户优先权，以便冲突时优先满足vip用户</li></ol><hr><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>电路交换：在两点之间建立通道，src和dst之间直接连接（中间类似于多刀多掷开关）</p><p>建链-传输-拆链。想象成老电影里的电话局，处长和局长通话需要接线员接线、通话、拔线。</p><p>时间分片：比如，将1ms分为1000片，1000个用户同话，用户1通话时只占用1ms的第1片，然后若干个1ms组成了通话时间。如果有人通话量大，就多分几片。</p><p>频率分片：将频率切片，比如1Mhz的一段切成100片分给不同的用户，实际上要分很多级/空间复用，不然没法满足几亿用户的分配需求，频率之间不干扰，频率由国家法律严格控制，比如联通被分在800-850Mhz。</p><p>低频波的波长长，容易绕开障碍物。所以停用2G用户，这样子那一段频率就可以用来给5G了。</p><p>1G频分，2G时分，后面的利用更高级原理。</p><p><img src="/2019/02/25/计网学习笔记/" alt="电路交换的时序图1"></p><p><strong>为什么建链时有delay，拆链时没有delay？</strong><br>因为建链时，需要预留电路，要时间，可能会失败。拆链直接拆就行。</p><p><img src="/2019/02/25/计网学习笔记/" alt="电路交换的时序图2"></p><p>传输data时，不一定是连续的，不传输的时候就浪费了。比如2G/3G时代的手机QQ，发一个消息要建链-拆链一次，电费消耗大。在传大文件或者看电影才划算。</p><p><strong>优点：</strong></p><ol><li>predictable performance（保证一定送到，速度也有保障）</li><li>simple/fast switching (once circuit established)（建链后很简单）</li></ol><p><strong>缺点：</strong></p><ol><li>complexity of circuit setup/teardown（建链和拆链很麻烦）</li><li>inefficient when traffic is bursty（上述手机QQ的浪费、驿站的一匹马只运输一串荔枝，但实际上可以驼很多东西，这些空间浪费了。）</li><li>circuit setup adds delay（建链需要一来一回，增加时延，聊微信会很花时延）</li><li>switch fails-&gt;circuit fails（建链失败就完蛋）</li></ol><p>相似工作原理：华为手机之所以省电，在于有1个主CPU和几个小CPU，微信等通过小CPU。天线也是自己开屏幕才会工作，所以微信可能会收到不及时。</p><hr><h2 id="包交换"><a href="#包交换" class="headerlink" title="包交换"></a>包交换</h2><p>包交换：通信时像快递一样，只要写好每个数据包发货地址和收货地址，交换机只要负责查地址，就可以发了。核心思想是<code>统计复用</code>。</p><p>不保证性能：如果一大堆人同时发包，只能送一个，其他丢掉。或者用一个buffer缓存一下，再发。</p><p><strong>优点：</strong></p><ol><li>Efficient use of network resources</li><li><strong>simpler to implement</strong>（要求交换机做的事情很少，复杂的事交给端系统完成，就很便宜）</li><li>robust: can “route around trouble”（不存在链路建立失败的问题，比如一家快递倒闭了我换一家就可以了）</li></ol><p><strong>缺点：</strong></p><ol><li>unpredictable performance（由于buffer容量有限，只能保证大部分快递不送丢，类比双11快递公司的爆仓）</li><li>requires buffer management and congestion control（需要管理仓库和拥塞控制，管理仓库是这个快递费20，那个快递费5块，冲突就丢掉5块的。拥塞控制是双11短期取货码（被动，拥塞已经发生）、提前两三周开始双11（主动从源头控制）、南大驿站装不下就返回到上一级驿站）</li></ol><h2 id="统计复用-statistical-multiplexing"><a href="#统计复用-statistical-multiplexing" class="headerlink" title="统计复用 statistical multiplexing"></a>统计复用 statistical multiplexing</h2><p>Allowing more demands than the network can handle.</p><ul><li><p>hoping that not all demands are required at the same time（小区接入宽带，允许10个用户100M，但只给他们分配100M，因为假定他们不会同时用网，且一家人用不了100M。）（旅馆也住不了那么多人，正常情况下不会这么多人同时去住，如果想专享线路，建个行宫吧）</p></li><li><p>results in unpredictability（世界杯期间突然爆满）</p></li><li><p>works well except for the extreme cases（爆满的情况不符合统计复用的条件）</p></li></ul><h2 id="如何评价网络性能"><a href="#如何评价网络性能" class="headerlink" title="如何评价网络性能"></a>如何评价网络性能</h2><ul><li>时延delay</li><li>丢包率loss</li><li>吞吐量throughput</li></ul><p>无线网络侧重于丢包率</p><p>数据中心侧重时延</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>Consists</p><ul><li>transmission delay (link，取决于带宽，$数据量/带宽$)</li><li>propagation delay (link，取决于路长，$长度/光速$)</li><li>queueing delay<br>(取决于来的包，冲突就进队列，队列溢出就丢掉，由于包有编号，接收端数一数123457，丢了6号，那么通知发送方重发)(按均值和variance来衡量，由排队论设计好)（数据中心的主要时延）（平均排队时长）<blockquote><p>Littes’s law(1961)<br>L = A * W</p></blockquote></li><li>processing delay (有但可以忽略不计了，和电子工业发展有关) </li></ul><p>链路带宽bandwidth：八车道的八（同时有几个比特在链路里跑）</p><p>BDP = Bandwidth * propagation delay</p><p>$1G=10^9$</p><p>对于小文件，$D_{prop}$占主导，对于大文件，$D_{trans}$占主导时延</p><p>普通交换机遵循store-forward模式，交换机收到包先存起来解析包头再发下一站。<br>端(trans,prop,queue&amp;process)交换机()交换机()端</p><p>高频交换机（高频率股票交易）不遵循上述模式<br>带宽极高不用queue，收到1bit就直接发。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记</title>
      <link href="/2019/02/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇供日后复习，跳跃性很大，随性更新。</p><p>参考书目：《算法设计与分析》 黄宇 机械工业出版社</p><h1 id="第2章-从算法的角度重新审视数学的概念"><a href="#第2章-从算法的角度重新审视数学的概念" class="headerlink" title="第2章 从算法的角度重新审视数学的概念"></a>第2章 从算法的角度重新审视数学的概念</h1><h3 id="2-1-3-阶乘n"><a href="#2-1-3-阶乘n" class="headerlink" title="2.1.3 阶乘n!"></a>2.1.3 阶乘n!</h3><p>根据<code>Stirling公式</code>，可以将<code>n!</code>转化为更易于处理的闭形式，对<code>n&gt;=1</code>，有：</p><script type="math/tex; mode=display">\sqrt{2\pi n}(\frac{n}{e})^n < n! < \sqrt{2\pi n}(\frac{n}{e})^n(1+\frac{1}{11n})</script><p><code>Stirling公式</code>也可以写成：</p><script type="math/tex; mode=display">n! = \sqrt{2\pi n}(\frac{n}{e})^n e^{\varepsilon(n)},其中\frac{1}{12n+1} \leq \varepsilon(n) \leq \frac{1}{12n}</script><p>写成近似形式：</p><script type="math/tex; mode=display">n! = \sqrt{2\pi n}(\frac{n}{e})^n(1+\Theta(\frac{1}{n}))</script><p>由于 $\Theta(\frac{1}{n})$ 是无穷小量，$\lim\limits_{n \to \infty} \frac{1}{n}=0$ ，忽略。所以得到进一步的近似式：</p><script type="math/tex; mode=display">n! \approx \sqrt{2\pi n}(\frac{n}{e})^n</script><h3 id="2-1-4-常见级数求和-sum-limits-i-1-n-f-i"><a href="#2-1-4-常见级数求和-sum-limits-i-1-n-f-i" class="headerlink" title="2.1.4 常见级数求和 $\sum\limits_{i=1}^{n}f(i)$"></a>2.1.4 常见级数求和 $\sum\limits_{i=1}^{n}f(i)$</h3><ul><li>多项式级数(polynomial series)<br>  $ \sum\limits_{i=1}^{n}i = \dfrac{n(n+1)}{2} $<br>  .<br>  $ \sum\limits_{i=1}^{n}i^2 = \dfrac{1}{3}n(n+\dfrac{1}{2})(n+1) $<br>  .<br>  $ \sum\limits_{i=1}^{n}i^k = \Theta(\dfrac{1}{k+1}n^{k+1}) $<br>  .</li><li>几何级数(geometric series)<br>  $ \sum\limits_{i=0}^{k}ar^i = a(\dfrac{r^{k+1}-1}{r-1}) $</li></ul><p>测试用<br>$\begin{eqnarray}f(x,y)<br>    &amp;=&amp;2xy+(x-y)^2\\<br>    &amp;=&amp;x^2+y^2<br>\end{eqnarray}$</p><h1 id="第0章-概论"><a href="#第0章-概论" class="headerlink" title="第0章 概论"></a>第0章 概论</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>Q1: 在数组中找最大元素和最小元素</p><p>A1: 最优：n为偶数时，将数组切分为($a_0$,$a_1$)($a_2$,$a_3$)…($a_{n-2}$, $a_{n-1}$)，组内比较后分出胜者组和败者组，胜者组遍历一遍得到最大元素，败者组遍历一遍得到最小元素。n为奇数时先抛开最后一个元素，最后额外比较一下。</p><hr><p>Q2: 比较3匹马的预测性</p><p>A2: 将马的过去两百场比赛进行huffman编码，所用字符最少的马预测性越强，原理是信息熵。</p><hr><p>Q3: 停机问题</p><p>A3: 不可判定，假设有程序terminate(p:program, x:input)能判断对于程序p，给一个输入x，p是否会终止（即判定p(x)是否终止），那么定义程序paradox(z:file)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paradox(z:file):</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">if</span>(terminate(z, z)) <span class="keyword">goto</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>paradox(z)的执行结果为</p><script type="math/tex; mode=display">\left\{\begin{array}{aligned}z(z)不终止   &&  {paradox(z)终止}\\z(z)终止     &&  {paradox(z)不终止}\\\end{array} \right.</script><p>此时，paradox(paradox)便成为矛盾体</p><script type="math/tex; mode=display">\left\{\begin{array}{aligned}paradox(paradox)不终止 &&   {paradox(paradox)终止}\\paradox(paradox)终止   &&   paradox(paradox)不终止\end{array} \right.</script><h2 id="课程任务："><a href="#课程任务：" class="headerlink" title="课程任务："></a>课程任务：</h2><p>书面作业15%（8次，准备2个作业本）<br>编程15%（6-8次，每次2-4题，时间2-3周）<br>期中20%<br>期末50%</p><h1 id="第1章-概论"><a href="#第1章-概论" class="headerlink" title="第1章 概论"></a>第1章 概论</h1><p>《proof without words》中的有趣证明？</p><p>double counting 思想用于证明</p><h2 id="平均复杂度"><a href="#平均复杂度" class="headerlink" title="平均复杂度"></a>平均复杂度</h2><p>$ \sum\limits_{i=1}^{n}Pr(i)I(i) $</p><h2 id="算法的最优性"><a href="#算法的最优性" class="headerlink" title="算法的最优性"></a>算法的最优性</h2><p>如果一个算法的最坏情况等于问题的下界，那么这个算法是最优的。</p><h2 id="渐进时间复杂度"><a href="#渐进时间复杂度" class="headerlink" title="渐进时间复杂度"></a>渐进时间复杂度</h2><p>$ log_{n}, n^\alpha, c^n, n!, n^n $</p><script type="math/tex; mode=display">\lim\limits_{n\to \infty}\frac{f(n)}{g(n)}=c,\left\{\begin{array}{aligned}c=0 &&  f=o(g)\\0 \leq c<\infty && f=O(g)\\0 < c <\infty && f=\Theta(g)\\0 < c \leq \infty && f=\Omega(g)\\c=\infty && f=\omega(g)\end{array} \right.</script><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树的高度p是问题的lower bound，基于比较的决策树节点数为n，有$ n \leq 2^{p-1} $，所以$ p &gt;= lgn $，所以查找问题的lower bound为$lgn$，二分查找是最优算法。</p><p>思考题：圆的内接八边形，边长4个2，4个3，求八边形面积。</p><script type="math/tex; mode=display">f(n) =\begin{cases}n/2,  & \text{if $n$ is even}\\3n+1, & \text{if $n$ is odd}\end{cases}</script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记</title>
      <link href="/2019/02/05/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/05/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title="?"></a>?</h1><h2 id="while中的let问题"><a href="#while中的let问题" class="headerlink" title="while中的let问题"></a>while中的let问题</h2><p>这是一段简单的遍历数组代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> array: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, array[index]);</span><br><span class="line"></span><br><span class="line">    index = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果显然</p><p><img src="/2019/02/05/Rust学习笔记/正常遍历结果.png" alt="正常遍历结果"></p><p>但如果略作修改，即index的mut关键字去掉，在迭代时用let index 隐藏原来的index<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> array: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, array[index]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> index = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果就是无限输出10。</p><hr><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安装参考网站</title>
      <link href="/2019/02/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/"/>
      <url>/2019/02/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文包含一些软件的优秀安装指南，都是亲测可用的。以备以后重新安装系统快速使用，本文会热更新。</p><p>每段的格式为：</p><ul><li><p>[已有教程网址]</p></li><li><p>[排除教程中的坑]</p></li><li><p>[对教程中的简要概括(防止教程404)]</p></li></ul><hr><h1 id="蓝灯lantern"><a href="#蓝灯lantern" class="headerlink" title="蓝灯lantern"></a>蓝灯lantern</h1><ul><li><p>教程：<a href="http://www.pianshen.com/article/5553973/" target="_blank" rel="noopener">lantern傻瓜式安装教程</a></p></li><li><p>排坑：进入 <a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">https://github.com/getlantern/lantern</a> 最下面。如果左击 <strong>ubuntu 14.04 64 bit</strong> 后没有直接下载：右击 <strong>ubuntu 14.04 64 bit</strong> 用迅雷下载链接。</p></li></ul><hr><h1 id="sublime-text-3"><a href="#sublime-text-3" class="headerlink" title="sublime text 3"></a>sublime text 3</h1><ul><li><p>教程：<a href="https://jingyan.baidu.com/article/64d05a023cd849de55f73be4.html" target="_blank" rel="noopener">命令行安装sublime text 3</a></p></li><li><p>概括：三条命令即可</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/sublime-text-3</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sublime-text-installer</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust环境安装+换中科大源</title>
      <link href="/2019/02/03/Rust%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2019/02/03/Rust%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>vct说Rust环境配置很复杂，小李哥不信邪地来打算试一试。</p><p>操作系统：Ubuntu 16.04</p><h1 id="1-安装curl"><a href="#1-安装curl" class="headerlink" title="1-安装curl"></a>1-安装curl</h1><blockquote><p>$ apt install curl</p></blockquote><h1 id="2-安装rustup"><a href="#2-安装rustup" class="headerlink" title="2-安装rustup"></a>2-安装rustup</h1><blockquote><p>$ curl <a href="https://sh.rustup.rs" target="_blank" rel="noopener">https://sh.rustup.rs</a> -sSf | sh</p></blockquote><p>这个命令会帮你装好rustc, cargo等一系列后面要用到的东西，可以说是一键安装了。</p><p>中途会遇到这个3个选项，需要选一个，手动输入1，回车。</p><p><img src="/2019/02/03/Rust环境安装/rustup安装选项.png" alt="rustup安装选项"></p><p>安装成功后提示</p><p><img src="/2019/02/03/Rust环境安装/rustup安装成功.png" alt="rustup安装成功"></p><p>然后<strong>重启系统</strong>，重启会使得<strong>rust被添加到PATH中</strong>。这一步很重要。</p><p>重启后，查看是否成功。</p><blockquote><p>$ rustc —version</p></blockquote><p><img src="/2019/02/03/Rust环境安装/rustc版本.png" alt="rustc版本"></p><h1 id="3-Hello-world"><a href="#3-Hello-world" class="headerlink" title="3-Hello, world!"></a>3-Hello, world!</h1><p>Rust源文件以.rs结尾，文件中的单词以下划线分割，编写hello_world.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译+运行</p><blockquote><p>$ rustc hello_world.rs -o hello_world</p><p>$ ./hello_world</p></blockquote><p>如果显示如下，那便成功了。</p><p><img src="/2019/02/03/Rust环境安装/Hello_world.png" alt="Hello_world"></p><h1 id="4-换中科大的源"><a href="#4-换中科大的源" class="headerlink" title="4-换中科大的源"></a>4-换中科大的源</h1><p>按照上面完成后，rustc和cargo都应该自动装好了。但问题在于，速度不够快。使用cargo管理项目的时候，会涉及更新问题，但rust是被墙挡在外面的，更新速度慢是小事，可是卡的根本更新不了，就是大事了。</p><p>所以我们需要，换 <strong>中科大的源</strong> 。</p><p>操作如下：</p><ul><li>在完成上面的步骤的基础上</li><li>进入<strong>root</strong>目录，如果有 <strong>.cargo</strong> 目录就进入(应该是一个隐藏目录，用 <code>ls -a</code> 查看)，没有就新建一个 <strong>.cargo</strong> 目录，然后进入</li><li>进入 <strong>.cargo</strong> 目录后，如果有 <strong>config</strong> 文件就打开，没有就新建 <strong>config</strong> 文件</li><li><p>在 <strong>config</strong> 文件中写入如下内容，保存退出</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class="line">replace-with = &apos;ustc&apos;</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;git://mirrors.ustc.edu.cn/crate.io-index&quot;</span><br></pre></td></tr></table></figure></li><li><p>然后重启一下系统就行了，以后更新就不用翻墙啦。</p></li></ul><h1 id="5-疑难杂症"><a href="#5-疑难杂症" class="headerlink" title="5-疑难杂症"></a>5-疑难杂症</h1><p>小李哥遇到一个奇怪的问题，就是2-安装rustup完成后，重启，查看version后发现是ok的。结果装了个vim，敲完hello_world.rs，编译的时候它提示：找不到rustc！我再查看version的时候发现我的rustc没了？！</p><p>很玄学……我重启了一下系统就好了，原因未知。</p><p>emmm……查看cargo的version时再次遇到找不到cargo！rustc也找不到了！和上次的共同之处在于：我试图关闭终端的时候提示还有进程在运行，然后我直接关掉终端，再次打开终端，cargo和rustc再次出现！</p><p>真奇怪啊……</p><p>见鬼图↓，估计和环境变量有关系，应该是我自己的问题……</p><p><img src="/2019/02/03/Rust环境安装/su后找不到rustc.png" alt="su后找不到rustc"></p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 环境安装 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS2019_winter</title>
      <link href="/2019/01/31/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/31/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经一年半的学习，发现计科本科生课程中与计算机原理相关的课程多是隔靴搔痒，用到时再查书/百度也不迟，故接下来的课程中将关注点放在各章的开头1~2节，若有兴趣再继续深入。</p><p>参考书目：《操作系统教程（第5版）》费翔林</p><hr><h1 id="第一章-操作系统概论"><a href="#第一章-操作系统概论" class="headerlink" title="第一章 操作系统概论"></a>第一章 操作系统概论</h1><p><strong>PPT内容主要讲述以下问题：</strong></p><h2 id="1-单道-多道程序的CPU效率问题。"><a href="#1-单道-多道程序的CPU效率问题。" class="headerlink" title="1. 单道/多道程序的CPU效率问题。"></a>1. 单道/多道程序的CPU效率问题。</h2><h2 id="2-对于一个操作系统来说，它要有哪些功能？"><a href="#2-对于一个操作系统来说，它要有哪些功能？" class="headerlink" title="2. 对于一个操作系统来说，它要有哪些功能？"></a>2. 对于一个操作系统来说，它要有哪些功能？</h2><h2 id="3-从发明至今，有哪些操作系统，特点是什么？"><a href="#3-从发明至今，有哪些操作系统，特点是什么？" class="headerlink" title="3. 从发明至今，有哪些操作系统，特点是什么？"></a>3. 从发明至今，有哪些操作系统，特点是什么？</h2><hr><h1 id="第三章-同步、通信与死锁"><a href="#第三章-同步、通信与死锁" class="headerlink" title="第三章 同步、通信与死锁"></a>第三章 同步、通信与死锁</h1><p><strong>PPT内容主要讲述以下问题：</strong></p><h2 id="什么是并发进程"><a href="#什么是并发进程" class="headerlink" title="什么是并发进程"></a>什么是并发进程</h2><hr><h2 id="并发进程与时间无关的充分条件Bernstein条件"><a href="#并发进程与时间无关的充分条件Bernstein条件" class="headerlink" title="并发进程与时间无关的充分条件Bernstein条件"></a>并发进程与时间无关的充分条件Bernstein条件</h2><blockquote><p><strong>Bernstein条件</strong>：</p><p>设进程<strong>A</strong>引用变量集合为<strong>R1</strong>，改变变量集合为<strong>W1</strong>，进程<strong>B</strong>引用变量集合为<strong>R2</strong>，改变变量集合为<strong>W2</strong>。那么只要满足：</p><p>(R1 ∩ W2) ∪ (R2 ∩ W1) ∪ (W1 ∩ W2) = ∅</p><p>那么进程<strong>A</strong>和进程<strong>B</strong>与时间无关。</p><p>简而言之就是A和B的读写不冲突，也不会往同一个变量里写。</p></blockquote><hr><h2 id="并发进程间的交互："><a href="#并发进程间的交互：" class="headerlink" title="并发进程间的交互："></a>并发进程间的交互：</h2><ul><li>竞争关系/间接制约关系：对于同一资源区，进程互斥访问，一个进程在用资源区的时候，其他进程只能等着</li><li>协作关系/直接制约关系：进程间互发信号控制对方是沉睡还是唤醒</li></ul><hr><h2 id="并发进程引起的时间问题："><a href="#并发进程引起的时间问题：" class="headerlink" title="并发进程引起的时间问题："></a>并发进程引起的时间问题：</h2><ul><li>结果不唯一，比如订票，抢红包</li><li>永远等待</li></ul><hr><h2 id="临界区-critial-section-是什么？"><a href="#临界区-critial-section-是什么？" class="headerlink" title="临界区(critial section)是什么？"></a>临界区(critial section)是什么？</h2><blockquote><p>定义：共享资源所在程序段</p><p>调度原则：</p><ul><li>一次只能进一个</li><li>里面的，不能一直呆在里面</li><li>外面的，不能一直等在外面</li><li>有空让进，无空等待，择一而入，算法可行</li></ul></blockquote><hr><h2 id="临界区管理方法："><a href="#临界区管理方法：" class="headerlink" title="临界区管理方法："></a>临界区管理方法：</h2><ul><li><p>先检测，后置位。弊端是检测完后可能有其他进程也进入临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inside1, inside2: Boolean</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br><span class="line">inside2 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>先置位，后检测。弊端是置位后可能inside2又被置1，可能永远等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="临界区管理软件方法："><a href="#临界区管理软件方法：" class="headerlink" title="临界区管理软件方法："></a>临界区管理软件方法：</h2><ol><li><p>Dekker算法</p><blockquote><p>基本思想：</p><ol><li>进程P1进入临界区时，将inside1置为true。</li><li>若P2在临界区，则P1等待。若P2不在临界区但也想进入，询问turn变量，由turn指示谁进入。若P2不在临界区且不想进入临界区，那么P1进入临界区。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Peterson算法</p><blockquote><p>基本思想：</p><ol><li>进程P1进入临界区时，将inside1置为true，指示器turn置为2。</li><li>若P2在临界区内且turn为2，则P1等待。否则P1进入临界区，然后inside1置为false。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol><hr><h2 id="临界区管理硬件方法："><a href="#临界区管理硬件方法：" class="headerlink" title="临界区管理硬件方法："></a>临界区管理硬件方法：</h2><ol><li><p>关中断</p><p> 进入临界区前关中断，进入临界区，出临界区后开中断</p></li><li><p>用TS指令(test and set)</p><p> 反复TS代表临界区的lock变量，即“上锁”，如果该临界区空闲，会返回true，否则返回false。如果空闲，就进入临界区，否则一直反复。出临界区后lock置为true，即“开锁”。</p><blockquote><p>TS(x)指令等价于这段代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TS</span><span class="params">(<span class="keyword">bool</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">true</span>)&#123;</span><br><span class="line">        x = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><ol><li><p>用SWAP指令(在x86-64架构下是XCHG指令)</p><p> 一开始置临界区的lock变量为false，进程P的变量为key，置为true。交换一次lock和key(“上锁”)就检测一次key，如果key为false，说明临界区此时为空闲，进入临界区，出来后再次交换lock和key，即“开锁”。</p><p> 代码：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> lock = <span class="literal">false</span>;</span><br><span class="line">cobegin</span><br><span class="line">    <span class="function">process <span class="title">P</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            SWAP(key, lock);    <span class="comment">//上锁</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(key);</span><br><span class="line">        临界区;</span><br><span class="line">        SWAP(key, lock);        <span class="comment">//开锁</span></span><br><span class="line">    &#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h2><p><del>书上没讲定义，按我的理解就是对共享资源的读写一致性问题，说白了还是前面的并发进程问题没解决呗</del>。</p><p>百度说，进程同步是指的进程相互协作、等待的过程。</p><p>同步的办法有3种，信号量与PV操作、管程、消息传递。</p><hr><h2 id="信号量与PV操作"><a href="#信号量与PV操作" class="headerlink" title="信号量与PV操作"></a>信号量与PV操作</h2><p>信号量用来表示一个物理资源的使用情况，PV操作用来控制资源使用。</p><p>同步原语：P(Proberen,测试)，V(Verhogen,增量)。</p><p>除了赋初值外，信号量只能由同步原语操作。</p><p>(所谓原语，就是一段在执行过程中不许中断的指令序列)</p><hr><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><hr><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><hr><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><hr><h2 id="具体问题的解决方案"><a href="#具体问题的解决方案" class="headerlink" title="具体问题的解决方案"></a>具体问题的解决方案</h2><ul><li>生产者-消费者问题</li><li>五个哲学家吃通心面问题</li><li>读者-写者问题</li><li>理发师问题</li></ul><hr><h1 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h1><h2 id="成绩组成"><a href="#成绩组成" class="headerlink" title="成绩组成"></a>成绩组成</h2><p>平时作业：10%<br>实验：30%<br>期中：10%<br>期末：50%</p><p>实验类似PA，阶段之间有联系，硬DDL<br>期中讲完3章考</p><h1 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>一些敏感系统不用操作系统的原因：</p><ol><li>直接汇编放内存速度快</li><li>防止出错？？</li></ol><p>裸机：未安装操作系统的计算机</p><p>操作系统的主要目标：</p><ol><li>扩大机器功能</li><li>管理系统资源</li><li>提高系统效率</li><li>构筑开发环境</li><li>方便用户使用</li></ol><p>资源管理技术：复用、虚拟、抽象</p><h2 id="资源复用"><a href="#资源复用" class="headerlink" title="资源复用"></a>资源复用</h2><h3 id="空分复用共享"><a href="#空分复用共享" class="headerlink" title="空分复用共享"></a>空分复用共享</h3><p>例如，将内存、磁盘，按4KB一页划分，分配给不同进程。</p><h3 id="时分复用共享"><a href="#时分复用共享" class="headerlink" title="时分复用共享"></a>时分复用共享</h3><p>时分独占式：<br>进程1使用一个完整周期后才释放资源。</p><p>时分共享式：<br>例如，将CPU使用时间分为若干个时间片，进程1使用第1、3、5片，进程2使用第2、4、6片…</p><h2 id="资源虚拟"><a href="#资源虚拟" class="headerlink" title="资源虚拟"></a>资源虚拟</h2><p>把物理资源变成逻辑上的多个对应物。<br>例如，计算机连接到打印机，发送打印命令时，先发到虚拟的打印机，等一个打印文件完全发到虚拟打印机后，物理打印机才开始打印。有多个文件请求打印时，进入虚拟的打印机的队列。</p><h2 id="资源抽象"><a href="#资源抽象" class="headerlink" title="资源抽象"></a>资源抽象</h2><p>用软件来屏蔽硬件实现细节，只要调用API就行了</p><p>操作系统：管理计算机硬件资源的系统软件，为用户提供交互界面，提升硬件使用效率，主要方法是复用、虚拟和抽象。<br>2019-2-26</p><hr><h2 id="认识操作系统的四种观点"><a href="#认识操作系统的四种观点" class="headerlink" title="认识操作系统的四种观点"></a>认识操作系统的四种观点</h2><h3 id="服务用户观点"><a href="#服务用户观点" class="headerlink" title="服务用户观点"></a>服务用户观点</h3><p>系统调用向API提供服务</p><p>操作系统提供良好的人机界面</p><h3 id="进程交互观点"><a href="#进程交互观点" class="headerlink" title="进程交互观点"></a>进程交互观点</h3><p>操作系统作为<strong>进程执行的控制者和执行者</strong></p><ul><li>OS需要提供机制，解决并发进程的<strong>互斥、同步、通信和死锁问题</strong></li></ul><h3 id="系统实现观点"><a href="#系统实现观点" class="headerlink" title="系统实现观点"></a>系统实现观点</h3><p>操作系统作为扩展机或虚拟机，把硬件的复杂性与用户隔离开来。</p><ul><li>把操作系统分为若干层次，逐步添加到裸机上，系统功能就能增加一点形成操作系统虚拟机</li><li>扩充后的虚拟机不仅能使用<strong>硬件指令</strong>，还能使用<strong>系统指令</strong></li></ul><h3 id="资源管理观点"><a href="#资源管理观点" class="headerlink" title="资源管理观点"></a>资源管理观点</h3><p>操作系统对软硬件资源进行<strong>资源复用、虚拟和抽象</strong></p><p>管理各种资源</p><h2 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h2><h3 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h3><p>多道程序设计，提高处理器效率。</p><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><p>主要是管理内存，包括</p><ul><li>内存分配</li><li>地址转换</li><li>存储保护</li><li>内存共享</li><li>存储扩充</li></ul><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>主要任务</p><ul><li>管理外设</li><li>发挥设备的并行性</li><li>提供设备驱动程序和中断处理程序</li></ul><p>核心功能</p><ul><li>设备中断处理</li><li>缓冲区管理</li><li>设备独立性<ul><li>实现逻辑设备到物理设备之间的映射</li></ul></li><li>设备的分配和回收</li><li>共享型设备的驱动调度</li><li>虚拟设备</li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>对用户文件和系统文件进行管理</p><ul><li>文件逻辑组织方法</li><li>文件物理组织方法</li><li>文件存取和使用方法</li><li>文件目录管理</li><li>文件共享和安全性控制</li></ul><h3 id="网络与通信管理"><a href="#网络与通信管理" class="headerlink" title="网络与通信管理"></a>网络与通信管理</h3><p>通过网络协议进行管理</p><h2 id="操作系统主要特性"><a href="#操作系统主要特性" class="headerlink" title="操作系统主要特性"></a>操作系统主要特性</h2><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><p>并发：指的是两个或两个以上的事件在同一时间间隔内（比如1分钟内）发生<br>并行：在同一时刻发生</p><p>要求实现多个进程间的安全切换</p><h3 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h3><p>解决读写一致问题、临界区之类的问题</p><h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><p>进程的开始、暂停、前进速度都是随机的</p><p>作业到达系统的类型和时间是随机的</p><p>操作员发命令或按按钮的时刻是随机的</p><p>程序出错是随机的</p><p>软硬件中断是随机的</p><p><strong>所以需要解决和时间有关的错误</strong></p><h2 id="多道程序设计效果"><a href="#多道程序设计效果" class="headerlink" title="多道程序设计效果"></a>多道程序设计效果</h2><ol><li><p>提高了系统效率</p></li><li><p>延长了每道题的计算时间</p></li><li><p>牺牲了用户的响应时间</p></li></ol><p>假设程序等待IO的时间占其运行时间比为p，n道程序同时等待的概率是$p^n$，那么CPU效率是$1-p^n$。</p><h2 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h2><p>作业是指把程序、数据连同作业说明书组织起来的任务单位</p><p>批作业是指把批中的作业预先输入作业队列，由操作系统按照说明来调度和控制作业执行，形成自动转接和连续处理作业。</p><p>特点：</p><ul><li>用户脱机工作</li><li>成批处理作业</li><li>多道程序运行</li><li>作业周转时间长</li></ul><h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><ul><li>多个联机用户同时使用一个计算机系统在各自的终端上进行交互式对话</li><li>程序、数据和命令都在会话过程中产生，通过问答方式控制程序</li><li>处理器分为时间片给不同用户</li></ul><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><ul><li>外部事件产生时，快速处理</li></ul><hr><p>地址转换</p><p>2019-2-28</p><hr>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
