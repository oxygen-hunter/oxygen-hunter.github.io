<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习笔记</title>
      <link href="/2019/02/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>机器学习复习笔记</p><p>参考书目：西瓜书</p><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="课程任务"><a href="#课程任务" class="headerlink" title="课程任务"></a>课程任务</h2><ol><li>平时作业40%</li><li>期中30%</li><li>期末30%（投票决定闭卷/半开卷）</li></ol><p>平时作业有2次取较高分作为期中成绩，其他4次作为平时成绩<br>半开卷：允许带一张a4纸，上面写什么都可以，考完交a4纸</p><h2 id="机器学习示例："><a href="#机器学习示例：" class="headerlink" title="机器学习示例："></a>机器学习示例：</h2><p>文献筛选<br>在<code>循证医学</code>中，针对特定临床问题，要先查文献进行详细研究评估。<br>提取摘要-&gt;人工筛选。应用机器学习后专家读少量文献，标记有关/无关，模型去读剩下来的文献。</p><p>搜索引擎<br><code>用机器学习解决排序问题</code></p><p>战场战术层面<br><code>损害管制自主机器人</code><br><code>罗盘系统</code></p><h2 id="典型的机器学习过程："><a href="#典型的机器学习过程：" class="headerlink" title="典型的机器学习过程："></a>典型的机器学习过程：</h2><p>给模型以数据（包含一系列属性+1个label），训练，检测。</p><h2 id="几个分类："><a href="#几个分类：" class="headerlink" title="几个分类："></a>几个分类：</h2><p><code>符号主义学习</code>、<code>连接主义学习</code></p><p>贝叶斯学派：<br>第1天，太阳升起，建立模型，预测明天太阳升起概率1/2<br>第2天，太阳升起，修正参数，预测明天太阳升起概率1/3<br>…<br>第30000天，预测30000/300001</p><p>非贝叶斯学派：<br>第1天，太阳升起，预测1<br>第2天，太阳升起，预测1<br>…<br>第30000天，根据之前的事实证据，认为太阳升起概率恒为1</p><h2 id="面临问题"><a href="#面临问题" class="headerlink" title="面临问题"></a>面临问题</h2><p>现在的问题在于大厂缺少需求，算力过剩。Google收购DeepMind是为了消耗TPU，AI实际上是互联网商们的一个出口。</p><p>鲁棒性不行，人类棋手犯错，从九段跌到八段，机器犯错，从九段跌到业余。</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>预测目标：</p><ul><li>分类：最后的输出是离散值<ul><li>二分类：好瓜、坏瓜</li><li>多分类：冬瓜、南瓜、西瓜</li></ul></li><li>回归：连续值<ul><li>瓜的成熟度</li></ul></li><li>聚类：无标记信息（物以类聚/具有相同hash feature的数据被hash后放入同一个桶/韩信点兵/等价类划分）</li></ul><p>有无标记信息：</p><ul><li>监督学习：分类、回归</li><li>无监督学习：聚类</li><li>半监督学习：两者结合</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论定理收集</title>
      <link href="/2019/02/26/%E5%9B%BE%E8%AE%BA%E5%AE%9A%E7%90%86%E6%94%B6%E9%9B%86/"/>
      <url>/2019/02/26/%E5%9B%BE%E8%AE%BA%E5%AE%9A%E7%90%86%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>参考书目：《图论与网络理论》和ppt</p><p>要求：复习的时候都会证明</p><h1 id="第一章-图的基本概念"><a href="#第一章-图的基本概念" class="headerlink" title="第一章 图的基本概念"></a>第一章 图的基本概念</h1><p>定理1.1.1 对任何图 $ G $ ，各顶点度数之和等于边数的2倍.即 $ \sum\limits_{\nu\in V(G)}d(\nu) = 2\varepsilon. $</p><p>推论1.1.1 任何图中，奇度顶点个数为偶数.</p><p>例1.1.2 设 $ G $ 是一个简单图，若最小度 $ \delta(G) \geq 2 $，则 $ G $ 中必含有圈.</p><p>例1.1.3 设 $ G $ 是一个简单图，若最小度 $ \delta(G) \geq 3 $，则 $ G $ 中必含有偶圈.</p><p>例1.1.4 设 $ G $ 是简单图，若最小度 $ \delta(G) \geq 3 $，则 $ G $ 中各个圈长的最大公因数是1或2.</p><p>定理1.1.2 一个图是二部图当且仅当它不含有奇圈.</p><p>定理1.1.3 如果图 $ G $ 连通，$ \varepsilon(G) \geq \nu(G)-1 $.</p><p>例1.1.6 设图 $ G $ 有 $ 2n $个顶点，$ \delta(G) \geq n $，求证 $ G $ 连通.</p><p>例1.1.7 求证：若图中有且仅有2个奇度顶点，则它们必然连通.</p><p>定理1.3.1<br>下列命题等价</p><ol><li>$ G $ 是树（无圈的连通图）.</li><li>$ G $ 无环边且 $ G $ 中任意两个顶点间有唯一的路.</li><li>$ G $ 无圈且 $ \varepsilon = v-1 $.</li><li>$ G $ 连通且 $ \varepsilon = v-1 $.</li><li>$ G $ 连通且对于任意 $ e \in E(G)$，$ G-e $ 不连通.</li><li>$ G $ 无圈且对于任意 $ e \in E(\overline{G}) $，$ G+e $ 恰有一个圈.</li></ol><hr><p>定理2.1.3 设 $ v $ 是树的顶点，则 $ v $ 是 $ T $ 的割点当且仅当 $ d(v)&gt;1 $.</p><p>推论2.1.1 每个非平凡无圈连通图至少有2个顶点不是割点.</p><p>定理2.1.5 边 $ e $ 是割边当且仅当 $ e $ 不在 $ G $ 的任何一个圈上.</p><p>定理2.2.1 $ \kappa(G) \leq \kappa’(G) \leq \delta(G) $</p><p>定理2.2.2 对具有 $ v $ 个顶点 $ \varepsilon $，有$ \kappa(G) \leq \lfloor \frac{2\varepsilon}{v} \rfloor $.</p><p>定理2.2.3 设 $ G $ 是一个简单图，$ k $ 是一个自然数，若$ \delta(G) \geq \frac{v+k+2}{2} $，则 $ G $ 是连通的.</p><p>推论2.2.1 设 $ G $ 是一个简单图，若 $ \delta(G) \geq \frac{v-1}{2} $，则 $ G $ 是连通图。</p><p>定理2.2.4 设 $ G $ 是一个直径为2的简单图，则 $ \kappa’(G)=\delta(G) $.</p>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高程学习笔记</title>
      <link href="/2019/02/26/%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/26/%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>高级程序设计复习笔记</p><p>参考书目：<br>《程序设计教程—用C++语言描述》陈家骏、郑滔<br>《Thinking in C++》机械工业出版社</p><h1 id="第一章-复习程设基础"><a href="#第一章-复习程设基础" class="headerlink" title="第一章 复习程设基础"></a>第一章 复习程设基础</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>分数组成：<br>作业10%<br>上机40%（现场oj和课后projects）<br>期末50%（据说较为简单）</p><h2 id="C-C-数据类型"><a href="#C-C-数据类型" class="headerlink" title="C/C++数据类型"></a>C/C++数据类型</h2><p><code>unsigned</code>类型运算不封闭，+*/封闭，-不封闭</p><p><code>float</code>类型 0.1+0.2!=0.3之类的</p><p><code>实数</code>相等条件，比较差的绝对值是否小于一个很小的数</p><p>联合类型用于用一种类型表示多种类型的数据，例如不同类型的数据组织在一起不能用array</p><p>指针是内存地址的抽象，用于动态变量（链表）、传递参数</p><h2 id="C-过程抽象"><a href="#C-过程抽象" class="headerlink" title="C++过程抽象"></a>C++过程抽象</h2><p><code>C++函数</code>与<code>数学函数</code>区别：</p><ol><li>C++函数可以没有返回值</li><li>可以有副作用(side effect)</li><li>同一个实参，不同时刻调用结果可以不一样</li></ol><h2 id="内存区安排"><a href="#内存区安排" class="headerlink" title="内存区安排"></a>内存区安排</h2><p>静态数据区</p><ul><li>全局变量</li><li>static局部变量</li><li>常量</li></ul><h1 id="第2章-对象与类"><a href="#第2章-对象与类" class="headerlink" title="第2章 对象与类"></a>第2章 对象与类</h1><p>把成员函数定义放在声明处，是建议编译器按内联函数处理。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>创建动态对象不用 malloc 和 free，原因是不会调用构造函数和析构函数。</p><p>无参数或全是默认参数的构造函数，是默认构造函数</p><p>隐式的构造函数仅调用<code>成员对象</code>所在类和基类的构造函数</p><p>一旦随便自定义了构造函数，编译器不再提供隐式构造函数</p><p>隐式的析构函数仅调用<code>成员对象</code>所在类和基类的析构函数</p><p>复制字符串时候 new char(strlen(str) <strong>+ 1</strong>)</p><h3 id="数据成员初始化"><a href="#数据成员初始化" class="headerlink" title="数据成员初始化"></a>数据成员初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span>&amp; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;a = <span class="number">1</span>;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> m, <span class="keyword">int</span> n):b(m), c(n)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    A a;</span><br><span class="line">    A1 a1;</span><br><span class="line">    A2 a2;</span><br><span class="line">    A3 a3;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;x = <span class="number">1</span>;&#125;</span><br><span class="line">    B(<span class="keyword">int</span> m):a(m, m)&#123;x = <span class="number">7</span>;&#125;</span><br><span class="line">    ~B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const int 和 int&amp; 数据成员必须用成员初始化表，如果这样的类不自定义构造函数，编译器不会为其生成默认构造函数，因此这样的类不能用于构造对象？</p><p>成员对象的初始化：默认按照成员对象的默认构造函数来，除非用<strong>成员初始化表</strong>进行显式调用，顺序 A1-A2-A3-B函数体，析构顺序 B函数体-A3-A2-A1</p><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A(<span class="keyword">const</span> A&amp; a);</span><br><span class="line">A(<span class="keyword">const</span> A&amp; a, <span class="keyword">int</span> m = <span class="number">1</span>, <span class="keyword">int</span> n = <span class="number">2</span>); <span class="comment">// 后面的必须是默认参数</span></span><br><span class="line">A(<span class="keyword">const</span> A a); <span class="comment">// 不行，考虑下面的例子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A re;</span><br><span class="line">    f(re); </span><br><span class="line">    <span class="comment">// 调用时，x需要用re初始化，相当于A x=A(re)</span></span><br><span class="line">    <span class="comment">// re又作为参数去初始化const A a，相当于A a = A(re)...无限递归[UST]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐式拷贝构造函数：普通成员直接拷贝（涉及资源申请的小心），成员对象调用它的拷贝构造函数</p><p>自定义拷贝构造函数：默认按照成员对象的默认构造函数来，除非用<strong>成员初始化表</strong>显式调用成员对象的拷贝构造函数，如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    A a;</span><br><span class="line">    B(<span class="keyword">const</span> B&amp; b):a(b.a) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h2><p>const 对象不能调用非 const 成员函数，所以<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="keyword">const</span> A* pa); <span class="comment">// *pa无法被改变</span></span><br><span class="line">f(<span class="keyword">const</span> A&amp; a); <span class="comment">// a无法被改变</span></span><br></pre></td></tr></table></figure></p><p>const 成员函数可以重载，效果[UST]<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 谁调用？</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// A a 和 const A a？</span></span><br></pre></td></tr></table></figure></p><p>题外话<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p / <span class="keyword">int</span> <span class="keyword">const</span> * p; <span class="comment">// *p无法修改</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p <span class="comment">// p无法修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p <span class="comment">// *p和p均无法修改</span></span><br><span class="line">记忆方式：<span class="keyword">const</span>的右边第一个是*还是p</span><br></pre></td></tr></table></figure></p><h2 id="static-成员"><a href="#static-成员" class="headerlink" title="static 成员"></a>static 成员</h2><p>算是 class 的属性，所有对象共享。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    static int x = 0; // 或者类外 x = 1 都行</span><br><span class="line">    static B b; // 类外定义</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::x = 1; // ok</span><br><span class="line">int main() &#123;</span><br><span class="line">    A::x = 1; // error，别的函数看不到这一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>访问 private 和 protected</p><h2 id="转移构造函数"><a href="#转移构造函数" class="headerlink" title="转移构造函数"></a>转移构造函数</h2><p>系统自动调用，用于返回一个对象的时候，节约资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A(A&amp;&amp; x) &#123;</span><br><span class="line">    p = x.p;</span><br><span class="line">    x = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>作为类的非静态成员函数</p><p>单目还是单目，双目还是双目。</p><p><em>既作为解引用，又作为乘法，咋办？[UST][CJJ: </em>默认已经作为解引用重载好了，只管乘法就行]</p><p>“.”, “.*”, “::”, “?:”, “sizeof” 不能重载</p><p>A&amp; operator++(); // 效果++a<br>A operator++(int i); // 效果a++</p><h3 id="操作符重载-1"><a href="#操作符重载-1" class="headerlink" title="= 操作符重载"></a>= 操作符重载</h3><p>=操作符被隐式重载，但如果类中有 const int 和 int&amp; 成员时，=不会隐式重载。</p><p>同拷贝构造函数的理，=操作符同样有即将消亡的对象赋值浪费的问题。<br>改进方法如下，该调用的时候编译器自动调用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>=(A&amp;&amp; x) &#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;x = *<span class="keyword">this</span>)&#123; <span class="comment">// 防止递归</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] x.p; <span class="comment">// 释放原来的资源</span></span><br><span class="line">    p = x.p; <span class="comment">// 转移资源</span></span><br><span class="line">    x.p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="new-重载"><a href="#new-重载" class="headerlink" title="new 重载"></a>new 重载</h3><p>作为类的 static 函数重载，static 可以不写<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span> <span class="comment">// size_t size必须有，别的无所谓</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> x)</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记</title>
      <link href="/2019/02/25/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/25/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>计算机网络（Computer Network）复习笔记</p><p>参考书目：《计算机网络自顶向下方法（第5版）》机械工业出版社</p><h1 id="CH1-Introduction-of-Networking-1"><a href="#CH1-Introduction-of-Networking-1" class="headerlink" title="CH1-Introduction of Networking-1"></a>CH1-Introduction of Networking-1</h1><h2 id="杂记："><a href="#杂记：" class="headerlink" title="杂记："></a>杂记：</h2><p>CN负责数字通信（数字信号）</p><p>哈罗车筐前黑色是太阳能板？</p><p>宿舍-一层-一楼-学校网络中心-南京教育网（东大）-全国教育网</p><p>第一台联网计算机在UCLA</p><p>remote medicine 瓶颈在于时延</p><p>行星间联网，光速瓶颈</p><p>因特网是一个复杂系统，分解为<strong>5个子问题</strong>，谁来分解？如何分解？</p><hr><h2 id="课程主要讲述："><a href="#课程主要讲述：" class="headerlink" title="课程主要讲述："></a>课程主要讲述：</h2><ol><li>因特网如何工作？</li><li>子问题为什么这样解决？</li></ol><h2 id="讲解顺序："><a href="#讲解顺序：" class="headerlink" title="讲解顺序："></a>讲解顺序：</h2><ol><li>基础：包、链路、复用、时延、丢包</li><li>低级技术：以太网，无线局域网，3g，4g</li><li>IP，路由，BGP</li><li>网络互通后如何交换信息：DNS,CDN,HTTP,TCP</li><li>热点问题：数据中心、</li></ol><h2 id="课程任务："><a href="#课程任务：" class="headerlink" title="课程任务："></a>课程任务：</h2><ol><li>实验25%（现场提问，验收，改代码，严格）</li><li>作业15%</li><li>期末考试60%</li></ol><hr><h2 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h2><ol><li>电路交换：最基础的交换方式。点对点<br> 特点：<ol><li>中间所有资源都预留好</li><li>admission control per connection</li></ol></li><li>包交换：大家都把数据分为小数据包，一股脑发到交换机，交换机再转发，自由竞争，冲突了就丢一个，一个小包失败了就再发一次。（核心思想：统计复用）<br> 特点：<ol><li>包独立处理</li><li>admission control per packet</li></ol></li><li>虚链路：在包交换中模拟电路交换给vip用户优先权，以便冲突时优先满足vip用户</li></ol><hr><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>电路交换：在两点之间建立通道，src和dst之间直接连接（中间类似于多刀多掷开关）</p><p>建链-传输-拆链。想象成老电影里的电话局，处长和局长通话需要接线员接线、通话、拔线。</p><p>时间分片：比如，将1ms分为1000片，1000个用户同话，用户1通话时只占用1ms的第1片，然后若干个1ms组成了通话时间。如果有人通话量大，就多分几片。</p><p>频率分片：将频率切片，比如1Mhz的一段切成100片分给不同的用户，实际上要分很多级/空间复用，不然没法满足几亿用户的分配需求，频率之间不干扰，频率由国家法律严格控制，比如联通被分在800-850Mhz。</p><p>低频波的波长长，容易绕开障碍物。所以停用2G用户，这样子那一段频率就可以用来给5G了。</p><p>1G频分，2G时分，后面的利用更高级原理。</p><p><img src="/2019/02/25/计网学习笔记/" alt="电路交换的时序图1"></p><p><strong>为什么建链时有delay，拆链时没有delay？</strong><br>因为建链时，需要预留电路，要时间，可能会失败。拆链直接拆就行。</p><p><img src="/2019/02/25/计网学习笔记/" alt="电路交换的时序图2"></p><p>传输data时，不一定是连续的，不传输的时候就浪费了。比如2G/3G时代的手机QQ，发一个消息要建链-拆链一次，电费消耗大。在传大文件或者看电影才划算。</p><p><strong>优点：</strong></p><ol><li>predictable performance（保证一定送到，速度也有保障）</li><li>simple/fast switching (once circuit established)（建链后很简单）</li></ol><p><strong>缺点：</strong></p><ol><li>complexity of circuit setup/teardown（建链和拆链很麻烦）</li><li>inefficient when traffic is bursty（上述手机QQ的浪费、驿站的一匹马只运输一串荔枝，但实际上可以驼很多东西，这些空间浪费了。）</li><li>circuit setup adds delay（建链需要一来一回，增加时延，聊微信会很花时延）</li><li>switch fails-&gt;circuit fails（建链失败就完蛋）</li></ol><p>相似工作原理：华为手机之所以省电，在于有1个主CPU和几个小CPU，微信等通过小CPU。天线也是自己开屏幕才会工作，所以微信可能会收到不及时。</p><hr><h2 id="包交换"><a href="#包交换" class="headerlink" title="包交换"></a>包交换</h2><p>包交换：通信时像快递一样，只要写好每个数据包发货地址和收货地址，交换机只要负责查地址，就可以发了。核心思想是<code>统计复用</code>。</p><p>不保证性能：如果一大堆人同时发包，只能送一个，其他丢掉。或者用一个buffer缓存一下，再发。</p><p><strong>优点：</strong></p><ol><li>Efficient use of network resources</li><li><strong>simpler to implement</strong>（要求交换机做的事情很少，复杂的事交给端系统完成，就很便宜）</li><li>robust: can “route around trouble”（不存在链路建立失败的问题，比如一家快递倒闭了我换一家就可以了）</li></ol><p><strong>缺点：</strong></p><ol><li>unpredictable performance（由于buffer容量有限，只能保证大部分快递不送丢，类比双11快递公司的爆仓）</li><li>requires buffer management and congestion control（需要管理仓库和拥塞控制，管理仓库是这个快递费20，那个快递费5块，冲突就丢掉5块的。拥塞控制是双11短期取货码（被动，拥塞已经发生）、提前两三周开始双11（主动从源头控制）、南大驿站装不下就返回到上一级驿站）</li></ol><h2 id="统计复用-statistical-multiplexing"><a href="#统计复用-statistical-multiplexing" class="headerlink" title="统计复用 statistical multiplexing"></a>统计复用 statistical multiplexing</h2><p>Allowing more demands than the network can handle.</p><ul><li><p>hoping that not all demands are required at the same time（小区接入宽带，允许10个用户100M，但只给他们分配100M，因为假定他们不会同时用网，且一家人用不了100M。）（旅馆也住不了那么多人，正常情况下不会这么多人同时去住，如果想专享线路，建个行宫吧）</p></li><li><p>results in unpredictability（世界杯期间突然爆满）</p></li><li><p>works well except for the extreme cases（爆满的情况不符合统计复用的条件）</p></li></ul><h2 id="如何评价网络性能"><a href="#如何评价网络性能" class="headerlink" title="如何评价网络性能"></a>如何评价网络性能</h2><ul><li>时延delay</li><li>丢包率loss</li><li>吞吐量throughput（速率）</li></ul><p>无线网络侧重于丢包率</p><p>数据中心侧重时延</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>Consists</p><ul><li>transmission delay (link，取决于带宽，$数据量/带宽$)</li><li>propagation delay (link，取决于路长，$长度/光速$)</li><li>queueing delay<br>(取决于来的包，冲突就进队列，队列溢出就丢掉，由于包有编号，接收端数一数123457，丢了6号，那么通知发送方重发)(按均值和variance来衡量，由排队论设计好)（数据中心的主要时延）（平均排队时长）<blockquote><p>Littes’s law(1961)<br>L = A * W</p></blockquote></li><li>processing delay (有但可以忽略不计了，和电子工业发展有关) </li></ul><p>链路带宽bandwidth：八车道的八（同时有几个比特在链路里跑）</p><p>BDP = Bandwidth * propagation delay</p><p>$1G=10^9$</p><p>对于小文件，$D_{prop}$占主导，对于大文件，$D_{trans}$占主导时延</p><p>普通交换机遵循store-forward模式，交换机收到包先存起来解析包头再发下一站。<br>端(trans,prop,queue&amp;process)交换机()交换机()端</p><p>高频交换机（高频率股票交易）不遵循上述模式<br>带宽极高不用queue，收到1bit就直接发。</p><h3 id="丢包loss"><a href="#丢包loss" class="headerlink" title="丢包loss"></a>丢包loss</h3><h3 id="吞吐率throughput"><a href="#吞吐率throughput" class="headerlink" title="吞吐率throughput"></a>吞吐率throughput</h3><p>transmission rate R bits/sec</p><p>file of size F bits<br>packets of size L bits</p><p>Transfer time(T) = F/R + propagation delay</p><p>木桶原理，端到端的速率取决于最细的那一段</p><h2 id="Little-laws的证明"><a href="#Little-laws的证明" class="headerlink" title="Little laws的证明"></a>Little laws的证明</h2><p>$<br>\begin{equation}<br>\lambda\overset{def}{=}\lim\limits_{t\to \infty} \frac{N(t)}{t}, \text{the arrival rate into the system}<br>\end{equation}<br>$</p><p>$<br>\begin{equation}<br>\omega\overset{def}{=}\lim\limits_{n\to \infty} \frac{1}{n}\sum\limits_{j=1}^{n}W_j, \text{average sojourn time}<br>\end{equation}<br>$</p><p>$<br>\begin{equation}<br>l\overset{def}{=}\lim\limits_{t\to \infty} {\frac{1}{t}\int_{0}^{t}L(s)ds}, \text{average number in system}<br>\end{equation}<br>$</p><p>$<br>L(t):\text{the total number of customers in the system at time t.}<br>$</p><p>$<br>N(t)=max\{n:t_n\leq t\}<br>$</p><p>$<br>L(t)=\sum\limits_{n=1}^{\infty}{I\{t_n\leq t\leq t_n^a\}}=<br>$</p><p>$<br>\frac{1}{t}\sum\limits_{j:t_j^{\alpha}\leq t}{W_j} \leq \frac{1}{t}\int_{0}^{t}{L(s)ds} \leq \frac{1}{t}\sum\limits_{j:t_j &lt; t}{W_j}<br>$</p><p>后者=$ \lim\limits_{t\to \infty} \frac{N(t)}{t} \frac{1}{N(t)}\sum\limits_{j=1}{N(t)}W_j $</p><p>Lemme: if $\lambda$ and $\omega$ exists and finite, then</p><script type="math/tex; mode=display">\lim\limits_{n\to \infty}{\frac{W_n}{n}=0}, \lim\limits_{n\to \infty}{\frac{W_n}{t_n}=0}</script><p>前者<img src="/2019/02/25/计网学习笔记/" alt="手机图片"></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>层与层之间没有耦合关系，所以更新时候方便。</p><p>OSI七层（L7应用层，L6表示层，L5会话层），TCP\IP五层</p><p>沙漏状的五层：（海淘）<br>应用层-CEO写的内容（确定到南大的哪个人）（千万种协议）<br>传输层-秘书（写美国哪个州哪个县）（TCP可靠，UDP不可靠）<br><strong>网络层-全球可达（only IP，基石）</strong><br>链路层-局部可达<br>物理层-计科不管</p><p>应用层-&gt;传输层，加header指明给对方的哪个进程<br>传输层-&gt;…，类似</p><p>端系统5层全要，中间的交换机只要下3层即可，负责信息的到达（联邦快递）。</p><p>传输层和网络层原本部署在 CPU 上，现在为了快速转到了网卡上。</p><p>pros:</p><ol><li>reduce complexity（分而治之）（负责分拣的就分拣，运货的就运货）</li><li>improve flexibility（每一层只对上层负责，内部实现可以改）（用飞机送和用马车送）</li></ol><p>cons:</p><ol><li>higher overheads（每一层的header，占总大小5%-8%）</li><li>cross-layer information often useful（上下层可以互相偷窥对方的内容，因为只是加了header）</li></ol><p>IP层不好改，打过了很多补丁。IPv4-&gt;IPv6的演进。就像给行驶中的高铁换轮子还不能让高铁发现。<br>IPv4是32bit的，所以它只能有4G个地址，不够用。</p><p><strong>End-to-end argument</strong><br>中间节点越简单越好，只负责转发就行了，复杂的事情交给终端。不然中间的设备太复杂成本高。</p><p>墙的效果：在物理层偷窥应用层，不符合要求就咔嚓</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>分层很棒</li><li>网络层最重要，将应用和底层完全隔离开</li><li>E2E arguments 激励我们 keep IP simple</li></ol><h1 id="第2章-链路层"><a href="#第2章-链路层" class="headerlink" title="第2章 链路层"></a>第2章 链路层</h1><p>术语<br>L3: packet<br>L2: frame</p><h3 id="data-link-layer-做的事："><a href="#data-link-layer-做的事：" class="headerlink" title="data link layer 做的事："></a>data link layer 做的事：</h3><ul><li>framing（将 L3 的 packet 封成 frame）</li><li>link access（宿舍四个人在使用同一个物理机，决定谁来用）</li><li>reliable delivery（应对错误和丢包丢 frame，用于无线网/基站通信，一个包发两次或者其他保护机制）</li><li>error detection and correction（包收到了，但内容不对，用校验码，纠错码）</li></ul><h3 id="传输方式："><a href="#传输方式：" class="headerlink" title="传输方式："></a>传输方式：</h3><ul><li>point to point（海底光缆，电话线，以太网-墙上的网口）</li><li>broadcast（无线局域网，不安全= =，几个人会同时讲话）</li></ul><h4 id="广播-broadcast"><a href="#广播-broadcast" class="headerlink" title="广播 broadcast"></a>广播 broadcast</h4><p>广播方式中，物理媒介是共享的，如何决定谁说话？</p><ul><li>channel partitioning: 切片，一人一片，类似电路交换，分频率，效率不高</li><li>taking turns: 轮流上</li><li>random access: 每个人想发就发，协议决定谁发（不避免 collision，而是解决 collision）（分布式）</li></ul><p>random access protocol(MAC)<br>do: <strong>detect and recover</strong> from collisions</p><p>所谓 protocol:</p><ul><li>pattern（先说一句hello）</li><li>senmatic（然后开始交流）</li></ul><h3 id="broadcast-Ethernet（老）"><a href="#broadcast-Ethernet（老）" class="headerlink" title="broadcast Ethernet（老）"></a>broadcast Ethernet（老）</h3><p>CD: collision detection</p><p>老的是 broadcast 方式，新的是网口直连交换机。</p><p>CSMA(carrier sense multiple access)<br>发之前监听一下，媒体空着我就说话，没空着我就等等再说<br>问题在于，有传播时延、还是有冲突没法消灭</p><p>CSMA/CD<br>limits:</p><ul><li>包的最小值</li><li>传输距离最大值</li></ul><p>原因：propagation delay</p><p>以太网最短帧限定 64bytes</p><p>Q: 冲突后 AB 都停止发送，何时重新开始？<br>AQ: 随机一段时间再发，随机多久？<br>A: binary exponential back-off（在小区间里取随机数，发，失败了就在更大区间里取随机数，重复，直到不拥塞）</p><p>CSMA/CD 效率<br>$ Efficiency \approx \frac{d_{trans}}{d_{trans}+5d_{prop}} $</p><h3 id="switched-Ethernet（新）"><a href="#switched-Ethernet（新）" class="headerlink" title="switched Ethernet（新）"></a>switched Ethernet（新）</h3><p>点到点，交换机判断 A 和 C 通信，那么 A 的消息就不往 B 和 D 发了。</p><h3 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h3><p>以太网协议除了帧格式没变，其他基本都变了，API 为帧格式。</p><p><img src="/2019/02/25/计网学习笔记/" alt="PPT图示以太网帧结构"></p><ul><li>preamble: 8 bytes 前导码，7用于时钟同步，1用于表示帧开始</li><li>address: 6 bytes，dst+source</li><li>type: 2 bytes，表明高层协议</li><li>data payload: max 1500, min 64 bytes</li><li>CRC: 4 bytes for error dectection</li></ul><p>Q: 如何决定帧在传输时，从何开始从何结束？<br>A1: 开头说明帧多长（弊端，可能会在传输中出错）<br>A2: 开头结尾加哨兵，比如0111110表示开头，01111111表示结尾（弊端，哨兵出现在 frame contents 中，提前结束）（解决方法：发送端向 frame contents 中加0，由网卡自动完成，接收端去0，使得哨兵不会出现在 contents 中）</p><p>MAC address（48 bit，二层地址，局部有效，身份证）<br>IP address（标识你在网络空间里的位置，邮政编码）</p><h3 id="路由-routing"><a href="#路由-routing" class="headerlink" title="路由 routing"></a>路由 routing</h3><h4 id="routing-with-broadcast-ethernet"><a href="#routing-with-broadcast-ethernet" class="headerlink" title="routing with broadcast ethernet"></a>routing with broadcast ethernet</h4><p>Q: 如何在广播以太网里路由？<br>A: 即插即用，都接在一根铜缆上</p><p>Q: 同一楼层用一根线，不同楼层<br>A: 用网桥 bridges，连接不同 LAN</p><p>broadcast storm 问题：假如不同 LANS 间有环路，信号永生，信号循环加强，gg</p><p>解决思路：无环路的连通图是树，给网络图找生成树，保留节点，去掉链路。</p><h5 id="spanning-tree-protocol"><a href="#spanning-tree-protocol" class="headerlink" title="spanning tree protocol"></a>spanning tree protocol</h5><p>nice properties:</p><ul><li>zero configuration（即插即用，自动配置）</li><li>self healing（坏了一台，可以迅速重新构建拓扑）</li></ul><h4 id="routing-with-switched-ethernet"><a href="#routing-with-switched-ethernet" class="headerlink" title="routing with switched ethernet"></a>routing with switched ethernet</h4><p>要求：即插即用</p><p>问题：依然存在广播数据包，交换机之间会有环<br>flooding 洪泛</p><h4 id="spaning-tree-算法"><a href="#spaning-tree-算法" class="headerlink" title="spaning tree 算法"></a>spaning tree 算法</h4><p>思想：</p><ol><li>pick a root（选一个 MAC 地址最小的作为 root，约定俗成）</li><li>计算其他节点到 root 的最短路，只保留最短路上的链路，多个最短路就选一条（比如选 MAC addr 最小的，约定俗成）</li></ol><p>算法内容：<br>[UST]见PPT</p><p>1次洪泛可以确定所有主机 MAC 地址、root 地址？<br>A 不知道 B 在哪时，就把 dst 设为全 f，总能传播到，路上的交换机也知道 A 在哪了，这样 B 再回个包就能顺利到 A</p><p>交换机干的事：</p><ol><li>看看 A 来的包以前来过没，没来过就加入 switch table</li><li>表里的项如果过了生存期还没有被使用，就删掉表项（原因：容量有限、A 可能会离开这片有线网）</li><li>收到单播数据包，当发现目标节点不认识时，就 forwarding</li></ol><h4 id="以太网-pros-and-cons"><a href="#以太网-pros-and-cons" class="headerlink" title="以太网 pros and cons"></a>以太网 pros and cons</h4><p>pros</p><ol><li>即插即用</li><li>自愈</li><li>便宜</li></ol><p>cons</p><ol><li>带宽浪费（spanning tree 把很多枝砍掉了）</li><li>重建 spanning tree 时的延迟（新插入节点的 id 是0，那么它会是新 root）</li><li>对付移动中的设备比较慢（云平台，虚拟机快速移动）</li><li>可预测性差（A 找 B 不知道找多久，但问题不大，因为很快）</li></ol><h3 id="即插即用咋实现的"><a href="#即插即用咋实现的" class="headerlink" title="即插即用咋实现的"></a>即插即用咋实现的</h3><p>Q: 一台主机来时，只有 MAC 地址，怎么知道 IP 地址，邮政编码？<br>A: ARP, DHCP protocol</p><p>功能：</p><ul><li>discovery of local end-host<ul><li>for communication between hosts on the same LAN</li></ul></li><li>bootstrap communication with remote hosts<br>  what is my<ul><li>IP addr</li><li>local DNS server</li><li>first hop router</li></ul></li></ul><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>a host uses DHCP to discover</p><ul><li>IP addr</li><li>netmask</li><li>IP addr for its local DNS name server （没有DNS也能通信，直接输入 IP 地址就行，DNS 坏了表现为 www.baidu.com 上不去，但QQ（内置了对方IP地址）可以用）</li><li>IP addr for its fist-hop “default” router(s)</li></ul><p>过程如下：<br>一个 DHCP 服务器把 IP addr，DNS addr 都弄好<br>用户先用全 f 进行广播，所有的 DHCP 服务器（一个就能工作，多个为了鲁棒）回一个 offer<br>用户选择一个，发一个 request， DHCP 服务器回一个 ACK<br>然后就能用了</p><p>DHCP uses “soft state”（软状态就好比普通内存，得不停的刷它，不然比特会翻转，所以得一直耗电，硬状态好比固态硬盘，即使不给他电，比特也不会翻转）<br>一个用户比如12小时不继续申请，DHCP server 就收回 IP addr，适用于咖啡馆这类客户用会就走了<br>如果用户在到期前“续租”，配置不会改变，应用不会断（网上银行之类，换个 IP addr 就直接断开），如果过期后续租，IP addr 可能就改了</p><p>如果用户挂了，租约到期时 DHCP 回收回<br>如果 DHCP 挂了，租约到期前用户正常使用，到期后用户企图续租，但没人鸟他，该 IP addr 就没法用了<br>如果用户和 DHCP 之间的链路挂了，用户到期前正常，到期后找别的 DHCP 服务器</p><h4 id="ARP-DNS"><a href="#ARP-DNS" class="headerlink" title="ARP, DNS"></a>ARP, DNS</h4><p>假设我的 IP addr 为 1.2.3.53<br>掩码 netmask 是 1.2.3.0/24<br>DNS IP addr 为 1.2.3.156</p><ol><li>在网页浏览器输入 www.sina.com</li><li>浏览器一看，就去问 DNS，由于在以太网内，就要知道 DNS 的 MAC addr</li><li>怎么知道呢，在以太网内广播一次，就知道哪个 MAC addr 拥有 1.2.3.156 这个 IP addr（即使要通信10000次也只要广播一次就知道 MAC addr 了）</li><li>利用每个主机都有一张 ARP table，记录最近和本主机通信过的 <ip addr,="" mac="" addr=""></ip></li></ol><p>本地通信：<br>直接丢局域网就解决了（类似同一个宿舍传递毛巾）</p><p>远程通信：<br>丢到网关里，然后事情丢给网关（类似快递丢给快递员，怎么送我就不关心了）</p><p>远程通信的四大关键要素：<br>IP addr<br>netmask<br>DNS IP addr<br>Gateway IP addr</p><p>ARP 负责 链路层和网络层映射<br>DNS 负责 应用层和网络层映射</p><p>DNS 是一级级的，有南大级别的，教育网级别的，中国级别的…</p><h3 id="无线网络-WLAN"><a href="#无线网络-WLAN" class="headerlink" title="无线网络 WLAN"></a>无线网络 WLAN</h3><p>wireless != mobility</p><p>handoff: mobile changes base station providing connection into wired network（从南校门走到北校门，手机用的基站已经换了一个了）<br>5G 目标就是解决高铁高速移动中迅速切换基站</p><p>基站：<br>可以理解为连接无线和有线的，解决最后一公里问题。<br>部署在位置比较好的地方，铁塔公司把基站后连接有线连入因特网核心</p><p>无线链路：<br>按照目标来划分，目标有：通信距离</p><p>无线网络通信的两种方式</p><ol><li>infrastructure mode（一台通信车，其他人通过通信车进行通讯，通信车被炸了就没法通信了）</li><li>ad-hoc mode（每个人都是一个节点，能和其他人进行通信，挂了一个其他人不影响）</li></ol><p>single hop: 宿舍两个人手机通信，实际上 A-AP-B<br>multiple hop: MANET, VANET（车联网用的到，企图把道路上的一片区域的车组成小网络，防止碰撞）</p><p>无线连接的特征：</p><ol><li>decreased signal strength: 信号衰减<br> 自由路径损失公式<br> free space path loss(FSPL)<br> $ FSPL = (\frac{4\pi df}{c})^2 $<br> d = distance<br> $\lamda$ = wave length(c/f)<br> f = frequency<br> c = speed of light</li></ol><hr><p><strong>TODO:</strong><br>第5周周四的课补</p><hr><h1 id="第3章-网络层"><a href="#第3章-网络层" class="headerlink" title="第3章 网络层"></a>第3章 网络层</h1><h2 id="IP-Layer"><a href="#IP-Layer" class="headerlink" title="IP Layer"></a>IP Layer</h2><p>IP 包：IP header + 四层的 payload</p><p>IP 层只关心 header，类比快递员只关心快递盒子上贴了什么快递单</p><p>IP header 作为下两者的 interface：</p><ol><li>source and destination（发件人和收货人）</li><li>source and network（发件人和收货地址）</li></ol><h3 id="IP-协议设计时要完成的目标"><a href="#IP-协议设计时要完成的目标" class="headerlink" title="IP 协议设计时要完成的目标"></a>IP 协议设计时要完成的目标</h3><ol><li>解析包</li><li>传送包</li><li>处理第三层遇到的问题：<ol><li>routing 的死循环（类似二层交换机的死循环）</li><li>出错误</li><li>包太大</li></ol></li><li>协议可扩展</li><li>信息传递优先级（类似顺丰隔日达、今日达，只看你给钱多）</li></ol><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><h4 id="目标1-parse-packet"><a href="#目标1-parse-packet" class="headerlink" title="目标1 parse packet"></a>目标1 parse packet</h4><ul><li>IP version number（4 bit），packet length（16 bit）</li></ul><h4 id="目标2-carry-packet-to-Destination"><a href="#目标2-carry-packet-to-Destination" class="headerlink" title="目标2 carry packet to Destination"></a>目标2 carry packet to Destination</h4><ul><li>destination packet addr（32 bit）</li></ul><h4 id="目标3-handle-problem"><a href="#目标3-handle-problem" class="headerlink" title="目标3 handle problem"></a>目标3 handle problem</h4><ol><li><p>preventing loops（TLL）<br> 为什么不用二层的 spanning tree？</p><ol><li>太大了不好剪</li><li><p>局域网里链路很便宜，广域网太贵了，一条光纤不能扔那不用</p><p>解决：<br>在包里加了 Time-to-Live（TTL）field（8 bit），每被发一次，TTL 就减一点，减到0就丢掉这个包<br>负责丢的路由器告诉 source 没发成</p></li></ol></li><li><p>corruption<br> checksum（16 bit），每发一次都计算一次 checksum，保证刚才一跳中包头未发生改变</p></li><li><p>fragmentation<br> frag（32 bit）</p></li><li><p>evolution<br> version number（4 bit）+ special handling</p><p> special handling：</p><ul><li>type of service（8 bit）</li></ul></li></ol><h3 id="IP-header-结构"><a href="#IP-header-结构" class="headerlink" title="IP header 结构"></a>IP header 结构</h3><p><img src="/2019/02/25/计网学习笔记/" alt="PPT完整图！"></p><h4 id="fragmentaion"><a href="#fragmentaion" class="headerlink" title="fragmentaion"></a>fragmentaion</h4><p>每个 link 有一个最大传输单元，从一段大链路到另一段小链路时需要切片加头。</p><p>Q: 何时重组？<br>A: 接收端重组比较好，不要让中间路由器做重组的事，否则</p><ol><li>影响效率</li><li>且包可以走很多条路，只有接收端这个唯一终点。</li><li>还能再被切更小</li></ol><p>体现了 E2E principle（中间节点傻，只干转发的事，终端智能）</p><p>切片重组需要</p><ol><li>知道是谁的分片</li><li>是第几片分片</li><li>还能继续切小</li></ol><p>fragmentation fields:</p><ol><li>identifier</li><li>flags</li><li>offset</li></ol><h3 id="IPv6-小览"><a href="#IPv6-小览" class="headerlink" title="IPv6 小览"></a>IPv6 小览</h3><ol><li>解决 IPv4 地址只有 32 bit IP 地址，地址不够的问题。进化到 128 bit 的地址，足以给太阳系内每一颗沙子分地址</li><li>简化 IPv4 里不必要的东西（</li></ol><h4 id="IPv6-哲学"><a href="#IPv6-哲学" class="headerlink" title="IPv6 哲学"></a>IPv6 哲学</h4><ol><li>don’t deal with problems: leave to ends（网络要做的只是传得快、不丢包）<ul><li>删去 fragmentation 和 checksum</li><li>保留 ttl</li></ul></li><li>simplify handling<ul><li>use next header</li><li>删去 header length</li></ul></li><li>provide general flow label for packet<ul><li>not tied to semantics(语义)</li><li>高灵活性</li></ul></li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li>网络层可分为数据平面和控制平面<ul><li>数据平面负责转发</li><li>控制平面负责指挥</li></ul></li></ol><h2 id="IP-router"><a href="#IP-router" class="headerlink" title="IP router"></a>IP router</h2><p>IP router 的架构大大小小都差不多，差别就是吞吐量</p><p>如何评价 router？</p><ul><li>Router capacity = N * R</li><li>N = number of external router “ports”（有几个口）</li><li>R = speed(“line rate”) of a port（一个口有多快）</li></ul><p>router 分类：</p><ol><li>core</li><li>edge（两种，一种和别的运营商交互，另一种和自家用户交互）</li><li>small business（家庭用）</li></ol><h3 id="router-结构："><a href="#router-结构：" class="headerlink" title="router 结构："></a>router 结构：</h3><p><img src="/2019/02/25/计网学习笔记/" alt="router结构ppt"></p><h4 id="入线卡-input-linecards"><a href="#入线卡-input-linecards" class="headerlink" title="入线卡 input linecards"></a>入线卡 input linecards</h4><p>任务：</p><ul><li>接受发过来的数据包</li><li>更新 IP 包头<ul><li>TTL-1, checksum, options and fragment(ipv4)</li><li>TTL-1(ipv6)</li></ul></li><li>查本地的 forwarding table 去找 dest IP addr 的出端口</li></ul><p>挑战：speed<br>100B packets @ 40Gbps -&gt; new packet every 20 nano secs</p><p>IP 包最小长度 64 bit，路由器能力评价标准 是能处理最小的包是多小，因为这决定了速度</p><p>查 forwarding table</p><ul><li>1个端口对应一块地址，而不是1个 IP addr</li></ul><p>如何找端口呢？找端口主要是根据 IP addr 的网络号进行找</p><ol><li>软件方法：用树的结构，根据网络号一级级往下分</li><li>硬件方法：?</li></ol><h4 id="出线卡-output-linecards"><a href="#出线卡-output-linecards" class="headerlink" title="出线卡 output linecards"></a>出线卡 output linecards</h4><p>任务：</p><ul><li>分类：map packets to flows</li><li>决定何时、丢哪个包</li><li>传输哪个包（优先级）</li></ul><p>调度策略：</p><ol><li>fair</li><li>weighted</li></ol><h4 id="入卡和出卡的连接"><a href="#入卡和出卡的连接" class="headerlink" title="入卡和出卡的连接"></a>入卡和出卡的连接</h4><ol><li>共享一块内存（低端货</li><li>总线（低端货</li><li>系统内部网络，做到入口和出口间传输不互相干扰（有点像数电的可编程阵列？</li></ol><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ol><li>IP router 是因特网骨干</li><li>速度和公平</li></ol><h2 id="routing-算法"><a href="#routing-算法" class="headerlink" title="routing 算法"></a>routing 算法</h2><p>goal:</p><ol><li>find a path</li><li>make the state contained in forwarding tables meets our goal</li></ol><p>评价路由算法：</p><ol><li>有效正确，即收敛</li><li>收敛地越快越好</li></ol><h3 id="local-state-vs-global-view-of-state"><a href="#local-state-vs-global-view-of-state" class="headerlink" title="local state vs. global view of state"></a>local state vs. global view of state</h3><p>单看一个路由器，无法判断它正确与否。要判断正确（即是否能正确转发到目的地），得看全局。</p><h3 id="路由正确性的充要条件"><a href="#路由正确性的充要条件" class="headerlink" title="路由正确性的充要条件"></a>路由正确性的充要条件</h3><ol><li>没有死路（即不会出现一个路由器在接到包后，不知道这个数据包该往哪发）<pre><code>     （case 1, case 2, ..., default。default 来保证没有 dead ends)</code></pre></li><li>没有环路</li></ol><h3 id="least-cost-path-routing（收敛的越快越好）"><a href="#least-cost-path-routing（收敛的越快越好）" class="headerlink" title="least-cost path routing（收敛的越快越好）"></a>least-cost path routing（收敛的越快越好）</h3><p>dijkstra 算法</p><h2 id="routing-协议（自治域内部）"><a href="#routing-协议（自治域内部）" class="headerlink" title="routing 协议（自治域内部）"></a>routing 协议（自治域内部）</h2><p>基于 dijkstra 算法</p><ul><li>link-state routing</li><li>distance-vector routing</li></ul><p>dijkstra 算法要知道全局的拓扑</p><p>工程做起来有两种方法：</p><ol><li>一个独立的 machine 计算完，再分发给各个节点</li><li>将全网拓扑广播给所以路由器，每个路由器都算一下，结果是一样的</li></ol><p>Internet 使用2</p><h3 id="link-state-routing"><a href="#link-state-routing" class="headerlink" title="link-state routing"></a>link-state routing</h3><p>每个节点都知道和自己直接相邻的路的 cost<br>每个节点都会把自己的状态广播给其他所有路由器，周期性地。<br>还有就是 cost 改变时也会广播。</p><p>洪泛过后大家重新计算 least-cost path</p><p>点数为 N, 边数为 E<br>复杂度 N*E</p><h4 id="何时洪泛？"><a href="#何时洪泛？" class="headerlink" title="何时洪泛？"></a>何时洪泛？</h4><p>洪泛不需要 routing 规则，直接发到广播端口的。所以在这里只能用洪泛不能用路由，因为路由还没建立呢。</p><ol><li>拓扑改变了（节点挂了，下线了）</li><li>cost 改变了</li><li>周期性的，告诉别人你还活着</li></ol><h4 id="收敛时延-convergence-delay"><a href="#收敛时延-convergence-delay" class="headerlink" title="收敛时延 convergence delay"></a>收敛时延 convergence delay</h4><p>时延太长会导致一台 router 还活在旧的状态理解里，搞不好会出环路</p><h4 id="收敛过程中可能发生"><a href="#收敛过程中可能发生" class="headerlink" title="收敛过程中可能发生"></a>收敛过程中可能发生</h4><ol><li>looping packets</li><li>包进死胡同丢了</li><li>由于发的过程中 path 可能改变，先发的数据后到了，而后发的数据先到了</li></ol><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ol><li>O(NE) messages 洪泛</li><li>O(N^2) computation time | dijkstra算法时间</li><li>O(network diameter) 收敛时延，主要是传播时延</li><li>O(N) entries in forwarding table</li></ol><h4 id="link-state-routing-协议"><a href="#link-state-routing-协议" class="headerlink" title="link-state routing 协议"></a>link-state routing 协议</h4><p>OSPF: open shortest path first</p><p>IS-IS: intermediate system to intermediate system</p><p><strong>讲到现在的所有协议都是 AS 内部的协议</strong></p><h3 id="distance-vector-协议"><a href="#distance-vector-协议" class="headerlink" title="distance-vector 协议"></a>distance-vector 协议</h3><p>router 不需要把自己的信息洪泛给全网，只要告诉邻居节点他对世界的看法就行了，这有益于分布式</p><h4 id="B-F-算法"><a href="#B-F-算法" class="headerlink" title="B-F 算法"></a>B-F 算法</h4><p>看 ppt 上的具体示例</p><p>节点 x 知道它到所有邻居的距离 d_i ，然后他的邻居 i 到目标的距离 dis_i 是已知的，所以只要遍历邻居，取 d_i + dis_i 之和的最小值即可。</p><p>节点发生改变时告诉它的邻居，然后向外更新 vector</p><h4 id="B-F-算法有的问题"><a href="#B-F-算法有的问题" class="headerlink" title="B-F 算法有的问题"></a>B-F 算法有的问题</h4><p>看 ppt 具体例子</p><ol><li>形成 routing loops，要互相丢包很久才能恢复到正确状态，期间没有包能被发送</li></ol><h4 id="解决办法-poinsoned-reverse-毒药逆转"><a href="#解决办法-poinsoned-reverse-毒药逆转" class="headerlink" title="解决办法 poinsoned reverse 毒药逆转"></a>解决办法 poinsoned reverse 毒药逆转</h4><p>若 z 经过 y 到达 x，那么 z 会告诉 y 自己到 x 的距离是 正无穷，这样 y 就不会考虑通过 z 到达 x。<br>否则 z 会告诉 y 它到 x 的真实距离。</p><p>x-y cost &lt; y-z cost</p><p>这样子假如 x-y 挂了，y 发现自己到 x 是无路可走的，y-x 更新为正无穷。这个消息传到 z，z-x 被启用，这个消息再正确的传给 y，y 就可以通过 z 到达 x 啦。</p><p>看 ppt 具体例子</p><h4 id="解决办法-path-routing"><a href="#解决办法-path-routing" class="headerlink" title="解决办法 path routing"></a>解决办法 path routing</h4><p>不单单广播距离，还广播向量，这样邻居就知道它之前是怎么走的了。（不考）</p><h3 id="LS-和-DV-不同点"><a href="#LS-和-DV-不同点" class="headerlink" title="LS 和 DV 不同点"></a>LS 和 DV 不同点</h3><p>信息告知：<br>LS: O(NE) 因为是全网洪泛<br>DV: O(E) 只要告诉邻居就行</p><p>收敛速度：<br>LS: 比较快<br>DV: 可能出现 loop，然后要一段时间才能恢复，即使用了毒药逆转</p><p>鲁棒性：（假定所有节点都是善意的）（节点挂了尽快恢复，且不出错就是鲁棒）<br>LS:</p><ul><li>可能广播错误的 link cost，然后影响其他节点</li><li>每个节点自己算自己的</li></ul><p>DV:</p><ul><li>可能传播错误的 path cost</li><li>每个节点算自己的，但别人还依赖你的计算结果，所以错误会蔓延</li></ul><h3 id="LS-和-DV-相似点"><a href="#LS-和-DV-相似点" class="headerlink" title="LS 和 DV 相似点"></a>LS 和 DV 相似点</h3><p>目的都是找最短路</p><p>用于同一个 AS 域内，都是友军</p><p>下节课讲 AS 之间的 routing</p><h2 id="routing-协议-（自治域之间）"><a href="#routing-协议-（自治域之间）" class="headerlink" title="routing 协议 （自治域之间）"></a>routing 协议 （自治域之间）</h2><p>IXP: 不提供服务，只负责交换 ISP 和 ISP 之间的信息，这样两个 ISP 之间就不用特地建立物理线了。（运营商间的交换机）</p><p>域间路由的挑战：</p><ol><li>全球寻址</li><li>管理<ul><li>自治管理，策略，隐私（可以不告诉对方自己的内部路由细节）</li></ul></li></ol><h3 id="scaling"><a href="#scaling" class="headerlink" title="scaling"></a>scaling</h3><p>路由器必须全球可达</p><p>一个操作就是把一个范围内的 IP 一个 entry。而不是一个 IP 一个 entry。</p><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><p>涉及商业竞争：</p><ol><li>我不走我竞争者的网</li><li>我不让竞争者走我的网</li></ol><h3 id="域间路由算法"><a href="#域间路由算法" class="headerlink" title="域间路由算法"></a>域间路由算法</h3><p>丢弃 Link-state</p><ol><li>没隐私，因为要广播自己的世界看法</li><li>得商量 cost 咋定义</li></ol><p>distance-vector</p><ol><li>需要改进，叫 BGP</li><li>需要去环路</li><li>需要加入 policy</li></ol><h3 id="IPv4-设计（为了scaling）"><a href="#IPv4-设计（为了scaling）" class="headerlink" title="IPv4 设计（为了scaling）"></a>IPv4 设计（为了scaling）</h3><p>一段 host 地址一般全0，全1，01不能用（留给网关）</p><p>一开始分为 ABCD 四类地址，愚蠢的设计</p><p>CIDR: 无类别的</p><p>比如一个公司 50 台主机，2^5 &lt; 50 &lt; 2^6，移动就给你 32 - 6 = 26 位前缀，IP 范围就是 128.23.9/26。掩码 26 个 1，6 个 0</p><p>大运营商层层分 IP，比如分给南大一段，南大再给下面的机子分配，运营商联系南大的时候，不需要知道南大下面的具体细节，只要知道是发往南大就行，剩下来的事情交给南大的路由器。</p><p>这就是聚合。</p><h3 id="AS-之间的关系"><a href="#AS-之间的关系" class="headerlink" title="AS 之间的关系"></a>AS 之间的关系</h3><p>AS A 可以是 B 的客户（付钱）</p><p>可以是 B 的提供商（付钱）</p><p>可以是 B 的对端，有双向合作的那种（互相不收钱，交换起来数据比不能过 1:3 或 3:1，在这个范围内不收钱，超了就收钱了）</p><h3 id="为什么会有-peer？"><a href="#为什么会有-peer？" class="headerlink" title="为什么会有 peer？"></a>为什么会有 peer？</h3><p>本来因特网是树，只有上下级关系，但因为钱，同级别的可以不经过上层传，而是直接传</p><p><img src="/2019/02/25/计网学习笔记/" alt="routing follows the money 图片"></p><p>B 没有义务帮 A 和 C 省钱，所以 D 走到 E 不能通过 A-B-C 路</p><p>域间路由的第一要义不是最短路！是省钱！题目分析是要看 经过的路上的 AS 是不是得到了利益，没得到就不能过这个 AS。</p><p>以及，不会先向下走再向上走。因为下层没有义务帮上层的 AS 传数据，不赚钱。</p><h3 id="BGP-协议"><a href="#BGP-协议" class="headerlink" title="BGP 协议"></a>BGP 协议</h3><p>先选一条 ASes 路，这条路反映了 物理链路通达 且 有商业关系。</p><p>两个 AS 的边防局互相交流就是 “讲 BGP 语言”</p><p>类似 DV，一个 AS 广播它到某一个 IP 域的 cost</p><h4 id="BGP-和-DV-的区别"><a href="#BGP-和-DV-的区别" class="headerlink" title="BGP 和 DV 的区别"></a>BGP 和 DV 的区别</h4><ol><li>不一定选最短路（钱）</li><li>path-vector 广播到某个 IP 网络的 path，而不只是距离，这样就可以避免环路了，还可以自己选择路径</li><li>广播策略可选，比如可以不广播</li><li>aggregate route，目的地址都在一起，可以合并以减少路由表</li></ol><h4 id="路怎么选"><a href="#路怎么选" class="headerlink" title="路怎么选"></a>路怎么选</h4><ul><li>为了赚钱，路由的路选哪好？customer &gt; peer &gt; provider</li><li>最大化 performance，最短 AS path 长度</li><li>最小化带宽，热土豆策略</li></ul><p>Gao-Rexford：<br>路由不往下走？<br>AS policy graph 应当是有向无环图</p><p>边防局 border routers</p><p>RFC: request for comments 制定于每年三次的 ietf 会议</p><h4 id="eBGP-iBGP-IGP"><a href="#eBGP-iBGP-IGP" class="headerlink" title="eBGP, iBGP, IGP"></a>eBGP, iBGP, IGP</h4><p>eBGP: 边防局交流</p><p>iBGP: 边防局和内部人员交流（学习外交部文件，交给内部人员学习）</p><p>IGP: 内部人员交流</p><h4 id="BGP-中的基本信息"><a href="#BGP-中的基本信息" class="headerlink" title="BGP 中的基本信息"></a>BGP 中的基本信息</h4><p>Open: 验明身份</p><p>notification：报故障</p><p>update：</p><p>keep alive：</p><h4 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h4><ol><li><p>AS path 矢量（每个 AS 都有独立编号）</p></li><li><p>local preference（对内消息，有多条出去的路的情况下，告诉内部人员走哪比较好，机密）</p></li><li><p>MED: multi-exit discriminator（对于每个 IP 的前缀，指定走哪里，南京的联通和移动通话没必要走到北京再走回来）</p></li><li><p>IGP cost（hot-potato）</p></li></ol><h4 id="可达问题"><a href="#可达问题" class="headerlink" title="可达问题"></a>可达问题</h4><p>不一定</p><h4 id="安全问题（想断就断，不想断就让他连着）"><a href="#安全问题（想断就断，不想断就让他连着）" class="headerlink" title="安全问题（想断就断，不想断就让他连着）"></a>安全问题（想断就断，不想断就让他连着）</h4><h4 id="收敛问题"><a href="#收敛问题" class="headerlink" title="收敛问题"></a>收敛问题</h4><p>很可能收敛不了</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层是端到端的</p><p>存在的意义：比如 NJU x 楼 x 宿舍 -&gt; PKU y 楼 y 宿舍，网络层就编址到这里，NJUer 对 PKUer 发文件、发 QQ 经过不同的端口？<br>NJUer 需要复用物理地址，PKUer 需要解复用</p><p>IP 层保证全球可达（但不是一定到达），包会 崩溃、延迟、丢包、乱序、重复包（电子设备出错、对抗前面的问题）<br>传输层需要提供手段解决上述问题（这些问题不交由网络层解决的原因是：不是所有业务都需要稳得一批，低价看视频就不用）</p><p>传输层要告诉 网络层 传多块（速度），比如传输层知道某个路由器拥堵了，那就发慢点让它能处理</p><h2 id="Ports"><a href="#Ports" class="headerlink" title="Ports"></a>Ports</h2><p>区分是哪个应用在发包</p><p>端口号自动分配，NJU 某机子一个端口，PKU 某机子一个端口，返回 1024~65536 ?</p><p>UDP 与 TCP 区别：<br>UDP</p><ul><li>不保证传达到</li><li>不面向连接，丢出去就完事了，野蛮人的交流方式</li></ul><p>TCP</p><ul><li>保证送达，发不到的会重发等等</li><li>面向连接，要握手，文明人的交流方式</li></ul><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>一直没怎么更新过，简陋但简单</p><p>包头就</p><ul><li>src port（这都可以不给，意思就是不需要你回复我）</li><li>dst port</li><li>length</li><li>checksum（可以置为0，意思就是别检查我了，对不对和你没关系）</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>精致，啥都干了</p><h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><p>一系列对抗机制 Mechanisms，来处理 bad events</p><ul><li>checksum</li><li>ACK（没收到）</li><li>NACK（没收到</li><li>Sequence number</li><li>Retransmission</li><li>timeout</li><li>forward error correction</li></ul><h4 id="检错、纠错"><a href="#检错、纠错" class="headerlink" title="检错、纠错"></a>检错、纠错</h4><p>checksum</p><h4 id="告诉发送端发生了啥"><a href="#告诉发送端发生了啥" class="headerlink" title="告诉发送端发生了啥"></a>告诉发送端发生了啥</h4><p>ACK/NACK</p><p>PPT 图</p><p>如果 ACK/NACK 包出错，那么也再发一遍 ACK/NACK（对于发送端来说，它只感受到刚发的没发好）</p><p>如果 A-&gt;B P1(yes), B-&gt;A ACK(no), A 重发 B P1，如果不编号，那么 B 不知道收到的是第几个包<br>所以要用 sequence number</p><h4 id="处理丢包"><a href="#处理丢包" class="headerlink" title="处理丢包"></a>处理丢包</h4><p>PPT 图</p><p>用 Timeout，如果过了时间没收到回复，那就重新发</p><p>会有伪丢包现象，只是传的慢了，确实可达了，但 timeout 超了</p><h4 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h4><h5 id="stop-and-wait"><a href="#stop-and-wait" class="headerlink" title="stop and wait"></a>stop and wait</h5><p>@sender</p><ol><li>send, then wait</li><li>if(ack) i++; repeat;</li><li>if(nack/timeout) repeat;</li></ol><p>弊端：不高效，因为 send 1 个 data 时间少，等待时间 RTT 太长！</p><p>效率 = data/RTT</p><p>在广域网情况下，带宽利用率会很低！<br>但如果很短的线直连，利用率还是挺高的</p><h5 id="sliding-window"><a href="#sliding-window" class="headerlink" title="sliding window"></a>sliding window</h5><p>PPT 图</p><p>记录应当在传输，而还未确认的包的数量</p><p>一次发一批，发送端和接收端维护相同长度的滑动窗</p><p>效率 = min{n*data/RTT, link bandwidth}</p><p>n 太大的情况下（一次传的超过带宽），包会堆积，然后丢包</p><h6 id="cumulative-ack"><a href="#cumulative-ack" class="headerlink" title="cumulative ack"></a>cumulative ack</h6><p>每次收到连续的 包 时更新 ack 的编号，再发</p><h6 id="selective-ack"><a href="#selective-ack" class="headerlink" title="selective ack"></a>selective ack</h6><p>每次收到都更新 ack 编号，发（导致 ack 数量很多，这是消耗）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记</title>
      <link href="/2019/02/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇供日后复习，跳跃性很大，随性更新。</p><p>参考书目：《算法设计与分析》 黄宇 机械工业出版社</p><h1 id="第2章-从算法的角度重新审视数学的概念"><a href="#第2章-从算法的角度重新审视数学的概念" class="headerlink" title="第2章 从算法的角度重新审视数学的概念"></a>第2章 从算法的角度重新审视数学的概念</h1><h3 id="2-1-3-阶乘n"><a href="#2-1-3-阶乘n" class="headerlink" title="2.1.3 阶乘n!"></a>2.1.3 阶乘n!</h3><p>根据<code>Stirling公式</code>，可以将<code>n!</code>转化为更易于处理的闭形式，对<code>n&gt;=1</code>，有：</p><script type="math/tex; mode=display">\sqrt{2\pi n}(\frac{n}{e})^n < n! < \sqrt{2\pi n}(\frac{n}{e})^n(1+\frac{1}{11n})</script><p><code>Stirling公式</code>也可以写成：</p><script type="math/tex; mode=display">n! = \sqrt{2\pi n}(\frac{n}{e})^n e^{\varepsilon(n)},其中\frac{1}{12n+1} \leq \varepsilon(n) \leq \frac{1}{12n}</script><p>写成近似形式：</p><script type="math/tex; mode=display">n! = \sqrt{2\pi n}(\frac{n}{e})^n(1+\Theta(\frac{1}{n}))</script><p>由于 $\Theta(\frac{1}{n})$ 是无穷小量，$\lim\limits_{n \to \infty} \frac{1}{n}=0$ ，忽略。所以得到进一步的近似式：</p><script type="math/tex; mode=display">n! \approx \sqrt{2\pi n}(\frac{n}{e})^n</script><h3 id="2-1-4-常见级数求和-sum-limits-i-1-n-f-i"><a href="#2-1-4-常见级数求和-sum-limits-i-1-n-f-i" class="headerlink" title="2.1.4 常见级数求和 $\sum\limits_{i=1}^{n}f(i)$"></a>2.1.4 常见级数求和 $\sum\limits_{i=1}^{n}f(i)$</h3><ul><li>多项式级数(polynomial series)<br>  $ \sum\limits_{i=1}^{n}i = \dfrac{n(n+1)}{2} $<br>  .<br>  $ \sum\limits_{i=1}^{n}i^2 = \dfrac{1}{3}n(n+\dfrac{1}{2})(n+1) $<br>  .<br>  $ \sum\limits_{i=1}^{n}i^k = \Theta(\dfrac{1}{k+1}n^{k+1}) $<br>  .</li><li>几何级数(geometric series)<br>  $ \sum\limits_{i=0}^{k}ar^i = a(\dfrac{r^{k+1}-1}{r-1}) $</li></ul><p>测试用<br>$\begin{eqnarray}f(x,y)<br>    &amp;=&amp;2xy+(x-y)^2\\<br>    &amp;=&amp;x^2+y^2<br>\end{eqnarray}$</p><h1 id="第0章-概论"><a href="#第0章-概论" class="headerlink" title="第0章 概论"></a>第0章 概论</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>Q1: 在数组中找最大元素和最小元素</p><p>A1: 最优：n为偶数时，将数组切分为($a_0$,$a_1$)($a_2$,$a_3$)…($a_{n-2}$, $a_{n-1}$)，组内比较后分出胜者组和败者组，胜者组遍历一遍得到最大元素，败者组遍历一遍得到最小元素。n为奇数时先抛开最后一个元素，最后额外比较一下。</p><hr><p>Q2: 比较3匹马的预测性</p><p>A2: 将马的过去两百场比赛进行huffman编码，所用字符最少的马预测性越强，原理是信息熵。</p><hr><p>Q3: 停机问题</p><p>A3: 不可判定，假设有程序terminate(p:program, x:input)能判断对于程序p，给一个输入x，p是否会终止（即判定p(x)是否终止），那么定义程序paradox(z:file)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paradox(z:file):</span><br><span class="line">    <span class="number">1</span>: <span class="keyword">if</span>(terminate(z, z)) <span class="keyword">goto</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>paradox(z)的执行结果为</p><script type="math/tex; mode=display">\left\{\begin{array}{aligned}z(z)不终止   &&  {paradox(z)终止}\\z(z)终止     &&  {paradox(z)不终止}\\\end{array} \right.</script><p>此时，paradox(paradox)便成为矛盾体</p><script type="math/tex; mode=display">\left\{\begin{array}{aligned}paradox(paradox)不终止 &&   {paradox(paradox)终止}\\paradox(paradox)终止   &&   paradox(paradox)不终止\end{array} \right.</script><h2 id="课程任务："><a href="#课程任务：" class="headerlink" title="课程任务："></a>课程任务：</h2><p>书面作业15%（8次，准备2个作业本）<br>编程15%（6-8次，每次2-4题，时间2-3周）<br>期中20%<br>期末50%</p><h1 id="第1章-概论"><a href="#第1章-概论" class="headerlink" title="第1章 概论"></a>第1章 概论</h1><p>《proof without words》中的有趣证明？</p><p>double counting 思想用于证明</p><h2 id="平均复杂度"><a href="#平均复杂度" class="headerlink" title="平均复杂度"></a>平均复杂度</h2><p>$ \sum\limits_{i=1}^{n}Pr(i)I(i) $</p><h2 id="算法的最优性"><a href="#算法的最优性" class="headerlink" title="算法的最优性"></a>算法的最优性</h2><p>如果一个算法的最坏情况等于问题的下界，那么这个算法是最优的。</p><h1 id="第2讲-渐进时间复杂度"><a href="#第2讲-渐进时间复杂度" class="headerlink" title="第2讲 渐进时间复杂度"></a>第2讲 渐进时间复杂度</h1><p>$ log_{n}, n^\alpha, c^n, n!, n^n $</p><script type="math/tex; mode=display">\lim\limits_{n\to \infty}\frac{f(n)}{g(n)}=c,\left\{\begin{array}{aligned}c=0 &&  f=o(g)\\0 \leq c < \infty   && f=O(g)\\0 < c < \infty      && f=\Theta(g)\\0 < c \leq \infty   && f=\Omega(g)\\c = \infty          && f=\omega(g)\end{array} \right.</script><p>不是所有俩函数之间都有上述五种关系，比如$ f(n)=n, g(n)=n^{1+sin n}$，极限不存在。</p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树的高度p是问题的lower bound，基于比较的决策树节点数为n，有$ n \leq 2^{p-1} $，所以$ p &gt;= lgn $，所以查找问题的lower bound为$lgn$，二分查找是最优算法。</p><p>无关思考题：圆的内接八边形，边长4个2，4个3，求八边形面积。<br>放到正方形里去，减去四个角的等腰直角三角形</p><script type="math/tex; mode=display">f(n) =\begin{cases}n/2,  & \text{if $n$ is even}\\3n+1, & \text{if $n$ is odd}\end{cases}</script><h1 id="第3讲-递归"><a href="#第3讲-递归" class="headerlink" title="第3讲 递归"></a>第3讲 递归</h1><p>时间复杂度计算</p><h3 id="齐次线性"><a href="#齐次线性" class="headerlink" title="齐次线性"></a>齐次线性</h3><p>$ a_n = r_1a_{n-1} + r_2a_{n-2} + … + r_ma_{n-k} $</p><p>特例<br>$ 形如T(n)=r_1T(n-1)+r_2T(n-2),有特征方程x^2 = r_1x + r_2x $<br>$ 则T(n) = ux_1^n + vx_2^n. $</p><p>证明：<br>$ B.C: T(1), T(2) $</p><p>$ I.H: 1 \leq m &lt; n, T(m) = ux_1^m + vx_2^m $</p><p>$\begin{eqnarray}T(n)<br>    &amp;=&amp; ux_1^n+vx_2^n\\<br>    &amp;=&amp; ux_1^{n-2}x_1^2+vx_2^{n-2}x_2^2\\<br>    &amp;=&amp; ux_1^{n-2}(r_1x_1+r_2)+vx_2^{n-2}(r_1x_2+r_2)\\<br>    &amp;=&amp; r_1(ux_1^{n-1}+vx_1^{n-2})+r_2(ux_1^{n-2}+vx2^{n-2})\\<br>    &amp;=&amp; r_1T(n-1)+r_2T(n-2)<br>\end{eqnarray}$</p><p>代价 = 递归代价 + 非递归代价</p><p>$ T(n) = bT(\frac{n}{c})+f(n) $</p><p>after $k$ th expansion</p><p>$ T(n) = b^kT(\frac{n}{c^k})+\sum\limits_{i=1}^{k}f(\frac{n}{c^{i-1}}) $</p><p>意味着递归树高度$\log_c n$</p><script type="math/tex; mode=display">\sum\limits_{i=0}^{n-1}=\begin{cases}n/2, \text{xxx} \\ss\end{cases}</script><h2 id="最大子序列之和"><a href="#最大子序列之和" class="headerlink" title="最大子序列之和"></a>最大子序列之和</h2><ol><li>暴力枚举<br> 算法：取所有sequence[i, j]，比较。<br> 时间复杂度：$O(n^3)$</li><li>减少重复计算</li><li>二分，最长要么在左，要么在右，要么有左有右</li><li><p>假设A[0, n]中最大和为M[0, n]，那么A[0, n+1]中最大和为$\max\{M[0,n], \sum\limits_{i=0}^{n}A_i, \sum\limits_{i=1}^{n}A_i, …,\sum\limits_{i=n-1}^{n}, A_n\}$</p><p> 当前和一直加，保持增长，如果小于0，就丢弃前面的（即丢弃当前和）</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ThisSum = MaxSum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">    ThisSum += A[j];</span><br><span class="line">    <span class="keyword">if</span>(ThisSum &gt; MaxSum) &#123;</span><br><span class="line">        MaxSum = ThisSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ThisSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ThisSum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="一个盘子可以被n个直线最多分为多少块"><a href="#一个盘子可以被n个直线最多分为多少块" class="headerlink" title="一个盘子可以被n个直线最多分为多少块"></a>一个盘子可以被n个直线最多分为多少块</h2><p>L(0) = 1<br>L(n) = L(n-1) + n</p><h2 id="合法字符串"><a href="#合法字符串" class="headerlink" title="合法字符串"></a>合法字符串</h2><p>字符串只有abc三种字符，aa不允许出现，长度为n的合法字符串有多少个</p><p>f(1) = 3<br>f(2) = 8<br>str(n)  : ab+str(n-2)<br>        : ac+str(n-2)<br>        : b+str(n-1)<br>        : c+str(n-1)<br>f(n) = 2f(n-1)+2f(n-2)</p><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>strassen’s alogorithm runs in $O(n^{2.81})$</p><p>f(n) = 7f(n/2) + $\Theta(n^2)$</p><h1 id="第4讲-quick-sort"><a href="#第4讲-quick-sort" class="headerlink" title="第4讲 quick sort"></a>第4讲 quick sort</h1><p>易合难分</p><p>partition的方法不同<br>最坏复杂度分析<br>平均复杂度分析</p><h1 id="第5讲-merge-sort"><a href="#第5讲-merge-sort" class="headerlink" title="第5讲 merge sort"></a>第5讲 merge sort</h1><p>易分难合</p><h1 id="第6讲-heap-sort"><a href="#第6讲-heap-sort" class="headerlink" title="第6讲 heap sort"></a>第6讲 heap sort</h1><h2 id="common-version"><a href="#common-version" class="headerlink" title="common version"></a>common version</h2><h2 id="accelerated-heap-sort"><a href="#accelerated-heap-sort" class="headerlink" title="accelerated heap sort"></a>accelerated heap sort</h2><h1 id="第7讲-选择"><a href="#第7讲-选择" class="headerlink" title="第7讲 选择"></a>第7讲 选择</h1><h2 id="找最大最小元素"><a href="#找最大最小元素" class="headerlink" title="找最大最小元素"></a>找最大最小元素</h2><h2 id="找第2大元素"><a href="#找第2大元素" class="headerlink" title="找第2大元素"></a>找第2大元素</h2><h2 id="找第k大-小元素"><a href="#找第k大-小元素" class="headerlink" title="找第k大/小元素"></a>找第k大/小元素</h2><h2 id="找中位数"><a href="#找中位数" class="headerlink" title="找中位数"></a>找中位数</h2><p>算法1：</p><ol><li>寻找 pivot，将数组分两半，在基数比较大的一半里找第 n/2 - |S小| - 1 小的元素<br>最坏情况：<br>类似快排，pivot选不好</li></ol><p>6次比较找出5个元素中的中位数：</p><p>算法2：</p><h1 id="第8讲-adversary-amp-BST"><a href="#第8讲-adversary-amp-BST" class="headerlink" title="第8讲 adversary &amp; BST"></a>第8讲 adversary &amp; BST</h1><h2 id="判断5个元素中是否有3个连续的1"><a href="#判断5个元素中是否有3个连续的1" class="headerlink" title="判断5个元素中是否有3个连续的1"></a>判断5个元素中是否有3个连续的1</h2><p>3次之内不够<br>对手策略：定义 x: 1 1 1 1 1, y: 0 0 0 0 0，我想看第i位的值，就先去 x 里看，如果把 xi 变成0还能保证有3个连续1，那么把 xi 变成0，否则把 yi 变成1.</p><p>4次：</p><h2 id="判断图的连通性"><a href="#判断图的连通性" class="headerlink" title="判断图的连通性"></a>判断图的连通性</h2><p>必须看$\frac{n(n-1)}{2}$次，否则<br>对手策略：</p><p>性质的单调性：图有这个性质，它的子图也有这个性质</p><p>图可平面化：图在平面上可以画出边不相交，条件是不含 K3,3 和 K5 这两个子图</p><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>例如求$\sqrt{N}$<br>当 N 很大时，等于是找 x，使得 $ x^2 \leq N, (x+1)^2 &gt; N $</p><h2 id="AVL-tree"><a href="#AVL-tree" class="headerlink" title="AVL tree"></a>AVL tree</h2><h2 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB tree"></a>RB tree</h2><h2 id="搜索的-tutorial"><a href="#搜索的-tutorial" class="headerlink" title="搜索的 tutorial"></a>搜索的 tutorial</h2><h3 id="扔鸡蛋问题"><a href="#扔鸡蛋问题" class="headerlink" title="扔鸡蛋问题"></a>扔鸡蛋问题</h3><p>Q: n 层楼，从某层楼扔下去鸡蛋会碎，求这个楼层</p><ol><li>如果只有1个鸡蛋，easy</li><li>如果有无穷多个鸡蛋，二分法</li><li>如果有2个鸡蛋<br>A1: 每隔$\sqrt(n)$层扔1个鸡蛋，尝试次数为$\sqrt(n) ~ 2\sqrt(n)$<br>A2: 第1次，从x层扔（碎了，最坏比x次，没碎继续），第2次从2x-1层扔（碎了，比1+x-1次，没碎继续），。。。共 (x+1)x/2 层，令它 &gt;=n 就求得了 x</li></ol><h3 id="找名人"><a href="#找名人" class="headerlink" title="找名人"></a>找名人</h3><p>Q: n 个人，名人定义：被其他所有人认识，但不认识其他任何人，操作是拿A和B来，问A是否认识B，B是否认识A<br>O(n)算法：每次比较可以淘汰1个人</p><h3 id="赛马问题"><a href="#赛马问题" class="headerlink" title="赛马问题"></a>赛马问题</h3><p>Q: 共25匹马，每次可以选5匹马进行比赛，并得到次序（无法计时），问至少要多少次比赛才能确定跑的 最快、第二快、第三块的马</p><p>最快的：比赛6次即可<br>第二快：出现在第1快的那一组的第2名（1匹），以及所有组第一快里的那5匹里输给第1快的第2名（1匹）（只输给最大元素的元素是候选人）。<br>第三快：候选人，第1组第3快，第2组第2快，第3组第一快</p><p>共7次找出前三快的马</p><h3 id="2018-mid-term"><a href="#2018-mid-term" class="headerlink" title="2018 mid-term"></a>2018 mid-term</h3><p>Q: 有sort5算法，一次排序5个元素，求n个元素的最大值和第二大</p><p>最大值：一次sort5丢弃4个元素，所以最多比较$\frac{n-1}{4}$取上整</p><p>第二大：采用5叉胜者树，即可得出 max，和仅仅输给 max 的元素</p><h3 id="带权中位数"><a href="#带权中位数" class="headerlink" title="带权中位数"></a>带权中位数</h3><p>Q: 所有权之和为1，带权中位数$ x_k: \sum_{x_i &lt; x_k}{w_i} &lt; 1/2 且 \sum_{x_i &gt; x_k}{w_i} \leq 1/2 $<br>A: 找普通中位数，判断行不行，小不行就将小于它的权和加到它头上，然后递归后半部，大不行就同理</p><h3 id="最小未出现自然数"><a href="#最小未出现自然数" class="headerlink" title="最小未出现自然数"></a>最小未出现自然数</h3><p>n个大小不同的自然数E[1]~E[n]，找出不在这个自然数序列中出现的最小自然数</p><ol><li>若已排序，二分查找，若E[n/2]&gt;n/2，在前一半，若等于，在后一半，不可能小于..</li><li>若未排序，<br>法1：开n位数组，遍历，出现置1，然后第一个0元素下标就是<br>法2：找中位数x，按x和n/2大小丢掉一半元素</li></ol><h3 id="前k大的数们"><a href="#前k大的数们" class="headerlink" title="前k大的数们"></a>前k大的数们</h3><ol><li>排序，取后k个，nlogn</li><li>建堆+取出k个元素，n+klogn</li><li>先找第k大元素，n，再遍历找出比第k大都大的元素，n，然后排序，klogk，合计 n+klogk</li></ol><h3 id="两个已排序数组中的第k小元素-LeetCode"><a href="#两个已排序数组中的第k小元素-LeetCode" class="headerlink" title="两个已排序数组中的第k小元素 LeetCode-"></a>两个已排序数组中的第k小元素 LeetCode-</h3><ol><li>merge到第k个就行，$\Theta(k)$</li><li>找两数组中位数A[m/2], B[n/2]<br>若 m/2+n/2 &lt; k，若A[m/2] &gt; B[n/2]，说明比B[n/2]小的元素数量[n/2, m/2+n/2]，所以确定比B小的B的前半部分可以丢了<pre><code>         若       &lt; ，丢A的前半部分</code></pre></li></ol><h3 id="5个元素6次比较找中位数讲过了，7次比较排序"><a href="#5个元素6次比较找中位数讲过了，7次比较排序" class="headerlink" title="5个元素6次比较找中位数讲过了，7次比较排序"></a>5个元素6次比较找中位数讲过了，7次比较排序</h3><p>ppt</p><h3 id="k个已排序树组-merge-策略"><a href="#k个已排序树组-merge-策略" class="headerlink" title="k个已排序树组 merge 策略"></a>k个已排序树组 merge 策略</h3><p>两两merge</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>简单一致哈希假设</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h2 id="均摊时间代价"><a href="#均摊时间代价" class="headerlink" title="均摊时间代价"></a>均摊时间代价</h2><h3 id="accounting-cost"><a href="#accounting-cost" class="headerlink" title="accounting cost"></a>accounting cost</h3><p>这个真不会，[UST]</p><p>一般是对一系列操作进行分析才使用均摊分析，分析出一次操作的代价，而且这些操作是由规律的</p><p>accounting cost 之和必须大于0，这样计算出的 amortized cost 是 actual cost 的一个上界</p><h4 id="二-计数器-ppt上的"><a href="#二-计数器-ppt上的" class="headerlink" title="二-计数器 ppt上的"></a>二-计数器 ppt上的</h4><p>发现：一开始每一位都是0，<br>每一位想要从1变为0，首先得从0变为1，于是把0-&gt;1的accost 为1，1-&gt;0的ac cost为-1，这样 ac cost 始终大于0</p><h3 id="聚合法"><a href="#聚合法" class="headerlink" title="聚合法"></a>聚合法</h3><p>比如作业那个 三-计数器，个位每次变，十位每3次变，百位每9次变。。所以操作n次increment，变了n+n/3+n/3^2+…. &lt; 2n</p><p>栈的pop，multipop，可见每次操作</p><h3 id="势能法？potential-method"><a href="#势能法？potential-method" class="headerlink" title="势能法？potential method"></a>势能法？potential method</h3><h2 id="统一-hash"><a href="#统一-hash" class="headerlink" title="统一 hash"></a>统一 hash</h2><p>解决类似快排 partition 没选好的问题，快排随机选 pivot</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记</title>
      <link href="/2019/02/05/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/05/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title="?"></a>?</h1><h2 id="while中的let问题"><a href="#while中的let问题" class="headerlink" title="while中的let问题"></a>while中的let问题</h2><p>这是一段简单的遍历数组代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> array: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, array[index]);</span><br><span class="line"></span><br><span class="line">    index = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果显然</p><p><img src="/2019/02/05/Rust学习笔记/正常遍历结果.png" alt="正常遍历结果"></p><p>但如果略作修改，即index的mut关键字去掉，在迭代时用let index 隐藏原来的index<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> array: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, array[index]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> index = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果就是无限输出10。</p><hr><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安装参考网站</title>
      <link href="/2019/02/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/"/>
      <url>/2019/02/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文包含一些软件的优秀安装指南，都是亲测可用的。以备以后重新安装系统快速使用，本文会热更新。</p><p>每段的格式为：</p><ul><li><p>[已有教程网址]</p></li><li><p>[排除教程中的坑]</p></li><li><p>[对教程中的简要概括(防止教程404)]</p></li></ul><hr><h1 id="蓝灯lantern"><a href="#蓝灯lantern" class="headerlink" title="蓝灯lantern"></a>蓝灯lantern</h1><ul><li><p>教程：<a href="http://www.pianshen.com/article/5553973/" target="_blank" rel="noopener">lantern傻瓜式安装教程</a></p></li><li><p>排坑：进入 <a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">https://github.com/getlantern/lantern</a> 最下面。如果左击 <strong>ubuntu 14.04 64 bit</strong> 后没有直接下载：右击 <strong>ubuntu 14.04 64 bit</strong> 用迅雷下载链接。</p></li></ul><hr><h1 id="sublime-text-3"><a href="#sublime-text-3" class="headerlink" title="sublime text 3"></a>sublime text 3</h1><ul><li><p>教程：<a href="https://jingyan.baidu.com/article/64d05a023cd849de55f73be4.html" target="_blank" rel="noopener">命令行安装sublime text 3</a></p></li><li><p>概括：三条命令即可</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/sublime-text-3</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sublime-text-installer</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust环境安装+换中科大源</title>
      <link href="/2019/02/03/Rust%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2019/02/03/Rust%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>vct说Rust环境配置很复杂，小李哥不信邪地来打算试一试。</p><p>操作系统：Ubuntu 16.04</p><h1 id="1-安装curl"><a href="#1-安装curl" class="headerlink" title="1-安装curl"></a>1-安装curl</h1><blockquote><p>$ apt install curl</p></blockquote><h1 id="2-安装rustup"><a href="#2-安装rustup" class="headerlink" title="2-安装rustup"></a>2-安装rustup</h1><blockquote><p>$ curl <a href="https://sh.rustup.rs" target="_blank" rel="noopener">https://sh.rustup.rs</a> -sSf | sh</p></blockquote><p>这个命令会帮你装好rustc, cargo等一系列后面要用到的东西，可以说是一键安装了。</p><p>中途会遇到这个3个选项，需要选一个，手动输入1，回车。</p><p><img src="/2019/02/03/Rust环境安装/rustup安装选项.png" alt="rustup安装选项"></p><p>安装成功后提示</p><p><img src="/2019/02/03/Rust环境安装/rustup安装成功.png" alt="rustup安装成功"></p><p>然后<strong>重启系统</strong>，重启会使得<strong>rust被添加到PATH中</strong>。这一步很重要。</p><p>重启后，查看是否成功。</p><blockquote><p>$ rustc —version</p></blockquote><p><img src="/2019/02/03/Rust环境安装/rustc版本.png" alt="rustc版本"></p><h1 id="3-Hello-world"><a href="#3-Hello-world" class="headerlink" title="3-Hello, world!"></a>3-Hello, world!</h1><p>Rust源文件以.rs结尾，文件中的单词以下划线分割，编写hello_world.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译+运行</p><blockquote><p>$ rustc hello_world.rs -o hello_world</p><p>$ ./hello_world</p></blockquote><p>如果显示如下，那便成功了。</p><p><img src="/2019/02/03/Rust环境安装/Hello_world.png" alt="Hello_world"></p><h1 id="4-换中科大的源"><a href="#4-换中科大的源" class="headerlink" title="4-换中科大的源"></a>4-换中科大的源</h1><p>按照上面完成后，rustc和cargo都应该自动装好了。但问题在于，速度不够快。使用cargo管理项目的时候，会涉及更新问题，但rust是被墙挡在外面的，更新速度慢是小事，可是卡的根本更新不了，就是大事了。</p><p>所以我们需要，换 <strong>中科大的源</strong> 。</p><p>操作如下：</p><ul><li>在完成上面的步骤的基础上</li><li>进入<strong>root</strong>目录，如果有 <strong>.cargo</strong> 目录就进入(应该是一个隐藏目录，用 <code>ls -a</code> 查看)，没有就新建一个 <strong>.cargo</strong> 目录，然后进入</li><li>进入 <strong>.cargo</strong> 目录后，如果有 <strong>config</strong> 文件就打开，没有就新建 <strong>config</strong> 文件</li><li><p>在 <strong>config</strong> 文件中写入如下内容，保存退出</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class="line">replace-with = &apos;ustc&apos;</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;git://mirrors.ustc.edu.cn/crate.io-index&quot;</span><br></pre></td></tr></table></figure></li><li><p>然后重启一下系统就行了，以后更新就不用翻墙啦。</p></li></ul><h1 id="5-疑难杂症"><a href="#5-疑难杂症" class="headerlink" title="5-疑难杂症"></a>5-疑难杂症</h1><p>小李哥遇到一个奇怪的问题，就是2-安装rustup完成后，重启，查看version后发现是ok的。结果装了个vim，敲完hello_world.rs，编译的时候它提示：找不到rustc！我再查看version的时候发现我的rustc没了？！</p><p>很玄学……我重启了一下系统就好了，原因未知。</p><p>emmm……查看cargo的version时再次遇到找不到cargo！rustc也找不到了！和上次的共同之处在于：我试图关闭终端的时候提示还有进程在运行，然后我直接关掉终端，再次打开终端，cargo和rustc再次出现！</p><p>真奇怪啊……</p><p>见鬼图↓，估计和环境变量有关系，应该是我自己的问题……</p><p><img src="/2019/02/03/Rust环境安装/su后找不到rustc.png" alt="su后找不到rustc"></p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 环境安装 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS2019_winter</title>
      <link href="/2019/01/31/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/31/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经一年半的学习，发现计科本科生课程中与计算机原理相关的课程多是隔靴搔痒，用到时再查书/百度也不迟，故接下来的课程中将关注点放在各章的开头1~2节，若有兴趣再继续深入。</p><p>参考书目：《操作系统教程（第5版）》费翔林</p><hr><h1 id="第一章-操作系统概论"><a href="#第一章-操作系统概论" class="headerlink" title="第一章 操作系统概论"></a>第一章 操作系统概论</h1><p><strong>PPT内容主要讲述以下问题：</strong></p><h2 id="1-单道-多道程序的CPU效率问题。"><a href="#1-单道-多道程序的CPU效率问题。" class="headerlink" title="1. 单道/多道程序的CPU效率问题。"></a>1. 单道/多道程序的CPU效率问题。</h2><h2 id="2-对于一个操作系统来说，它要有哪些功能？"><a href="#2-对于一个操作系统来说，它要有哪些功能？" class="headerlink" title="2. 对于一个操作系统来说，它要有哪些功能？"></a>2. 对于一个操作系统来说，它要有哪些功能？</h2><h2 id="3-从发明至今，有哪些操作系统，特点是什么？"><a href="#3-从发明至今，有哪些操作系统，特点是什么？" class="headerlink" title="3. 从发明至今，有哪些操作系统，特点是什么？"></a>3. 从发明至今，有哪些操作系统，特点是什么？</h2><hr><h1 id="第三章-同步、通信与死锁"><a href="#第三章-同步、通信与死锁" class="headerlink" title="第三章 同步、通信与死锁"></a>第三章 同步、通信与死锁</h1><p><strong>PPT内容主要讲述以下问题：</strong></p><h2 id="什么是并发进程"><a href="#什么是并发进程" class="headerlink" title="什么是并发进程"></a>什么是并发进程</h2><hr><h2 id="并发进程与时间无关的充分条件Bernstein条件"><a href="#并发进程与时间无关的充分条件Bernstein条件" class="headerlink" title="并发进程与时间无关的充分条件Bernstein条件"></a>并发进程与时间无关的充分条件Bernstein条件</h2><blockquote><p><strong>Bernstein条件</strong>：</p><p>设进程<strong>A</strong>引用变量集合为<strong>R1</strong>，改变变量集合为<strong>W1</strong>，进程<strong>B</strong>引用变量集合为<strong>R2</strong>，改变变量集合为<strong>W2</strong>。那么只要满足：</p><p>(R1 ∩ W2) ∪ (R2 ∩ W1) ∪ (W1 ∩ W2) = ∅</p><p>那么进程<strong>A</strong>和进程<strong>B</strong>与时间无关。</p><p>简而言之就是A和B的读写不冲突，也不会往同一个变量里写。</p></blockquote><hr><h2 id="并发进程间的交互："><a href="#并发进程间的交互：" class="headerlink" title="并发进程间的交互："></a>并发进程间的交互：</h2><ul><li>竞争关系/间接制约关系：对于同一资源区，进程互斥访问，一个进程在用资源区的时候，其他进程只能等着</li><li>协作关系/直接制约关系：进程间互发信号控制对方是沉睡还是唤醒</li></ul><hr><h2 id="并发进程引起的时间问题："><a href="#并发进程引起的时间问题：" class="headerlink" title="并发进程引起的时间问题："></a>并发进程引起的时间问题：</h2><ul><li>结果不唯一，比如订票，抢红包</li><li>永远等待</li></ul><hr><h2 id="临界区-critial-section-是什么？"><a href="#临界区-critial-section-是什么？" class="headerlink" title="临界区(critial section)是什么？"></a>临界区(critial section)是什么？</h2><blockquote><p>定义：共享资源所在程序段</p><p>调度原则：</p><ul><li>一次只能进一个</li><li>里面的，不能一直呆在里面</li><li>外面的，不能一直等在外面</li><li>有空让进，无空等待，择一而入，算法可行</li></ul></blockquote><hr><h2 id="临界区管理方法："><a href="#临界区管理方法：" class="headerlink" title="临界区管理方法："></a>临界区管理方法：</h2><ul><li><p>先检测，后置位。弊端是检测完后可能有其他进程也进入临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inside1, inside2: Boolean</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br><span class="line">inside2 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>先置位，后检测。弊端是置位后可能inside2又被置1，可能永远等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="临界区管理软件方法："><a href="#临界区管理软件方法：" class="headerlink" title="临界区管理软件方法："></a>临界区管理软件方法：</h2><ol><li><p>Dekker算法</p><blockquote><p>基本思想：</p><ol><li>进程P1进入临界区时，将inside1置为true。</li><li>若P2在临界区，则P1等待。若P2不在临界区但也想进入，询问turn变量，由turn指示谁进入。若P2不在临界区且不想进入临界区，那么P1进入临界区。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Peterson算法</p><blockquote><p>基本思想：</p><ol><li>进程P1进入临界区时，将inside1置为true，指示器turn置为2。</li><li>若P2在临界区内且turn为2，则P1等待。否则P1进入临界区，然后inside1置为false。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol><hr><h2 id="临界区管理硬件方法："><a href="#临界区管理硬件方法：" class="headerlink" title="临界区管理硬件方法："></a>临界区管理硬件方法：</h2><ol><li><p>关中断</p><p> 进入临界区前关中断，进入临界区，出临界区后开中断</p></li><li><p>用TS指令(test and set)</p><p> 反复TS代表临界区的lock变量，即“上锁”，如果该临界区空闲，会返回true，否则返回false。如果空闲，就进入临界区，否则一直反复。出临界区后lock置为true，即“开锁”。</p><blockquote><p>TS(x)指令等价于这段代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TS</span><span class="params">(<span class="keyword">bool</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">true</span>)&#123;</span><br><span class="line">        x = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><ol><li><p>用SWAP指令(在x86-64架构下是XCHG指令)</p><p> 一开始置临界区的lock变量为false，进程P的变量为key，置为true。交换一次lock和key(“上锁”)就检测一次key，如果key为false，说明临界区此时为空闲，进入临界区，出来后再次交换lock和key，即“开锁”。</p><p> 代码：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> lock = <span class="literal">false</span>;</span><br><span class="line">cobegin</span><br><span class="line">    <span class="function">process <span class="title">P</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            SWAP(key, lock);    <span class="comment">//上锁</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(key);</span><br><span class="line">        临界区;</span><br><span class="line">        SWAP(key, lock);        <span class="comment">//开锁</span></span><br><span class="line">    &#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h2><p><del>书上没讲定义，按我的理解就是对共享资源的读写一致性问题，说白了还是前面的并发进程问题没解决呗</del>。</p><p>百度说，进程同步是指的进程相互协作、等待的过程。</p><p>同步的办法有3种，信号量与PV操作、管程、消息传递。</p><hr><h2 id="信号量与PV操作"><a href="#信号量与PV操作" class="headerlink" title="信号量与PV操作"></a>信号量与PV操作</h2><p>信号量用来表示一个物理资源的使用情况，PV操作用来控制资源使用。</p><p>同步原语：P(Proberen,测试)，V(Verhogen,增量)。</p><p>除了赋初值外，信号量只能由同步原语操作。</p><p>(所谓原语，就是一段在执行过程中不许中断的指令序列)</p><hr><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><hr><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><hr><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><hr><h2 id="具体问题的解决方案"><a href="#具体问题的解决方案" class="headerlink" title="具体问题的解决方案"></a>具体问题的解决方案</h2><ul><li>生产者-消费者问题</li><li>五个哲学家吃通心面问题</li><li>读者-写者问题</li><li>理发师问题</li></ul><hr><h1 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h1><h2 id="成绩组成"><a href="#成绩组成" class="headerlink" title="成绩组成"></a>成绩组成</h2><p>平时作业：10%<br>实验：30%<br>期中：10%<br>期末：50%</p><p>实验类似PA，阶段之间有联系，硬DDL<br>期中讲完3章考</p><h1 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>一些敏感系统不用操作系统的原因：</p><ol><li>直接汇编放内存速度快</li><li>防止出错？？</li></ol><p>裸机：未安装操作系统的计算机</p><p>操作系统的主要目标：</p><ol><li>扩大机器功能</li><li>管理系统资源</li><li>提高系统效率</li><li>构筑开发环境</li><li>方便用户使用</li></ol><p>资源管理技术：复用、虚拟、抽象</p><h2 id="资源复用"><a href="#资源复用" class="headerlink" title="资源复用"></a>资源复用</h2><h3 id="空分复用共享"><a href="#空分复用共享" class="headerlink" title="空分复用共享"></a>空分复用共享</h3><p>例如，将内存、磁盘，按4KB一页划分，分配给不同进程。</p><h3 id="时分复用共享"><a href="#时分复用共享" class="headerlink" title="时分复用共享"></a>时分复用共享</h3><p>时分独占式：<br>进程1使用一个完整周期后才释放资源。</p><p>时分共享式：<br>例如，将CPU使用时间分为若干个时间片，进程1使用第1、3、5片，进程2使用第2、4、6片…</p><h2 id="资源虚拟"><a href="#资源虚拟" class="headerlink" title="资源虚拟"></a>资源虚拟</h2><p>把物理资源变成逻辑上的多个对应物。<br>例如，计算机连接到打印机，发送打印命令时，先发到虚拟的打印机，等一个打印文件完全发到虚拟打印机后，物理打印机才开始打印。有多个文件请求打印时，进入虚拟的打印机的队列。</p><h2 id="资源抽象"><a href="#资源抽象" class="headerlink" title="资源抽象"></a>资源抽象</h2><p>用软件来屏蔽硬件实现细节，只要调用API就行了</p><p>操作系统：管理计算机硬件资源的系统软件，为用户提供交互界面，提升硬件使用效率，主要方法是复用、虚拟和抽象。<br>2019-2-26</p><hr><h2 id="认识操作系统的四种观点"><a href="#认识操作系统的四种观点" class="headerlink" title="认识操作系统的四种观点"></a>认识操作系统的四种观点</h2><h3 id="服务用户观点"><a href="#服务用户观点" class="headerlink" title="服务用户观点"></a>服务用户观点</h3><p>系统调用向API提供服务</p><p>操作系统提供良好的人机界面</p><h3 id="进程交互观点"><a href="#进程交互观点" class="headerlink" title="进程交互观点"></a>进程交互观点</h3><p>操作系统作为<strong>进程执行的控制者和执行者</strong></p><ul><li>OS需要提供机制，解决并发进程的<strong>互斥、同步、通信和死锁问题</strong></li></ul><h3 id="系统实现观点"><a href="#系统实现观点" class="headerlink" title="系统实现观点"></a>系统实现观点</h3><p>操作系统作为扩展机或虚拟机，把硬件的复杂性与用户隔离开来。</p><ul><li>把操作系统分为若干层次，逐步添加到裸机上，系统功能就能增加一点形成操作系统虚拟机</li><li>扩充后的虚拟机不仅能使用<strong>硬件指令</strong>，还能使用<strong>系统指令</strong></li></ul><h3 id="资源管理观点"><a href="#资源管理观点" class="headerlink" title="资源管理观点"></a>资源管理观点</h3><p>操作系统对软硬件资源进行<strong>资源复用、虚拟和抽象</strong></p><p>管理各种资源</p><h2 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h2><h3 id="处理器管理"><a href="#处理器管理" class="headerlink" title="处理器管理"></a>处理器管理</h3><p>多道程序设计，提高处理器效率。</p><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><p>主要是管理内存，包括</p><ul><li>内存分配</li><li>地址转换</li><li>存储保护</li><li>内存共享</li><li>存储扩充</li></ul><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>主要任务</p><ul><li>管理外设</li><li>发挥设备的并行性</li><li>提供设备驱动程序和中断处理程序</li></ul><p>核心功能</p><ul><li>设备中断处理</li><li>缓冲区管理</li><li>设备独立性<ul><li>实现逻辑设备到物理设备之间的映射</li></ul></li><li>设备的分配和回收</li><li>共享型设备的驱动调度</li><li>虚拟设备</li></ul><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>对用户文件和系统文件进行管理</p><ul><li>文件逻辑组织方法</li><li>文件物理组织方法</li><li>文件存取和使用方法</li><li>文件目录管理</li><li>文件共享和安全性控制</li></ul><h3 id="网络与通信管理"><a href="#网络与通信管理" class="headerlink" title="网络与通信管理"></a>网络与通信管理</h3><p>通过网络协议进行管理</p><h2 id="操作系统主要特性"><a href="#操作系统主要特性" class="headerlink" title="操作系统主要特性"></a>操作系统主要特性</h2><h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><p>并发：指的是两个或两个以上的事件在同一时间间隔内（比如1分钟内）发生<br>并行：在同一时刻发生</p><p>要求实现多个进程间的安全切换</p><h3 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h3><p>解决读写一致问题、临界区之类的问题</p><h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><p>进程的开始、暂停、前进速度都是随机的</p><p>作业到达系统的类型和时间是随机的</p><p>操作员发命令或按按钮的时刻是随机的</p><p>程序出错是随机的</p><p>软硬件中断是随机的</p><p><strong>所以需要解决和时间有关的错误</strong></p><h2 id="多道程序设计效果"><a href="#多道程序设计效果" class="headerlink" title="多道程序设计效果"></a>多道程序设计效果</h2><ol><li><p>提高了系统效率</p></li><li><p>延长了每道题的计算时间</p></li><li><p>牺牲了用户的响应时间</p></li></ol><p>假设程序等待IO的时间占其运行时间比为p，n道程序同时等待的概率是$p^n$，那么CPU效率是$1-p^n$。</p><h2 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h2><p>作业是指把程序、数据连同作业说明书组织起来的任务单位</p><p>批作业是指把批中的作业预先输入作业队列，由操作系统按照说明来调度和控制作业执行，形成自动转接和连续处理作业。</p><p>特点：</p><ul><li>用户脱机工作</li><li>成批处理作业</li><li>多道程序运行</li><li>作业周转时间长</li></ul><h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><ul><li>多个联机用户同时使用一个计算机系统在各自的终端上进行交互式对话</li><li>程序、数据和命令都在会话过程中产生，通过问答方式控制程序</li><li>处理器分为时间片给不同用户</li></ul><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><ul><li>外部事件产生时，快速处理</li></ul><hr><p>地址转换</p><p>2019-2-28</p><hr><h2 id="操作系统基本服务和用户接口"><a href="#操作系统基本服务和用户接口" class="headerlink" title="操作系统基本服务和用户接口"></a>操作系统基本服务和用户接口</h2><h3 id="基本服务和用户接口"><a href="#基本服务和用户接口" class="headerlink" title="基本服务和用户接口"></a>基本服务和用户接口</h3><p>基本服务</p><ul><li>创建程序</li><li>执行程序</li><li>数据IO</li><li>通信服务</li><li>错误检测和处理</li><li>资源分配、统计、保护</li></ul><h3 id="程序接口与系统调用"><a href="#程序接口与系统调用" class="headerlink" title="程序接口与系统调用"></a>程序接口与系统调用</h3><p>各种Linux版本之间相同点在于内核，内核只有版本号不一样。即内核版本相同的ubuntu和debian，能支持一样的软件。</p><p>用户态-&gt;内核态通过IDT，内核态-&gt;用户态iret</p><p>异常分类：</p><ul><li>故障(fault)：可恢复错误</li><li>陷阱(trap)：用户态-&gt;内核态</li><li>终止(abort)：不可恢复错误，不返回</li></ul><p>POSIX标准：<br>规定操作系统必须提供API，未规定接口的实现是采用系统调用、库函数还是其他形式。</p><p>函数库：</p><ul><li>静态库：编译时把库函数作为代码的一部分，生成bin</li><li>动态库/共享库：如DLL，编译时只给出入口地址，运行到这才加载</li></ul><p>系统调用时的过程、内核栈</p><p>区分系统调用过程中的中断向量号和系统调用号：压栈时取反再压</p><p>禁用一个syscall: sys_ni_syscall</p><p>添加一个syscall: 看ppt</p><h3 id="操作接口"><a href="#操作接口" class="headerlink" title="操作接口"></a>操作接口</h3><p>作业控制方式：</p><ul><li>联机：有命令行交互，人敲一句机器干一句/处理一个.bat文件</li><li>脱机：用JCL(job control language)语言把作业说明书塞给机器，然后人走了机器继续干活</li></ul><h3 id="系统程序"><a href="#系统程序" class="headerlink" title="系统程序"></a>系统程序</h3><p>运行于用户态</p><p>分类：</p><ul><li>文件管理</li><li>状态信息</li><li>对编程语言的支持</li></ul><h2 id="操作系统结构与运行模型"><a href="#操作系统结构与运行模型" class="headerlink" title="操作系统结构与运行模型"></a>操作系统结构与运行模型</h2><h3 id="结构分类"><a href="#结构分类" class="headerlink" title="结构分类"></a>结构分类</h3><ul><li>单体式：模块组合，互相接口，可以互相调用，数据是全程量，缺点：牵一发而动全身</li><li>层次式：分中断-内存-进程-IO（不全）等等多层，自下到顶</li><li>微内核：仅具有很少的必要功能，很小</li><li>虚拟机：用一个物理机模拟另一个物理机，通过分时使用管理多台机器。CMS?用户交互CMS，CMS交互硬件。</li></ul><p>原语不可中断</p><p>单内核功能多，效率高，但修改之后要重新编译<br>微内核容量小，额外功能都通过服务来完成，不用重新编译</p><p>Linux的做法：可加载内核模块，需要的时候像零件一样装上去拆下来，不用重新编译整个内核</p><h3 id="Linux中断处理"><a href="#Linux中断处理" class="headerlink" title="Linux中断处理"></a>Linux中断处理</h3><p>中断分快中断和慢中断</p><p>x86提供了15根 IRQ 线，但可以接入的设备不止15台，连到同一根 IRQ 线的设备有不同的<code>中断服务例程</code></p><p>最早的“下半部”实现机制：bottom half，静态创建，32个元素的链表，全局同步，不允许在任何两个 BH 同时执行</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
