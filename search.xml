<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图论定理收集</title>
      <link href="/2019/02/26/%E5%9B%BE%E8%AE%BA%E5%AE%9A%E7%90%86%E6%94%B6%E9%9B%86/"/>
      <url>/2019/02/26/%E5%9B%BE%E8%AE%BA%E5%AE%9A%E7%90%86%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>参考书目：《图论与网络理论》和ppt</p><h1 id="第一章-图的基本概念"><a href="#第一章-图的基本概念" class="headerlink" title="第一章 图的基本概念"></a>第一章 图的基本概念</h1><p>定理1.1.1 对任何图G，各顶点度数之和等于边数的2倍。即$ \sum_{\nu\in V(G)}d(\nu) = 2\varepsilon. $</p>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高程学习笔记</title>
      <link href="/2019/02/26/%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/26/%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>高级程序设计复习笔记</p><p>参考书目：<br>《程序设计教程—用C++语言描述》陈家骏、郑滔<br>《Thinking in C++》机械工业出版社</p><h1 id="第一章-复习程设基础"><a href="#第一章-复习程设基础" class="headerlink" title="第一章 复习程设基础"></a>第一章 复习程设基础</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>分数组成：<br>作业10%<br>上机40%（现场oj和课后projects）<br>期末50%（据说较为简单）</p><h2 id="C-C-数据类型"><a href="#C-C-数据类型" class="headerlink" title="C/C++数据类型"></a>C/C++数据类型</h2><p><code>unsigned</code>类型运算不封闭，+*/封闭，-不封闭</p><p><code>float</code>类型 0.1+0.2!=0.3之类的</p><p><code>实数</code>相等条件，比较差的绝对值是否小于一个很小的数</p><p>联合类型用于用一种类型表示多种类型的数据，例如不同类型的数据组织在一起不能用array</p><p>指针是内存地址的抽象，用于动态变量（链表）、传递参数</p><h2 id="C-过程抽象"><a href="#C-过程抽象" class="headerlink" title="C++过程抽象"></a>C++过程抽象</h2><p><code>C++函数</code>与<code>数学函数</code>区别：</p><ol><li>C++函数可以没有返回值</li><li>可以有副作用(side effect)</li><li>同一个实参，不同时刻调用结果可以不一样</li></ol><h2 id="内存区安排"><a href="#内存区安排" class="headerlink" title="内存区安排"></a>内存区安排</h2><p>静态数据区</p><ul><li>全局变量</li><li>static局部变量</li><li>常量</li></ul><p>2019-2-26</p><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网学习笔记</title>
      <link href="/2019/02/25/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/25/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>计算机网络（Computer Network）复习笔记</p><p>参考书目：《计算机网络自顶向下方法（第5版）》机械工业出版社</p><h1 id="CH1-Introduction-of-Networking-1"><a href="#CH1-Introduction-of-Networking-1" class="headerlink" title="CH1-Introduction of Networking-1"></a>CH1-Introduction of Networking-1</h1><h2 id="杂记："><a href="#杂记：" class="headerlink" title="杂记："></a>杂记：</h2><p>CN负责数字通信（数字信号）</p><p>哈罗车筐前黑色是太阳能板？</p><p>宿舍-一层-一楼-学校网络中心-南京教育网（东大）-全国教育网</p><p>第一台联网计算机在UCLA</p><p>remote medicine 瓶颈在于时延</p><p>行星间联网，光速瓶颈</p><p>因特网是一个复杂系统，分解为<strong>5个子问题</strong>，谁来分解？如何分解？</p><hr><h2 id="课程主要讲述："><a href="#课程主要讲述：" class="headerlink" title="课程主要讲述："></a>课程主要讲述：</h2><ol><li>因特网如何工作？</li><li>子问题为什么这样解决？</li></ol><h2 id="讲解顺序："><a href="#讲解顺序：" class="headerlink" title="讲解顺序："></a>讲解顺序：</h2><ol><li>基础：包、链路、复用、时延、丢包</li><li>低级技术：以太网，无线局域网，3g，4g</li><li>IP，路由，BGP</li><li>网络互通后如何交换信息：DNS,CDN,HTTP,TCP</li><li>热点问题：数据中心、</li></ol><h2 id="课程任务："><a href="#课程任务：" class="headerlink" title="课程任务："></a>课程任务：</h2><ol><li>实验25%（现场提问，验收，改代码，严格）</li><li>作业15%</li><li>期末考试60%</li></ol><hr><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>交换方式</p><ol><li>电路交换：最基础的交换方式。点对点<br> 特点：<ol><li>中间所有资源都预留好</li><li>admission control per connection</li></ol></li><li>包交换：大家都把数据分为小数据包，一股脑发到交换机，交换机再转发，自由竞争，冲突了就丢一个，一个小包失败了就再发一次。（核心思想：统计复用）<br> 特点：<ol><li>包独立处理</li><li>admission control per packet</li></ol></li><li>虚链路：在包交换中给vip用户优先权，以便冲突时优先满足vip用户</li></ol><hr><p>电路交换：src和dst之间直接连接（中间类似于多刀多掷开关）</p><p>时间分片：比如，将1ms分为500片，500个用户同话，用户1通话时只占用1ms的第1片，然后若干个1ms组成了通话时间。</p><p>频率分片：将频率切片，比如1Mhz的一段切成100片分给不同的用户，实际上要分很多级不然没法满足几亿用户的分配需求，频率之间不干扰，频率由国家严格控制</p><p>2019-2-25</p><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法设计与分析》学习笔记</title>
      <link href="/2019/02/10/%E3%80%8A%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/10/%E3%80%8A%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇供日后复习，跳跃性很大，随性更新。</p><p>参考书目：《算法设计与分析》 黄宇 机械工业出版社</p><h1 id="第2章-从算法的角度重新审视数学的概念"><a href="#第2章-从算法的角度重新审视数学的概念" class="headerlink" title="第2章 从算法的角度重新审视数学的概念"></a>第2章 从算法的角度重新审视数学的概念</h1><h3 id="2-1-3-阶乘n"><a href="#2-1-3-阶乘n" class="headerlink" title="2.1.3 阶乘n!"></a>2.1.3 阶乘n!</h3><p>根据<code>Stirling公式</code>，可以将<code>n!</code>转化为更易于处理的闭形式，对<code>n&gt;=1</code>，有：</p><p>$$ \sqrt{2\pi n}(\frac{n}{e})^n &lt; n! &lt; \sqrt{2\pi n}(\frac{n}{e})^n(1+\frac{1}{11n}) $$</p><p><code>Stirling公式</code>也可以写成：</p><p>$$ n! = \sqrt{2\pi n}(\frac{n}{e})^n e^{\varepsilon(n)},其中\frac{1}{12n+1} \leq \varepsilon(n) \leq \frac{1}{12n} $$</p><p>写成近似形式：</p><p>$$ n! = \sqrt{2\pi n}(\frac{n}{e})^n(1+\Theta(\frac{1}{n})) $$</p><p>由于 $\Theta(\frac{1}{n})$ 是无穷小量，$\lim\limits_{n \to \infty} \frac{1}{n}=0$ ，忽略。所以得到进一步的近似式：</p><p>$$ n! \approx \sqrt{2\pi n}(\frac{n}{e})^n $$</p><h3 id="2-1-4-常见级数求和-sum-limits-i-1-n-f-i"><a href="#2-1-4-常见级数求和-sum-limits-i-1-n-f-i" class="headerlink" title="2.1.4 常见级数求和 $\sum\limits_{i=1}^{n}f(i)$"></a>2.1.4 常见级数求和 $\sum\limits_{i=1}^{n}f(i)$</h3><ul><li>多项式级数(polynomial series)<br>  $ \sum\limits_{i=1}^{n}i = \dfrac{n(n+1)}{2} $<br>  .<br>  $ \sum\limits_{i=1}^{n}i^2 = \dfrac{1}{3}n(n+\dfrac{1}{2})(n+1) $<br>  .<br>  $ \sum\limits_{i=1}^{n}i^k = \Theta(\dfrac{1}{k+1}n^{k+1}) $<br>  .</li><li>几何级数(geometric series)<br>  $ \sum\limits_{i=0}^{k}ar^i = a(\dfrac{r^{k+1}-1}{r-1}) $</li></ul><p>测试用<br>$\begin{eqnarray}f(x,y)<br>    &amp;=&amp;2xy+(x-y)^2\<br>    &amp;=&amp;x^2+y^2<br>\end{eqnarray}$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复习 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习笔记</title>
      <link href="/2019/02/05/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/05/Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title="?"></a>?</h1><h2 id="while中的let问题"><a href="#while中的let问题" class="headerlink" title="while中的let问题"></a>while中的let问题</h2><p>这是一段简单的遍历数组代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> array: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, array[index]);</span><br><span class="line"></span><br><span class="line">    index = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果显然</p><p><img src="/2019/02/05/Rust学习笔记/正常遍历结果.png" alt="正常遍历结果"></p><p>但如果略作修改，即index的mut关键字去掉，在迭代时用let index 隐藏原来的index<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> array: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, array[index]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> index = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果就是无限输出10。</p><hr><p>## </p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安装参考网站</title>
      <link href="/2019/02/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/"/>
      <url>/2019/02/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%82%E8%80%83%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文包含一些软件的优秀安装指南，都是亲测可用的。以备以后重新安装系统快速使用，本文会热更新。</p><p>每段的格式为：</p><ul><li><p>[已有教程网址]</p></li><li><p>[排除教程中的坑]</p></li><li><p>[对教程中的简要概括(防止教程404)]</p></li></ul><hr><h1 id="蓝灯lantern"><a href="#蓝灯lantern" class="headerlink" title="蓝灯lantern"></a>蓝灯lantern</h1><ul><li><p>教程：<a href="http://www.pianshen.com/article/5553973/" target="_blank" rel="noopener">lantern傻瓜式安装教程</a></p></li><li><p>排坑：进入 <a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener">https://github.com/getlantern/lantern</a> 最下面。如果左击 <strong>ubuntu 14.04 64 bit</strong> 后没有直接下载：右击 <strong>ubuntu 14.04 64 bit</strong> 用迅雷下载链接。</p></li></ul><hr><h1 id="sublime-text-3"><a href="#sublime-text-3" class="headerlink" title="sublime text 3"></a>sublime text 3</h1><ul><li><p>教程：<a href="https://jingyan.baidu.com/article/64d05a023cd849de55f73be4.html" target="_blank" rel="noopener">命令行安装sublime text 3</a></p></li><li><p>概括：三条命令即可</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/sublime-text-3</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sublime-text-installer</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust环境安装+换中科大源</title>
      <link href="/2019/02/03/Rust%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2019/02/03/Rust%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>vct说Rust环境配置很复杂，小李哥不信邪地来打算试一试。</p><p>操作系统：Ubuntu 16.04</p><h1 id="1-安装curl"><a href="#1-安装curl" class="headerlink" title="1-安装curl"></a>1-安装curl</h1><blockquote><p>$ apt install curl</p></blockquote><h1 id="2-安装rustup"><a href="#2-安装rustup" class="headerlink" title="2-安装rustup"></a>2-安装rustup</h1><blockquote><p>$ curl <a href="https://sh.rustup.rs" target="_blank" rel="noopener">https://sh.rustup.rs</a> -sSf | sh</p></blockquote><p>这个命令会帮你装好rustc, cargo等一系列后面要用到的东西，可以说是一键安装了。</p><p>中途会遇到这个3个选项，需要选一个，手动输入1，回车。</p><p><img src="/2019/02/03/Rust环境安装/rustup安装选项.png" alt="rustup安装选项"></p><p>安装成功后提示</p><p><img src="/2019/02/03/Rust环境安装/rustup安装成功.png" alt="rustup安装成功"></p><p>然后<strong>重启系统</strong>，重启会使得<strong>rust被添加到PATH中</strong>。这一步很重要。</p><p>重启后，查看是否成功。</p><blockquote><p>$ rustc –version</p></blockquote><p><img src="/2019/02/03/Rust环境安装/rustc版本.png" alt="rustc版本"></p><h1 id="3-Hello-world"><a href="#3-Hello-world" class="headerlink" title="3-Hello, world!"></a>3-Hello, world!</h1><p>Rust源文件以.rs结尾，文件中的单词以下划线分割，编写hello_world.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译+运行</p><blockquote><p>$ rustc hello_world.rs -o hello_world</p></blockquote><blockquote><p>$ ./hello_world</p></blockquote><p>如果显示如下，那便成功了。</p><p><img src="/2019/02/03/Rust环境安装/Hello_world.png" alt="Hello_world"></p><h1 id="4-换中科大的源"><a href="#4-换中科大的源" class="headerlink" title="4-换中科大的源"></a>4-换中科大的源</h1><p>按照上面完成后，rustc和cargo都应该自动装好了。但问题在于，速度不够快。使用cargo管理项目的时候，会涉及更新问题，但rust是被墙挡在外面的，更新速度慢是小事，可是卡的根本更新不了，就是大事了。</p><p>所以我们需要，换 <strong>中科大的源</strong> 。</p><p>操作如下：</p><ul><li>在完成上面的步骤的基础上</li><li>进入<strong>root</strong>目录，如果有 <strong>.cargo</strong> 目录就进入(应该是一个隐藏目录，用 <code>ls -a</code> 查看)，没有就新建一个 <strong>.cargo</strong> 目录，然后进入</li><li>进入 <strong>.cargo</strong> 目录后，如果有 <strong>config</strong> 文件就打开，没有就新建 <strong>config</strong> 文件</li><li><p>在 <strong>config</strong> 文件中写入如下内容，保存退出</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class="line">replace-with = &apos;ustc&apos;</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;git://mirrors.ustc.edu.cn/crate.io-index&quot;</span><br></pre></td></tr></table></figure></li><li><p>然后重启一下系统就行了，以后更新就不用翻墙啦。</p></li></ul><h1 id="5-疑难杂症"><a href="#5-疑难杂症" class="headerlink" title="5-疑难杂症"></a>5-疑难杂症</h1><p>小李哥遇到一个奇怪的问题，就是2-安装rustup完成后，重启，查看version后发现是ok的。结果装了个vim，敲完hello_world.rs，编译的时候它提示：找不到rustc！我再查看version的时候发现我的rustc没了？！</p><p>很玄学……我重启了一下系统就好了，原因未知。</p><p>emmm……查看cargo的version时再次遇到找不到cargo！rustc也找不到了！和上次的共同之处在于：我试图关闭终端的时候提示还有进程在运行，然后我直接关掉终端，再次打开终端，cargo和rustc再次出现！</p><p>真奇怪啊……</p><p>见鬼图↓，估计和环境变量有关系，应该是我自己的问题……</p><p><img src="/2019/02/03/Rust环境安装/su后找不到rustc.png" alt="su后找不到rustc"></p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> 环境安装 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS2019_winter</title>
      <link href="/2019/01/31/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/31/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>经一年半的学习，发现计科本科生课程中与计算机原理相关的课程多是隔靴搔痒，用到时再查书/百度也不迟，故接下来的课程中将关注点放在各章的开头1~2节，若有兴趣再继续深入。</p><p>参考书目：《操作系统教程（第5版）》费翔林</p><hr><h1 id="第一章-操作系统概论"><a href="#第一章-操作系统概论" class="headerlink" title="第一章 操作系统概论"></a>第一章 操作系统概论</h1><p><strong>PPT内容主要讲述以下问题：</strong></p><h2 id="1-单道-多道程序的CPU效率问题。"><a href="#1-单道-多道程序的CPU效率问题。" class="headerlink" title="1. 单道/多道程序的CPU效率问题。"></a>1. 单道/多道程序的CPU效率问题。</h2><h2 id="2-对于一个操作系统来说，它要有哪些功能？"><a href="#2-对于一个操作系统来说，它要有哪些功能？" class="headerlink" title="2. 对于一个操作系统来说，它要有哪些功能？"></a>2. 对于一个操作系统来说，它要有哪些功能？</h2><h2 id="3-从发明至今，有哪些操作系统，特点是什么？"><a href="#3-从发明至今，有哪些操作系统，特点是什么？" class="headerlink" title="3. 从发明至今，有哪些操作系统，特点是什么？"></a>3. 从发明至今，有哪些操作系统，特点是什么？</h2><hr><h1 id="第三章-同步、通信与死锁"><a href="#第三章-同步、通信与死锁" class="headerlink" title="第三章 同步、通信与死锁"></a>第三章 同步、通信与死锁</h1><p><strong>PPT内容主要讲述以下问题：</strong></p><h2 id="什么是并发进程"><a href="#什么是并发进程" class="headerlink" title="什么是并发进程"></a>什么是并发进程</h2><hr><h2 id="并发进程与时间无关的充分条件Bernstein条件"><a href="#并发进程与时间无关的充分条件Bernstein条件" class="headerlink" title="并发进程与时间无关的充分条件Bernstein条件"></a>并发进程与时间无关的充分条件Bernstein条件</h2><blockquote><p><strong>Bernstein条件</strong>：</p><p>设进程<strong>A</strong>引用变量集合为<strong>R1</strong>，改变变量集合为<strong>W1</strong>，进程<strong>B</strong>引用变量集合为<strong>R2</strong>，改变变量集合为<strong>W2</strong>。那么只要满足：</p><p>(R1 ∩ W2) ∪ (R2 ∩ W1) ∪ (W1 ∩ W2) = ∅</p><p>那么进程<strong>A</strong>和进程<strong>B</strong>与时间无关。</p></blockquote><blockquote><p>简而言之就是A和B的读写不冲突，也不会往同一个变量里写。</p></blockquote><hr><h2 id="并发进程间的交互："><a href="#并发进程间的交互：" class="headerlink" title="并发进程间的交互："></a>并发进程间的交互：</h2><ul><li>竞争关系/间接制约关系：对于同一资源区，进程互斥访问，一个进程在用资源区的时候，其他进程只能等着</li><li>协作关系/直接制约关系：进程间互发信号控制对方是沉睡还是唤醒</li></ul><hr><h2 id="并发进程引起的时间问题："><a href="#并发进程引起的时间问题：" class="headerlink" title="并发进程引起的时间问题："></a>并发进程引起的时间问题：</h2><ul><li>结果不唯一，比如订票，抢红包</li><li>永远等待</li></ul><hr><h2 id="临界区-critial-section-是什么？"><a href="#临界区-critial-section-是什么？" class="headerlink" title="临界区(critial section)是什么？"></a>临界区(critial section)是什么？</h2><blockquote><p>定义：共享资源所在程序段</p><p>调度原则：</p><ul><li>一次只能进一个</li><li>里面的，不能一直呆在里面</li><li>外面的，不能一直等在外面</li><li>有空让进，无空等待，择一而入，算法可行</li></ul></blockquote><hr><h2 id="临界区管理方法："><a href="#临界区管理方法：" class="headerlink" title="临界区管理方法："></a>临界区管理方法：</h2><ul><li><p>先检测，后置位。弊端是检测完后可能有其他进程也进入临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inside1, inside2: Boolean</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br><span class="line">inside2 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>先置位，后检测。弊端是置位后可能inside2又被置1，可能永远等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="临界区管理软件方法："><a href="#临界区管理软件方法：" class="headerlink" title="临界区管理软件方法："></a>临界区管理软件方法：</h2><ol><li><p>Dekker算法</p><blockquote><p>基本思想：</p><ol><li>进程P1进入临界区时，将inside1置为true。</li><li>若P2在临界区，则P1等待。若P2不在临界区但也想进入，询问turn变量，由turn指示谁进入。若P2不在临界区且不想进入临界区，那么P1进入临界区。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Peterson算法</p><blockquote><p>基本思想：</p><ol><li>进程P1进入临界区时，将inside1置为true，指示器turn置为2。</li><li>若P2在临界区内且turn为2，则P1等待。否则P1进入临界区，然后inside1置为false。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol><hr><h2 id="临界区管理硬件方法："><a href="#临界区管理硬件方法：" class="headerlink" title="临界区管理硬件方法："></a>临界区管理硬件方法：</h2><ol><li><p>关中断</p><p> 进入临界区前关中断，进入临界区，出临界区后开中断</p></li><li><p>用TS指令(test and set)</p><p> 反复TS代表临界区的lock变量，即“上锁”，如果该临界区空闲，会返回true，否则返回false。如果空闲，就进入临界区，否则一直反复。出临界区后lock置为true，即“开锁”。</p><blockquote><p>TS(x)指令等价于这段代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TS</span><span class="params">(<span class="keyword">bool</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">true</span>)&#123;</span><br><span class="line">        x = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><ol start="3"><li><p>用SWAP指令(在x86-64架构下是XCHG指令)</p><p> 一开始置临界区的lock变量为false，进程P的变量为key，置为true。交换一次lock和key(“上锁”)就检测一次key，如果key为false，说明临界区此时为空闲，进入临界区，出来后再次交换lock和key，即“开锁”。</p><p> 代码：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> lock = <span class="literal">false</span>;</span><br><span class="line">cobegin</span><br><span class="line">    <span class="function">process <span class="title">P</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            SWAP(key, lock);    <span class="comment">//上锁</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(key);</span><br><span class="line">        临界区;</span><br><span class="line">        SWAP(key, lock);        <span class="comment">//开锁</span></span><br><span class="line">    &#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h2><p><del>书上没讲定义，按我的理解就是对共享资源的读写一致性问题，说白了还是前面的并发进程问题没解决呗</del>。</p><p>百度说，进程同步是指的进程相互协作、等待的过程。</p><p>同步的办法有3种，信号量与PV操作、管程、消息传递。</p><hr><h2 id="信号量与PV操作"><a href="#信号量与PV操作" class="headerlink" title="信号量与PV操作"></a>信号量与PV操作</h2><p>信号量用来表示一个物理资源的使用情况，PV操作用来控制资源使用。</p><p>同步原语：P(Proberen,测试)，V(Verhogen,增量)。</p><p>除了赋初值外，信号量只能由同步原语操作。</p><p>(所谓原语，就是一段在执行过程中不许中断的指令序列)</p><hr><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><hr><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><hr><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><hr><h2 id="具体问题的解决方案"><a href="#具体问题的解决方案" class="headerlink" title="具体问题的解决方案"></a>具体问题的解决方案</h2><ul><li>生产者-消费者问题</li><li>五个哲学家吃通心面问题</li><li>读者-写者问题</li><li>理发师问题</li></ul><hr><h1 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h1><h2 id="成绩组成"><a href="#成绩组成" class="headerlink" title="成绩组成"></a>成绩组成</h2><p>平时作业：10%<br>实验：30%<br>期中：10%<br>期末：50%</p><p>实验类似PA，阶段之间有联系，硬DDL<br>期中讲完3章考</p><h1 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>一些敏感系统不用操作系统的原因：</p><ol><li>直接汇编放内存速度快</li><li>防止出错？？</li></ol><p>裸机：未安装操作系统的计算机</p><p>操作系统的主要目标：</p><ol><li>扩大机器功能</li><li>管理系统资源</li><li>提高系统效率</li><li>构筑开发环境</li><li>方便用户使用</li></ol><p>资源管理技术：复用、虚拟、抽象</p><h2 id="资源复用"><a href="#资源复用" class="headerlink" title="资源复用"></a>资源复用</h2><h3 id="空分复用共享"><a href="#空分复用共享" class="headerlink" title="空分复用共享"></a>空分复用共享</h3><p>例如，将内存、磁盘，按4KB一页划分，分配给不同进程。</p><h3 id="时分复用共享"><a href="#时分复用共享" class="headerlink" title="时分复用共享"></a>时分复用共享</h3><p>时分独占式：<br>进程1使用一个完整周期后才释放资源。</p><p>时分共享式：<br>例如，将CPU使用时间分为若干个时间片，进程1使用第1、3、5片，进程2使用第2、4、6片…</p><h2 id="资源虚拟"><a href="#资源虚拟" class="headerlink" title="资源虚拟"></a>资源虚拟</h2><p>把物理资源变成逻辑上的多个对应物。<br>例如，计算机连接到打印机，发送打印命令时，先发到虚拟的打印机，等一个打印文件完全发到虚拟打印机后，物理打印机才开始打印。有多个文件请求打印时，进入虚拟的打印机的队列。</p><h2 id="资源抽象"><a href="#资源抽象" class="headerlink" title="资源抽象"></a>资源抽象</h2><p>用软件来屏蔽硬件实现细节，只要调用API就行了</p><p>操作系统：管理计算机硬件资源的系统软件，为用户提供交互界面，提升硬件使用效率，主要方法是复用、虚拟和抽象。<br>2019-2-26</p><hr>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
