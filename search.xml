<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OS2019_winter</title>
      <link href="/2019/01/31/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/01/31/OS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习笔记2019winter"><a href="#操作系统学习笔记2019winter" class="headerlink" title="操作系统学习笔记2019winter"></a>操作系统学习笔记2019winter</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经一年半的学习，发现计科本科生课程中与计算机原理相关的课程多是隔靴搔痒，用到时再查书/百度也不迟，故接下来的课程中将关注点放在各章的开头1~2节，若有兴趣再继续深入。</p><p>参考书目：《操作系统教程（第5版）》费翔林</p><hr><h2 id="第一章-操作系统概论"><a href="#第一章-操作系统概论" class="headerlink" title="第一章 操作系统概论"></a>第一章 操作系统概论</h2><h3 id="PPT内容主要讲述以下问题："><a href="#PPT内容主要讲述以下问题：" class="headerlink" title="PPT内容主要讲述以下问题："></a>PPT内容主要讲述以下问题：</h3><p><strong>1. 单道/多道程序的CPU效率问题。</strong></p><p><strong>2. 对于一个操作系统来说，它要有哪些功能？</strong></p><p><strong>3. 从发明至今，有哪些操作系统，特点是什么？</strong></p><hr><h2 id="第三章-同步、通信与死锁"><a href="#第三章-同步、通信与死锁" class="headerlink" title="第三章 同步、通信与死锁"></a>第三章 同步、通信与死锁</h2><h3 id="PPT内容主要讲述以下问题：-1"><a href="#PPT内容主要讲述以下问题：-1" class="headerlink" title="PPT内容主要讲述以下问题："></a>PPT内容主要讲述以下问题：</h3><p><strong>什么是并发进程？</strong></p><hr><p><strong>并发进程与时间无关的充分条件Bernstein条件</strong></p><blockquote><p><strong>Bernstein条件</strong>：</p><p>设进程<strong>A</strong>引用变量集合为<strong>R1</strong>，改变变量集合为<strong>W1</strong>，进程<strong>B</strong>引用变量集合为<strong>R2</strong>，改变变量集合为<strong>W2</strong>。那么只要满足：</p><p>(R1 ∩ W2) ∪ (R2 ∩ W1) ∪ (W1 ∩ W2) = ∅</p><p>那么进程<strong>A</strong>和进程<strong>B</strong>与时间无关。</p></blockquote><blockquote><p>简而言之就是A和B的读写不冲突，也不会往同一个变量里写。</p></blockquote><hr><p><strong>并发进程间的交互：</strong></p><ul><li>竞争关系/间接制约关系：对于同一资源区，进程互斥访问，一个进程在用资源区的时候，其他进程只能等着</li><li>协作关系/直接制约关系：进程间互发信号控制对方是沉睡还是唤醒</li></ul><hr><p><strong>并发进程引起的时间问题：</strong></p><ul><li>结果不唯一，比如订票，抢红包</li><li>永远等待</li></ul><hr><p><strong>临界区(critial section)是什么？</strong></p><blockquote><p>定义：共享资源所在程序段</p><p>调度原则：</p><ul><li>一次只能进一个</li><li>里面的，不能一直呆在里面</li><li>外面的，不能一直等在外面</li><li>有空让进，无空等待，择一而入，算法可行</li></ul></blockquote><hr><p><strong>临界区管理方法：</strong></p><ul><li><p>先检测，后置位。弊端是检测完后可能有其他进程也进入临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>先置位，后检测。弊端是置位后可能inside2又被置1，可能永远等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> process P1:</span><br><span class="line">inside1 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> inside2; <span class="comment">//等待P2退出临界区</span></span><br><span class="line">临界区;</span><br><span class="line">inside1 = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>临界区管理软件方法：</strong></p><ol><li><p>Dekker算法</p><blockquote><p>基本思想：</p><ol><li>进程P1进入临界区时，将inside1置为true。</li><li>若P2在临界区，则P1等待。若P2不在临界区但也想进入，询问turn变量，由turn指示谁进入。若P2不在临界区且不想进入临界区，那么P1进入临界区。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Peterson算法</p><blockquote><p>基本思想：</p><ol><li>进程P1进入临界区时，将inside1置为true，指示器turn置为2。</li><li>若P2在临界区内且turn为2，则P1等待。否则P1进入临界区，然后inside1置为false。</li></ol><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; TODO</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ol><hr><p><strong>临界区管理硬件方法：</strong></p><ol><li><p>关中断</p><p> 进入临界区前关中断，进入临界区，出临界区后开中断</p></li><li><p>用TS指令(test and set)</p><p> 反复TS代表临界区的lock变量，即“上锁”，如果该临界区空闲，会返回true，否则返回false。如果空闲，就进入临界区，否则一直反复。出临界区后lock置为true，即“开锁”。</p><blockquote><p>TS(x)指令等价于这段代码</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TS</span><span class="params">(<span class="keyword">bool</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">true</span>)&#123;</span><br><span class="line">        x = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><ol start="3"><li><p>用SWAP指令(在x86-64架构下是XCHG指令)</p><p> 一开始置临界区的lock变量为false，进程P的变量为key，置为true。交换一次lock和key(“上锁”)就检测一次key，如果key为false，说明临界区此时为空闲，进入临界区，出来后再次交换lock和key，即“开锁”。</p><p> 代码：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> lock = <span class="literal">false</span>;</span><br><span class="line">cobegin</span><br><span class="line">    <span class="function">process <span class="title">P</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> key = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            SWAP(key, lock);    <span class="comment">//上锁</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(key);</span><br><span class="line">        临界区;</span><br><span class="line">        SWAP(key, lock);        <span class="comment">//开锁</span></span><br><span class="line">    &#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure></li></ol><hr><p><strong>进程同步问题</strong></p><p><del>书上没讲定义，按我的理解就是对共享资源的读写一致性问题，说白了还是前面的并发进程问题没解决呗</del>。</p><p>百度说，进程同步是指的进程相互协作、等待的过程。</p><p>同步的办法有3种，信号量与PV操作、管程、消息传递。</p><hr><p><strong>信号量与PV操作</strong></p><p>信号量用来表示一个物理资源的使用情况，PV操作用来控制资源使用。</p><p>同步原语：P(Proberen,测试)，V(Verhogen,增量)。</p><p>除了赋初值外，信号量只能由同步原语操作。</p><p>(所谓原语，就是一段在执行过程中不许中断的指令序列)</p><hr><p><strong>管程</strong></p><hr><p><strong>死锁问题</strong></p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/01/29/hello-world/"/>
      <url>/2019/01/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
